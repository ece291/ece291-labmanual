<!--
     ECE 291 Lab Manual

     $IdPath$
-->

<appendix id="inst-ref">
 <appendixinfo>
  <authorgroup>
   <author>
    <firstname>Julian</firstname>
    <surname>Hall</surname>
    <affiliation>
     <address><email>jules@acris.co.uk</email></address>
    </affiliation>
    <contrib>Originally written by </contrib>
   </author>

   <author>
    <firstname>Simon</firstname>
    <surname>Tantham</surname>
    <affiliation>
     <address><email>anakin@pobox.com</email></address>
    </affiliation>
   </author>
  </authorgroup>
 </appendixinfo>

 <title>x86 Instruction Reference</title>

 <para>This appendix provides a incomplete list of the machine
  instructions which NASM will assemble, and a short description of
  the function of each one.  SSE2, 3DNow!, Cyrix MMX, and some
  undocumented or obsoleted instructions are not included in this list
  due to space concerns in the lab manual.  See the NASM manual for a
  complete list of all the instructions NASM will assemble.</para>

 <para>It is not intended to be exhaustive documentation on the fine
  details of the instructions' function, such as which exceptions they
  can trigger: for such documentation, you should go to either Intel's
  Web site, <ulink
   url="http://developer.intel.com/design/Pentium4/manuals/">http://developer.intel.com/design/Pentium4/manuals/</ulink> 
  or AMD's Web site, <ulink
   url="http://www.amd.com/">http://www.amd.com/</ulink>.</para>

 <para>Instead, this appendix is intended primarily to provide
  documentation on the way the instructions may be used within NASM.
  For example, looking up <literal>LOOP</literal> will tell you that
  NASM allows &reg.cx; or &reg.ecx; to be specified as an optional
  second argument to the <literal>LOOP</literal> instruction, to
  enforce which of the two possible counter registers should be used
  if the default is not the one desired.</para>

 <para>The instructions are not quite listed in alphabetical order,
  since groups of instructions with similar functions are lumped
  together in the same entry.  Most of them don't move very far from
  their alphabetic position because of this.</para>

 <sect1 id="inst-ref-operand-spec">
  <title>Key to Operand Specifications</title>

  <para>The instruction descriptions in this appendix specify their
   operands using the following notation:</para>

  <variablelist>
   <varlistentry>
    <term>Registers</term>

    <indexterm>
     <primary>general purpose register</primary>
    </indexterm>

    <listitem>
     <para><literal>reg8</literal> denotes an 8-bit general purpose
      register, <literal>reg16</literal> denotes a 16-bit general
      purpose register, and <literal>reg32</literal> a 32-bit one.
      <literal>fpureg</literal> denotes one of the eight FPU stack
      registers, <literal>mmxreg</literal> denotes one of the eight
      64-bit MMX registers, and <literal>segreg</literal> denotes a
      segment register. In addition, some registers (such as &reg.al;,
      &reg.dx; or &reg.ecx;) may be specified explicitly.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Immediate operands</term>

    <indexterm>
     <primary>immediate operand</primary>
    </indexterm>

    <listitem>
     <para><literal>imm</literal> denotes a generic immediate operand.
      <literal>imm8</literal>, <literal>imm16</literal> and
      <literal>imm32</literal> are used when the operand is intended
      to be a specific size. For some of these instructions, NASM
      needs an explicit specifier: for example, <literal>ADD
       ESP,16</literal> could be interpreted as either <literal>ADD
       r/m32,imm32</literal> or <literal>ADD r/m32,imm8</literal>.
      NASM chooses the former by default, and so you must specify
      <literal>ADD ESP,BYTE 16</literal> for the latter.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Memory references</term>

    <indexterm>
     <primary>memory reference</primary>
    </indexterm>

    <listitem>
     <para><literal>mem</literal> denotes a generic memory reference;
      <literal>mem8</literal>, <literal>mem16</literal>,
      <literal>mem32</literal>, <literal>mem64</literal> and
      <literal>mem80</literal> are used when the operand needs to be a
      specific size.  Again, a specifier is needed in some cases:
      <literal>DEC [address]</literal> is ambiguous and will be
      rejected by NASM.  You must specify <literal>DEC BYTE
       [address]</literal>, <literal>DEC WORD [address]</literal> or
      <literal>DEC DWORD [address]</literal> instead.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Restricted memory references</term>

    <indexterm>
     <primary>Restricted memory references</primary>
    </indexterm>

    <listitem>
     <para>One form of the <literal>MOV</literal> instruction allows a
      memory address to be specified <emphasis>without</emphasis>
      allowing the normal range of register combinations and effective
      address processing. This is denoted by
      <literal>memoffs8</literal>, <literal>memoffs16</literal> and
      <literal>memoffs32</literal>.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Register or memory choices</term>

    <listitem>
     <para>Many instructions can accept either a register
      <emphasis>or</emphasis> a memory reference as an operand.
      <literal>r/m8</literal> is a shorthand for
      <literal>reg8/mem8</literal>; similarly <literal>r/m16</literal>
      and <literal>r/m32</literal>.  <literal>r/m64</literal> is
      MMX-related, and is a shorthand for
      <literal>mmxreg/mem64</literal>.</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>

 <sect1 id="inst-ref-opcode-desc">
  <title>Key to Opcode Descriptions</title>

  <indexterm>
   <primary>ModR/M byte</primary>
  </indexterm>

  <indexterm>
   <primary>SIB byte</primary>
  </indexterm>

  <para>This appendix also provides the opcodes which NASM will
   generate for each form of each instruction. The opcodes are listed
   in the following way:</para>

  <itemizedlist>
   <listitem>
    <para>A hex number, such as <literal>3F</literal>, indicates a
     fixed byte containing that number.</para>
   </listitem>

   <listitem>
    <para>A hex number followed by <literal>+r</literal>, such as
     <literal>C8+r</literal>, indicates that one of the operands to
     the instruction is a register, and the `register value' of that
     register should be added to the hex number to produce the
     generated byte. For example, &reg.edx; has register value 2, so
     the code <literal>C8+r</literal>, when the register operand is
     &reg.edx;, generates the hex byte <literal>CA</literal>. Register
     values for specific registers are given in <xref
      linkend="inst-ref-opcode-desc-reg-values">.</para>
   </listitem>

   <listitem>
    <para>A hex number followed by <literal>+cc</literal>, such as
     <literal>40+cc</literal>, indicates that the instruction name has
     a condition code suffix, and the numeric representation of the
     condition code should be added to the hex number to produce the
     generated byte. For example, the code <literal>40+cc</literal>,
     when the instruction contains the <literal>NE</literal>
     condition, generates the hex byte <literal>45</literal>.
     Condition codes and their numeric representations are given in
     <xref
      linkend="inst-ref-opcode-desc-cond-codes">.</para>
   </listitem>

   <listitem>
    <para>A slash followed by a digit, such as <literal>/2</literal>,
     indicates that one of the operands to the instruction is a memory
     address or register (denoted <literal>mem</literal> or
     <literal>r/m</literal>, with an optional size). This is to be
     encoded as an effective address, with a ModR/M byte, an optional
     SIB byte, and an optional displacement, and the spare (register)
     field of the ModR/M byte should be the digit given (which will be
     from 0 to 7, so it fits in three bits). The encoding of effective
     addresses is given in <xref
      linkend="inst-ref-opcode-desc-eff-addr">.</para>
   </listitem>

   <listitem>
    <para>The code <literal>/r</literal> combines the above two: it
     indicates that one of the operands is a memory address or
     <literal>r/m</literal>, and another is a register, and that an
     effective address should be generated with the spare (register)
     field in the ModR/M byte being equal to the <quote>register
      value</quote> of the register operand. The encoding of effective
     addresses is given in <xref
      linkend="inst-ref-opcode-desc-eff-addr">; register values are
     given in <xref linkend="inst-ref-opcode-desc-reg-values">.</para>
   </listitem>

   <listitem>
    <para>The codes <literal>ib</literal>, <literal>iw</literal> and
     <literal>id</literal> indicate that one of the operands to the
     instruction is an immediate value, and that this is to be encoded
     as a byte, little-endian word or little-endian doubleword
     respectively.</para>
   </listitem>

   <listitem>
    <para>The codes <literal>rb</literal>, <literal>rw</literal> and
     <literal>rd</literal> indicate that one of the operands to the
     instruction is an immediate value, and that the
     <emphasis>difference</emphasis> between this value and the
     address of the end of the instruction is to be encoded as a byte,
     word or doubleword respectively. Where the form
     <literal>rw/rd</literal> appears, it indicates that either
     <literal>rw</literal> or <literal>rd</literal> should be used
     according to whether assembly is being performed in <literal>BITS
      16</literal> or <literal>BITS 32</literal> state
     respectively.</para>
   </listitem>

   <listitem>
    <para>The codes <literal>ow</literal> and <literal>od</literal>
     indicate that one of the operands to the instruction is a
     reference to the contents of a memory address specified as an
     immediate value: this encoding is used in some forms of the
     <literal>MOV</literal> instruction in place of the standard
     effective-address mechanism. The displacement is encoded as a
     word or doubleword. Again, <literal>ow/od</literal> denotes that
     <literal>ow</literal> or <literal>od</literal> should be chosen
     according to the <literal>BITS</literal> setting.</para>
   </listitem>

   <listitem>
    <para>The codes <literal>o16</literal> and <literal>o32</literal>
     indicate that the given form of the instruction should be
     assembled with operand size 16 or 32 bits. In other words,
     <literal>o16</literal> indicates a <literal>66</literal> prefix
     in <literal>BITS 32</literal> state, but generates no code in
     <literal>BITS 16</literal> state; and <literal>o32</literal>
     indicates a <literal>66</literal> prefix in <literal>BITS
      16</literal> state but generates nothing in <literal>BITS
      32</literal>.</para>
   </listitem>

   <listitem>
    <para>The codes <literal>a16</literal> and <literal>a32</literal>,
     similarly to <literal>o16</literal> and <literal>o32</literal>,
     indicate the address size of the given form of the instruction.
     Where this does not match the <literal>BITS</literal> setting, a
     <literal>67</literal> prefix is required.</para>
   </listitem>
  </itemizedlist>

  <sect2 id="inst-ref-opcode-desc-reg-values">
   <title>Register Values</title>

   <para>Where an instruction requires a register value, it is already
    implicit in the encoding of the rest of the instruction what type
    of register is intended: an 8-bit general-purpose register, a
    segment register, a debug register, an MMX register, or whatever.
    Therefore there is no problem with registers of different types
    sharing an encoding value.</para>

   <para>The encodings for the various classes of register are:</para>

   <variablelist>
    <varlistentry>
     <term>8-bit general registers</term>

     <listitem>
      <para>&reg.al; is 0, &reg.cl; is 1, &reg.dl; is 2, &reg.bl; is
       3, &reg.ah; is 4, &reg.ch; is 5, &reg.dh; is 6, and &reg.bh; is
       7.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>16-bit general registers</term>

     <listitem>
      <para>&reg.ax; is 0, &reg.cx; is 1, &reg.dx; is 2, &reg.bx; is
       3, &reg.sp; is 4, &reg.bp; is 5, &reg.si; is 6, and &reg.di; is
       7.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>32-bit general registers</term>

     <listitem>
      <para>&reg.eax; is 0, &reg.ecx; is 1, &reg.edx; is 2, &reg.ebx;
       is 3, &reg.esp; is 4, &reg.ebp; is 5, &reg.esi; is 6, and
       &reg.edi; is 7.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Segment registers</term>

     <indexterm>
      <primary>Segment registers</primary>
     </indexterm>

     <listitem>
      <para>&reg.es; is 0, &reg.cs; is 1, &reg.ss; is 2, &reg.ds; is
       3, &reg.fs; is 4, and &reg.gs; is 5.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Floating-point registers</term>

     <indexterm>
      <primary>floating-point</primary>
      <secondary>registers</secondary>
     </indexterm>

     <listitem>
      <para>&reg.st0; is 0, &reg.st1; is 1, &reg.st2; is 2, &reg.st3;
       is 3, &reg.st4; is 4, &reg.st5; is 5, &reg.st6; is 6, and
       &reg.st7; is 7.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>64-bit MMX registers</term>

     <indexterm>
      <primary>MMX registers</primary>
     </indexterm>

     <listitem>
      <para>&reg.mm0; is 0, &reg.mm1; is 1, &reg.mm2; is 2, &reg.mm3;
       is 3, &reg.mm4; is 4, &reg.mm5; is 5, &reg.mm6; is 6, and
       &reg.mm7; is 7.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Control registers</term>

     <indexterm>
      <primary>Control registers</primary>
     </indexterm>

     <listitem>
      <para>&reg.cr0; is 0, &reg.cr2; is 2, &reg.cr3; is 3, and
       &reg.cr4; is 4.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Debug registers</term>

     <indexterm>
      <primary>Debug registers</primary>
     </indexterm>

     <listitem>
      <para>&reg.dr0; is 0, &reg.dr1; is 1, &reg.dr2; is 2, &reg.dr3;
       is 3, &reg.dr6; is 6, and &reg.dr7; is 7.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Test registers</term>

     <indexterm>
      <primary>Test registers</primary>
     </indexterm>

     <listitem>
      <para>&reg.tr3; is 3, &reg.tr4; is 4, &reg.tr5; is 5, &reg.tr6;
       is 6, and &reg.tr7; is 7.</para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>(Note that wherever a register name contains a number, that
    number is also the register value for that register.)</para>
  </sect2>

  <sect2 id="inst-ref-opcode-desc-cond-codes">
   <title>Condition Codes</title>

   <indexterm>
    <primary>Condition Codes</primary>
   </indexterm>

   <para>The available condition codes are given here, along with
    their numeric representations as part of opcodes. Many of these
    condition codes have synonyms, so several will be listed at a
    time.</para>

   <para>In the following descriptions, the word
    <quote>either,</quote> when applied to two possible trigger
    conditions, is used to mean <quote>either or both</quote>. If
    <quote>either but not both</quote> is meant, the phrase
    <quote>exactly one of</quote> is used.</para>

   <itemizedlist>
    <listitem>
     <para><literal>O</literal> is 0 (trigger if the overflow flag is
      set); <literal>NO</literal> is 1.</para>
    </listitem>

    <listitem>
     <para><literal>B</literal>, <literal>C</literal> and
      <literal>NAE</literal> are 2 (trigger if the carry flag is set);
      <literal>AE</literal>, <literal>NB</literal> and
      <literal>NC</literal> are 3.</para>
    </listitem>

    <listitem>
     <para><literal>E</literal> and <literal>Z</literal> are 4
      (trigger if the zero flag is set); <literal>NE</literal> and
      <literal>NZ</literal> are 5.</para>
    </listitem>

    <listitem>
     <para><literal>BE</literal> and <literal>NA</literal> are 6
      (trigger if either of the carry or zero flags is set);
      <literal>A</literal> and <literal>NBE</literal> are 7.</para>
    </listitem>

    <listitem>
     <para><literal>S</literal> is 8 (trigger if the sign flag is
      set); <literal>NS</literal> is 9.</para>
    </listitem>

    <listitem>
     <para><literal>P</literal> and <literal>PE</literal> are 10
      (trigger if the parity flag is set); <literal>NP</literal> and
      <literal>PO</literal> are 11.</para>
    </listitem>

    <listitem>
     <para><literal>L</literal> and <literal>NGE</literal> are 12
      (trigger if exactly one of the sign and overflow flags is set);
      <literal>GE</literal> and <literal>NL</literal> are 13.</para>
    </listitem>

    <listitem>
     <para><literal>LE</literal> and <literal>NG</literal> are 14
      (trigger if either the zero flag is set, or exactly one of the
      sign and overflow flags is set); <literal>G</literal> and
      <literal>NLE</literal> are 15.</para>
    </listitem>
   </itemizedlist>

   <para>Note that in all cases, the sense of a condition code may be
    reversed by changing the low bit of the numeric
    representation.</para>
  </sect2>

  <sect2 id="inst-ref-opcode-desc-sse-cc">
   <title>SSE Condition Predicates</title>

   <indexterm significance="preferred">
    <primary>SSE Condition Predicates</primary>
   </indexterm>

   <para>The condition predicates for SSE comparison instructions are
    the codes used as part of the opcode, to determine what form of
    comparison is being carried out. In each case, the imm8 value is
    the final byte of the opcode encoding, and the predicate is the
    code used as part of the mnemonic for the instruction (equivalent
    to the "cc" in an integer instruction that used a condition code).
    The instructions that use this will give details of what the
    various mnemonics are, this table is used to help you work out
    details of what is happening.</para>

   <table frame="none">
    <title>SSE Condition Predicate Encoding</title>

    <tgroup cols="7">
     <colspec colname="predicate">
     <colspec colname="encoding">
     <colspec colname="description">
     <colspec colname="relation">
     <colspec colname="emulation">
     <colspec colname="result">
     <colspec colname="signals">

     <thead>
      <row>
       <entry>Predicate</entry>
       <entry>imm8 Encoding</entry>
       <entry>Description</entry>
       <entry>Relation where A is 1st Operand, B is 2nd Operand</entry>
       <entry>Emulation</entry>
       <entry>Result if NaN Operand</entry>
       <entry>QNan Signals Invalid</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>EQ</entry>
       <entry>000B</entry>
       <entry>equal</entry>
       <entry>A = B</entry>
       <entry></entry>
       <entry>False</entry>
       <entry>No</entry>
      </row>

      <row>
       <entry>LT</entry>
       <entry>001B</entry>
       <entry>less than</entry>
       <entry>A < B</entry>
       <entry></entry>
       <entry>False</entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry>LE</entry>
       <entry>010B</entry>
       <entry>less than or equal</entry>
       <entry>A <= B</entry>
       <entry></entry>
       <entry>False</entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry>---</entry>
       <entry>---</entry>
       <entry>greater than</entry>
       <entry>A > B</entry>
       <entry>Swap Operands, Use LT</entry>
       <entry>False</entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry>---</entry>
       <entry>---</entry>
       <entry>greater than or equal</entry>
       <entry>A >= B</entry>
       <entry>Swap Operands, Use LE</entry>
       <entry>False</entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry>UNORD</entry>
       <entry>011B</entry>
       <entry>unordered</entry>
       <entry>A, B = Unordered</entry>
       <entry></entry>
       <entry>True</entry>
       <entry>No</entry>
      </row>

      <row>
       <entry>NEQ</entry>
       <entry>100B</entry>
       <entry>not equal</entry>
       <entry>A != B</entry>
       <entry></entry>
       <entry>True</entry>
       <entry>No</entry>
      </row>

      <row>
       <entry>NLT</entry>
       <entry>101B</entry>
       <entry>not less than</entry>
       <entry>NOT(A < B)</entry>
       <entry></entry>
       <entry>True</entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry>NLE</entry>
       <entry>110B</entry>
       <entry>not less than or equal</entry>
       <entry>NOT(A <= B)</entry>
       <entry></entry>
       <entry>True</entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry>---</entry>
       <entry>---</entry>
       <entry>not greater than</entry>
       <entry>NOT(A > B)</entry>
       <entry>Swap Operands, Use NLT</entry>
       <entry>True</entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry>---</entry>
       <entry>---</entry>
       <entry>not greater than or equal</entry>
       <entry>NOT(A >= B)</entry>
       <entry>Swap Operands, Use NLE</entry>
       <entry>True</entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry>ORD</entry>
       <entry>111B</entry>
       <entry>ordered</entry>
       <entry>A, B = Ordered</entry>
       <entry></entry>
       <entry>False</entry>
       <entry>No</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>The unordered relationship is true when at least one of the
    two values being compared is a NaN or in an unsupported
    format.</para>

   <para>Note that the comparisons which are listed as not having a
    predicate or encoding can only be achieved through software
    emulation, as described in the <quote>emulation</quote> column.
    Note in particular that an instruction such as <quote>greater
     than</quote> is not the same as <literal>NLE</literal>, as,
    unlike with the <literal>CMP</literal> instruction, it has to take
    into account the possibility of one operand containing a NaN or an
    unsupported numeric format.</para>
  </sect2>

  <sect2 id="inst-ref-opcode-desc-eff-addr">
   <title>Effective Address Encoding: ModR/M and SIB</title>

   <indexterm significance="preferred">
    <primary>ModR/M byte</primary>
   </indexterm>

   <indexterm significance="preferred">
    <primary>SIB byte</primary>
   </indexterm>

   <indexterm significance="preferred">
    <primary>effective addresses</primary>
   </indexterm>

   <para>An effective address is encoded in up to three parts: a
    ModR/M byte, an optional SIB byte, and an optional byte, word or
    doubleword displacement field.</para>

   <para>The ModR/M byte consists of three fields: the
    <literal>mod</literal> field, ranging from 0 to 3, in the upper
    two bits of the byte, the <literal>r/m</literal> field, ranging
    from 0 to 7, in the lower three bits, and the spare (register)
    field in the middle (bit 3 to bit 5). The spare field is not
    relevant to the effective address being encoded, and either
    contains an extension to the instruction opcode or the register
    value of another operand.</para>

   <para>The ModR/M system can be used to encode a direct register
    reference rather than a memory access. This is always done by
    setting the <literal>mod</literal> field to 3 and the
    <literal>r/m</literal> field to the register value of the register
    in question (it must be a general-purpose register, and the size
    of the register must already be implicit in the encoding of the
    rest of the instruction).  In this case, the SIB byte and
    displacement field are both absent.</para>

   <para>In 16-bit addressing mode (either <literal>BITS 16</literal>
    with no <literal>67</literal> prefix, or <literal>BITS
     32</literal> with a <literal>67</literal> prefix), the SIB byte
    is never used. The general rules for <literal>mod</literal> and
    <literal>r/m</literal> (there is an exception, given below)
    are:</para>

   <itemizedlist>
    <listitem>
     <para>The <literal>mod</literal> field gives the length of the
      displacement field: 0 means no displacement, 1 means one byte,
      and 2 means two bytes.</para>
    </listitem>

    <listitem>
     <para>The <literal>r/m</literal> field encodes the combination of
      registers to be added to the displacement to give the accessed
      address: 0 means <literal>&reg.bx;+&reg.si;</literal>, 1 means
      <literal>&reg.bx;+&reg.di;</literal>, 2 means
      <literal>&reg.bp;+&reg.si;</literal>, 3 means
      <literal>&reg.bp;+&reg.di;</literal>, 4 means &reg.si; only,
      5 means &reg.di; only, 6 means &reg.bp; only, and 7 means
      &reg.bx; only.</para>
    </listitem>
   </itemizedlist>

   <para>However, there is a special case:</para>

   <itemizedlist>
    <listitem>
     <para>If <literal>mod</literal> is 0 and <literal>r/m</literal>
      is 6, the effective address encoded is not
      <literal>[&reg.bp;]</literal> as the above rules would suggest,
      but instead <literal>[disp16]</literal>: the displacement field
      is present and is two bytes long, and no registers are added to
      the displacement.</para>
    </listitem>
   </itemizedlist>

   <para>Therefore the effective address <literal>[&reg.bp;]</literal>
    cannot be encoded as efficiently as <literal>[&reg.bx;]</literal>;
    so if you code <literal>[&reg.bp;]</literal> in a program, NASM
    adds a notional 8-bit zero displacement, and sets
    <literal>mod</literal> to 1, <literal>r/m</literal> to 6, and the
    one-byte displacement field to 0.</para>

   <para>In 32-bit addressing mode (either <literal>BITS 16</literal>
    with a <literal>67</literal> prefix, or <literal>BITS 32</literal>
    with no <literal>67</literal> prefix) the general rules (again,
    there are exceptions) for <literal>mod</literal> and
    <literal>r/m</literal> are:</para>

   <itemizedlist>
    <listitem>
     <para>The <literal>mod</literal> field gives the length of the
      displacement field: 0 means no displacement, 1 means one byte,
      and 2 means four bytes.</para>
    </listitem>

    <listitem>
     <para>If only one register is to be added to the displacement,
      and it is not &reg.esp;, the <literal>r/m</literal> field gives
      its register value, and the SIB byte is absent. If the
      <literal>r/m</literal> field is 4 (which would encode
      &reg.esp;), the SIB byte is present and gives the combination
      and scaling of registers to be added to the displacement.</para>
    </listitem>
   </itemizedlist>

   <para>If the SIB byte is present, it describes the combination of
    registers (an optional base register, and an optional index
    register scaled by multiplication by 1, 2, 4 or 8) to be added to
    the displacement. The SIB byte is divided into the
    <literal>scale</literal> field, in the top two bits, the
    <literal>index</literal> field in the next three, and the
    <literal>base</literal> field in the bottom three. The general
    rules are:</para>

   <itemizedlist>
    <listitem>
     <para>The <literal>base</literal> field encodes the register
      value of the base register.</para>
    </listitem>

    <listitem>
     <para>The <literal>index</literal> field encodes the register
      value of the index register, unless it is 4, in which case no
      index register is used (so &reg.esp; cannot be used as an index
      register).</para>
    </listitem>

    <listitem>
     <para>The <literal>scale</literal> field encodes the multiplier
      by which the index register is scaled before adding it to the
      base and displacement: 0 encodes a multiplier of 1, 1 encodes 2,
      2 encodes 4 and 3 encodes 8.</para>
    </listitem>
   </itemizedlist>

   <para>The exceptions to the 32-bit encoding rules are:</para>

   <itemizedlist>
    <listitem>
     <para>If <literal>mod</literal> is 0 and <literal>r/m</literal>
      is 5, the effective address encoded is not
      <literal>[&reg.ebp;]</literal> as the above rules would suggest,
      but instead <literal>[disp32]</literal>: the displacement field
      is present and is four bytes long, and no registers are added to
      the displacement.</para>
    </listitem>

    <listitem>
     <para>If <literal>mod</literal> is 0, <literal>r/m</literal> is 4
      (meaning the SIB byte is present) and <literal>base</literal> is
      4, the effective address encoded is not
      <literal>[&reg.ebp;+index]</literal> as the above rules would
      suggest, but instead <literal>[disp32+index]</literal>: the
      displacement field is present and is four bytes long, and there
      is no base register (but the index register is still processed
      in the normal way).</para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>

 <sect1 id="inst-ref-flags">
  <title>Key to Instruction Flags</title>

  <para>Given along with each instruction in this appendix is a set of
   flags, denoting the type of the instruction. The types are as
   follows:</para>

  <itemizedlist>
   <listitem>
    <para><literal>8086</literal>, <literal>186</literal>,
     <literal>286</literal>, <literal>386</literal>,
     <literal>486</literal>, <literal>PENT</literal> and
     <literal>P6</literal> denote the lowest processor type that
     supports the instruction. Most instructions run on all processors
     above the given type; those that do not are documented. The
     Pentium II contains no additional instructions beyond the P6
     (Pentium Pro); from the point of view of its instruction set, it
     can be thought of as a P6 with MMX capability.</para>
   </listitem>

   <listitem>
    <para><literal>3DNOW</literal> indicates that the instruction is a
     3DNow! one, and will run on the AMD K6-2 and later processors.
     ATHLON extensions to the 3DNow! instruction set are documented as
     such.</para>
   </listitem>

   <listitem>
    <para><literal>CYRIX</literal> indicates that the instruction is
     specific to Cyrix processors, for example the extra MMX
     instructions in the Cyrix extended MMX instruction set.</para>
   </listitem>

   <listitem>
    <para><literal>FPU</literal> indicates that the instruction is a
     floating-point one, and will only run on machines with a
     coprocessor (automatically including 486DX, Pentium and
     above).</para>
   </listitem>

   <listitem>
    <para><literal>KATMAI</literal> indicates that the instruction was
     introduced as part of the Katmai New Instruction set. These
     instructions are available on the Pentium III and later
     processors. Those which are not specifically SSE instructions are
     also available on the AMD Athlon.</para>
   </listitem>

   <listitem>
    <para><literal>MMX</literal> indicates that the instruction is an
     MMX one, and will run on MMX-capable Pentium processors and the
     Pentium II.</para>
   </listitem>

   <listitem>
    <para><literal>PRIV</literal> indicates that the instruction is a
     protected-mode management instruction. Many of these may only be
     used in protected mode, or only at privilege level zero.</para>
   </listitem>

   <listitem>
    <para><literal>SSE</literal> and <literal>SSE2</literal> indicate
     that the instruction is a Streaming SIMD Extension instruction.
     These instructions operate on multiple values in a single
     operation. SSE was introduced with the Pentium III and SSE2 was
     introduced with the Pentium 4.</para>
   </listitem>

   <listitem>
    <para><literal>UNDOC</literal> indicates that the instruction is
     an undocumented one, and not part of the official Intel
     Architecture; it may or may not be supported on any given
     machine.</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-aaa">
  <title><literal>AAA</literal>, <literal>AAS</literal>,
   <literal>AAM</literal>, <literal>AAD</literal>: ASCII
   Adjustments</title>

  <indexterm>
   <primary><literal>AAA</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>AAS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>AAM</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>AAD</literal></primary>
  </indexterm>

  <screen>AAA                           ; 37                   [8086]

AAS                           ; 3F                   [8086]

AAD                           ; D5 0A                [8086]
AAD imm                       ; D5 ib                [8086]

AAM                           ; D4 0A                [8086]
AAM imm                       ; D4 ib                [8086]</screen>

  <para>These instructions are used in conjunction with the add,
   subtract, multiply and divide instructions to perform binary-coded
   decimal arithmetic in <emphasis>unpacked</emphasis> (one BCD digit
   per byte - easy to translate to and from <literal>ASCII</literal>,
   hence the instruction names) form. There are also packed BCD
   instructions <literal>DAA</literal> and <literal>DAS</literal>: see
   <xref linkend="inst-ref-daa">.</para>

  <itemizedlist>
   <listitem>
    <para><literal>AAA</literal> (ASCII Adjust After Addition) should
     be used after a one-byte <literal>ADD</literal> instruction whose
     destination was the &reg.al; register: by means of examining the
     value in the low nibble of &reg.al; and also the auxiliary carry
     flag &flag.af;, it determines whether the addition has
     overflowed, and adjusts it (and sets the carry flag) if so. You
     can add long BCD strings together by doing
     <literal>ADD</literal>/<literal>AAA</literal> on the low digits,
     then doing <literal>ADC</literal>/<literal>AAA</literal> on each
     subsequent digit.</para>
   </listitem>

   <listitem>
    <para><literal>AAS</literal> (ASCII Adjust &reg.al; After
     Subtraction) works similarly to <literal>AAA</literal>, but is
     for use after <literal>SUB</literal> instructions rather than
     <literal>ADD</literal>.</para>
   </listitem>

   <listitem>
    <para><literal>AAM</literal> (ASCII Adjust &reg.ax; After
     Multiply) is for use after you have multiplied two decimal digits
     together and left the result in &reg.al;: it divides &reg.al; by
     ten and stores the quotient in &reg.ah;, leaving the remainder in
     &reg.al;. The divisor 10 can be changed by specifying an operand
     to the instruction: a particularly handy use of this is
     <literal>AAM 16</literal>, causing the two nibbles in &reg.al; to
     be separated into &reg.ah; and &reg.al;.</para>
   </listitem>

   <listitem>
    <para><literal>AAD</literal> (ASCII Adjust &reg.ax; Before
     Division) performs the inverse operation to
     <literal>AAM</literal>: it multiplies &reg.ah; by ten, adds it to
     &reg.al;, and sets &reg.ah; to zero. Again, the multiplier 10 can
     be changed.</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-adc">
  <title><literal>ADC</literal>: Add with Carry</title>

  <indexterm>
   <primary><literal>ADC</literal></primary>
  </indexterm>

  <screen>ADC r/m8,reg8                 ; 10 /r                [8086]
ADC r/m16,reg16               ; o16 11 /r            [8086]
ADC r/m32,reg32               ; o32 11 /r            [386]

ADC reg8,r/m8                 ; 12 /r                [8086]
ADC reg16,r/m16               ; o16 13 /r            [8086]
ADC reg32,r/m32               ; o32 13 /r            [386]

ADC r/m8,imm8                 ; 80 /2 ib             [8086]
ADC r/m16,imm16               ; o16 81 /2 iw         [8086]
ADC r/m32,imm32               ; o32 81 /2 id         [386]

ADC r/m16,imm8                ; o16 83 /2 ib         [8086]
ADC r/m32,imm8                ; o32 83 /2 ib         [386]

ADC AL,imm8                   ; 14 ib                [8086]
ADC AX,imm16                  ; o16 15 iw            [8086]
ADC EAX,imm32                 ; o32 15 id            [386]</screen>

  <para><literal>ADC</literal> performs integer addition: it adds its
   two operands together, plus the value of the carry flag, and leaves
   the result in its destination (first) operand.  The destination
   operand can be a register or a memory location.  The source operand
   can be a register, a memory locaion, or an immediate value.</para>

  <para>The flags are set according to the result of the operation: in
   particular, the carry flag is affected and can be used by a
   subsequent <literal>ADC</literal> instruction.</para>

  <para>In the forms with an 8-bit immediate second operand and a
   longer first operand, the second operand is considered to be
   signed, and is sign-extended to the length of the first operand. In
   these cases, the <literal>BYTE</literal> qualifier is necessary to
   force NASM to generate this form of the instruction.</para>

  <para>To add two numbers without also adding the contents of the
   carry flag, use <literal>ADD</literal> (<xref
    linkend="inst-ref-add">).</para>
 </sect1>

 <sect1 id="inst-ref-add">
  <title><literal>ADD</literal>: Add Integers</title>

  <indexterm>
   <primary><literal>ADD</literal></primary>
  </indexterm>

  <screen>ADD r/m8,reg8                 ; 00 /r                [8086]
ADD r/m16,reg16               ; o16 01 /r            [8086]
ADD r/m32,reg32               ; o32 01 /r            [386]

ADD reg8,r/m8                 ; 02 /r                [8086]
ADD reg16,r/m16               ; o16 03 /r            [8086]
ADD reg32,r/m32               ; o32 03 /r            [386]

ADD r/m8,imm8                 ; 80 /0 ib             [8086]
ADD r/m16,imm16               ; o16 81 /0 iw         [8086]
ADD r/m32,imm32               ; o32 81 /0 id         [386]

ADD r/m16,imm8                ; o16 83 /0 ib         [8086]
ADD r/m32,imm8                ; o32 83 /0 ib         [386]

ADD AL,imm8                   ; 04 ib                [8086]
ADD AX,imm16                  ; o16 05 iw            [8086]
ADD EAX,imm32                 ; o32 05 id            [386]</screen>

  <para><literal>ADD</literal> performs integer addition: it adds its
   two operands together, and leaves the result in its destination
   (first) operand.  The destination operand can be a register or a
   memory location.  The source operand can be a register, a memory
   location, or an immediate value.</para>

  <para>The flags are set according to the result of the operation: in
   particular, the carry flag is affected and can be used by a
   subsequent <literal>ADC</literal> instruction.</para>

  <para>In the forms with an 8-bit immediate second operand and a
   longer first operand, the second operand is considered to be
   signed, and is sign-extended to the length of the first operand. In
   these cases, the <literal>BYTE</literal> qualifier is necessary to
   force NASM to generate this form of the instruction.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-addpd">
  <title><literal>ADDPD</literal>: ADD Packed Double-Precision FP
   Values</title>

  <indexterm>
   <primary><literal>ADDPD</literal></primary>
  </indexterm>

  <screen>ADDPD xmm1,xmm2/mem128        ; 66 0F 58 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>ADDPD</literal> performs addition on each of two
   packed double-precision FP value pairs:</para>

  <screen>    dst[0-63]   := dst[0-63]   + src[0-63],
    dst[64-127] := dst[64-127] + src[64-127].</screen>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 128-bit memory
   location.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-addps">
  <title><literal>ADDPS</literal>: Add Packed Single-Precision FP
   Values</title>

  <indexterm>
   <primary><literal>ADDPS</literal></primary>
  </indexterm>

  <screen>ADDPS xmm1,xmm2/mem128        ; 0F 58 /r        [KATMAI,SSE]</screen>

  <para><literal>ADDPS</literal> performs addition on each of four
   packed single-precision FP value pairs:</para>

  <screen>   dst[0-31]   := dst[0-31]   + src[0-31],
   dst[32-63]  := dst[32-63]  + src[32-63],
   dst[64-95]  := dst[64-95]  + src[64-95],
   dst[96-127] := dst[96-127] + src[96-127].</screen>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 128-bit memory
   location.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-addsd">
  <title><literal>ADDSD</literal>: Add Scalar Double-Precision FP
   Values</title>

  <indexterm>
   <primary><literal>ADDSD</literal></primary>
  </indexterm>

  <screen>ADDSD xmm1,xmm2/mem32         ; F3 0F 58 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>ADDSD</literal> adds the low double-precision FP
   values from the source and destination operands and stores the
   double-precision FP result in the destination operand.</para>

  <screen>   dst[0-63]   := dst[0-63] + src[0-63],
   dst[64-127) remains unchanged.</screen>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 64-bit memory
   location.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-addss">
  <title><literal>ADDSS</literal>: Add Scalar Single-Precision FP
   Values</title>

  <indexterm>
   <primary><literal>ADDSS</literal></primary>
  </indexterm>

  <screen>ADDSS xmm1,xmm2/mem64         ; F2 0F 58 /r     [KATMAI,SSE]</screen>

  <para><literal>ADDSS</literal> adds the low single-precision FP
   values from the source and destination operands and stores the
   single-precision FP result in the destination operand.</para>

  <screen>   dst[0-31]   := dst[0-31] + src[0-31],
   dst[32-127] remains unchanged.</screen>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 32-bit memory
   location.</para>
 </sect1>

 <sect1 id="inst-ref-and">
  <title><literal>AND</literal>: Bitwise AND</title>

  <indexterm>
   <primary><literal>AND</literal></primary>
  </indexterm>

  <screen>AND r/m8,reg8                 ; 20 /r                [8086]
AND r/m16,reg16               ; o16 21 /r            [8086]
AND r/m32,reg32               ; o32 21 /r            [386]

AND reg8,r/m8                 ; 22 /r                [8086]
AND reg16,r/m16               ; o16 23 /r            [8086]
AND reg32,r/m32               ; o32 23 /r            [386]

AND r/m8,imm8                 ; 80 /4 ib             [8086]
AND r/m16,imm16               ; o16 81 /4 iw         [8086]
AND r/m32,imm32               ; o32 81 /4 id         [386]

AND r/m16,imm8                ; o16 83 /4 ib         [8086]
AND r/m32,imm8                ; o32 83 /4 ib         [386]

AND AL,imm8                   ; 24 ib                [8086]
AND AX,imm16                  ; o16 25 iw            [8086]
AND EAX,imm32                 ; o32 25 id            [386]</screen>

  <para><literal>AND</literal> performs a bitwise AND operation
   between its two operands (i.e. each bit of the result is 1 if and
   only if the corresponding bits of the two inputs were both 1), and
   stores the result in the destination (first) operand.  The
   destination operand can be a register or a memory location.  The
   source operand can be a register, a memory location, or an
   immediate value.</para>

  <para>In the forms with an 8-bit immediate second operand and a
   longer first operand, the second operand is considered to be
   signed, and is sign-extended to the length of the first operand. In
   these cases, the <literal>BYTE</literal> qualifier is necessary to
   force NASM to generate this form of the instruction.</para>

  <para>The &reg.mmx; instruction <literal>PAND</literal> (see <xref
    linkend="inst-ref-pand">) performs the same operation on the
   64-bit &reg.mmx; registers.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-andnpd">
  <title><literal>ANDNPD</literal>: Bitwise Logical AND NOT of Packed
   Double-Precision FP Values</title>

  <indexterm>
   <primary><literal>ANDNPD</literal></primary>
  </indexterm>

  <screen>ANDNPD xmm1,xmm2/mem128       ; 66 0F 55 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>ANDNPD</literal> inverts the bits of the two
   double-precision floating-point values in the destination register,
   and then performs a logical AND between the two double-precision
   floating-point values in the source operand and the temporary
   inverted result, storing the result in the destination
   register.</para>

  <screen>   dst[0-63]   := src[0-63]   AND NOT dst[0-63],
   dst[64-127] := src[64-127] AND NOT dst[64-127].</screen>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 128-bit memory
   location.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-andnps">
  <title><literal>ANDNPS</literal>: Bitwise Logical AND NOT of Packed
   Single-Precision FP Values</title>

  <indexterm>
   <primary><literal>ANDNPS</literal></primary>
  </indexterm>

  <screen>ANDNPS xmm1,xmm2/mem128       ; 0F 55 /r        [KATMAI,SSE]</screen>

  <para><literal>ANDNPS</literal> inverts the bits of the four
   single-precision floating-point values in the destination register,
   and then performs a logical AND between the four single-precision
   floating-point values in the source operand and the temporary
   inverted result, storing the result in the destination
   register.</para>

  <screen>   dst[0-31]   := src[0-31]   AND NOT dst[0-31],
   dst[32-63]  := src[32-63]  AND NOT dst[32-63],
   dst[64-95]  := src[64-95]  AND NOT dst[64-95],
   dst[96-127] := src[96-127] AND NOT dst[96-127].</screen>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 128-bit memory
   location.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-andpd">
  <title><literal>ANDPD</literal>: Bitwise Logical AND For Single
   FP</title>

  <indexterm>
   <primary><literal>ANDPD</literal></primary>
  </indexterm>

  <screen>ANDPD xmm1,xmm2/mem128        ; 66 0F 54 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>ANDPD</literal> performs a bitwise logical AND of the
   two double-precision floating point values in the source and
   destination operand, and stores the result in the destination
   register.</para>

  <screen>   dst[0-63]   := src[0-63]   AND dst[0-63],
   dst[64-127] := src[64-127] AND dst[64-127].</screen>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 128-bit memory
   location.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-andps">
  <title><literal>ANDPS</literal>: Bitwise Logical AND For Single
   FP</title>

  <indexterm>
   <primary><literal>ANDPS</literal></primary>
  </indexterm>

  <screen>ANDPS xmm1,xmm2/mem128        ; 0F 54 /r        [KATMAI,SSE]</screen>

  <para><literal>ANDPS</literal> performs a bitwise logical AND of the
   four single-precision floating point values in the source and
   destination operand, and stores the result in the destination
   register.</para>

  <screen>   dst[0-31]   := src[0-31]   AND dst[0-31],
   dst[32-63]  := src[32-63]  AND dst[32-63],
   dst[64-95]  := src[64-95]  AND dst[64-95],
   dst[96-127] := src[96-127] AND dst[96-127].</screen>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 128-bit memory
   location.</para>
 </sect1>

 <sect1 id="inst-ref-arpl">
  <title><literal>ARPL</literal>: Adjust RPL Field of Selector</title>

  <indexterm>
   <primary><literal>ARPL</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>RPL</literal></primary>
  </indexterm>

  <screen>ARPL r/m16,reg16              ; 63 /r                [286,PRIV]</screen>

  <para><literal>ARPL</literal> expects its two word operands to be
   segment selectors. It adjusts the <literal>RPL</literal> (requested
   privilege level - stored in the bottom two bits of the selector)
   field of the destination (first) operand to ensure that it is no
   less (i.e. no more privileged than) the <literal>RPL</literal>
   field of the source operand. The zero flag is set if and only if a
   change had to be made.</para>
 </sect1>

 <sect1 id="inst-ref-bound">
  <title><literal>BOUND</literal>: Check Array Index against
   Bounds</title>

  <indexterm>
   <primary><literal>BOUND</literal></primary>
  </indexterm>

  <screen>BOUND reg16,mem               ; o16 62 /r            [186]
BOUND reg32,mem               ; o32 62 /r            [386]</screen>

  <para><literal>BOUND</literal> expects its second operand to point
   to an area of memory containing two signed values of the same size
   as its first operand (i.e. two words for the 16-bit form; two
   doublewords for the 32-bit form). It performs two signed
   comparisons: if the value in the register passed as its first
   operand is less than the first of the in-memory values, or is
   greater than or equal to the second, it throws a
   <literal>BR</literal> exception. Otherwise, it does nothing.</para>
 </sect1>

 <sect1 id="inst-ref-bsf">
  <title><literal>BSF</literal>, <literal>BSR</literal>: Bit
   Scan</title>

  <indexterm>
   <primary><literal>BSF</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>BSR</literal></primary>
  </indexterm>

  <screen>BSF reg16,r/m16               ; o16 0F BC /r         [386]
BSF reg32,r/m32               ; o32 0F BC /r         [386]

BSR reg16,r/m16               ; o16 0F BD /r         [386]
BSR reg32,r/m32               ; o32 0F BD /r         [386]</screen>

  <itemizedlist>
   <listitem>
    <para><literal>BSF</literal> searches for the least significant
     set bit in its source (second) operand, and if it finds one,
     stores the index in its destination (first) operand. If no set
     bit is found, the contents of the destination operand are
     undefined.  If the source operand is zero, the zero flag is
     set.</para>
   </listitem>

   <listitem>
    <para><literal>BSR</literal> performs the same function, but
     searches from the top instead, so it finds the most significant
     set bit.</para>
   </listitem>
  </itemizedlist>

  <para>Bit indices are from 0 (least significant) to 15 or 31 (most
   significant).  The destination operand can only be a register.  The
   source operand can be a register or a memory location.</para>
 </sect1>

 <sect1 id="inst-ref-bswap">
  <title><literal>BSWAP</literal>: Byte Swap</title>

  <indexterm>
   <primary><literal>BSWAP</literal></primary>
  </indexterm>

  <screen>BSWAP reg32                   ; o32 0F C8+r          [486]</screen>

  <para><literal>BSWAP</literal> swaps the order of the four bytes of
   a 32-bit register: bits 0-7 exchange places with bits 24-31, and
   bits 8-15 swap with bits 16-23. There is no explicit 16-bit
   equivalent: to byte-swap &reg.ax;, &reg.bx;, &reg.cx; or &reg.dx;,
   <literal>XCHG</literal> can be used (<xref
    linkend="inst-ref-xchg">).  When <literal>BSWAP</literal> is used
   with a 16-bit register, the result is undefined.</para>
 </sect1>

 <sect1 id="inst-ref-bt">
  <title><literal>BT</literal>, <literal>BTC</literal>,
   <literal>BTR</literal>, <literal>BTS</literal>: Bit Test</title>

  <indexterm>
   <primary><literal>BT</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>BTC</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>BTR</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>BTS</literal></primary>
  </indexterm>

  <screen>BT r/m16,reg16                ; o16 0F A3 /r         [386]
BT r/m32,reg32                ; o32 0F A3 /r         [386]
BT r/m16,imm8                 ; o16 0F BA /4 ib      [386]
BT r/m32,imm8                 ; o32 0F BA /4 ib      [386]

BTC r/m16,reg16               ; o16 0F BB /r         [386]
BTC r/m32,reg32               ; o32 0F BB /r         [386]
BTC r/m16,imm8                ; o16 0F BA /7 ib      [386]
BTC r/m32,imm8                ; o32 0F BA /7 ib      [386]

BTR r/m16,reg16               ; o16 0F B3 /r         [386]
BTR r/m32,reg32               ; o32 0F B3 /r         [386]
BTR r/m16,imm8                ; o16 0F BA /6 ib      [386]
BTR r/m32,imm8                ; o32 0F BA /6 ib      [386]

BTS r/m16,reg16               ; o16 0F AB /r         [386]
BTS r/m32,reg32               ; o32 0F AB /r         [386]
BTS r/m16,imm                 ; o16 0F BA /5 ib      [386]
BTS r/m32,imm                 ; o32 0F BA /5 ib      [386]</screen>

  <para>These instructions all test one bit of their first operand,
   whose index is given by the second operand, and store the value of
   that bit into the carry flag.  Bit indices are from 0 (least
   significant) to 15 or 31 (most significant).</para>

  <para>In addition to storing the original value of the bit into the
   carry flag, <literal>BTR</literal> also resets (clears) the bit in
   the operand itself.  <literal>BTS</literal> sets the bit, and
   <literal>BTC</literal> complements the bit.  <literal>BT</literal>
   does not modify its operands.</para>

  <para>The destination can be a register or a memory location. The
   source can be a register or an immediate value.</para>

  <para>If the destination operand is a register, the bit offset
   should be in the range 0-15 (for 16-bit operands) or 0-31 (for
   32-bit operands).  An immediate value outside these ranges will be
   taken modulo 16/32 by the processor.</para>

  <para>If the destination operand is a memory location, then an
   immediate bit offset follows the same rules as for a register.  If
   the bit offset is in a register, then it can be anything within the
   signed range of the register used (ie, for a 32-bit operand, it can
   be (-2^31) to (2^31 - 1).</para>
 </sect1>

 <sect1 id="inst-ref-call">
  <title><literal>CALL</literal>: Call Subroutine</title>

  <indexterm>
   <primary><literal>CALL</literal></primary>
  </indexterm>

  <indexterm>
   <primary>near call</primary>
  </indexterm>

  <indexterm>
   <primary>far call</primary>
  </indexterm>

  <screen>CALL imm                      ; E8 rw/rd             [8086]
CALL imm:imm16                ; o16 9A iw iw         [8086]
CALL imm:imm32                ; o32 9A id iw         [386]
CALL FAR mem16                ; o16 FF /3            [8086]
CALL FAR mem32                ; o32 FF /3            [386]
CALL r/m16                    ; o16 FF /2            [8086]
CALL r/m32                    ; o32 FF /2            [386]</screen>

  <para><literal>CALL</literal> calls a subroutine, by means of
   pushing the current instruction pointer (&reg.ip;) and optionally
   &reg.cs; as well on the stack, and then jumping to a given
   address.</para>

  <para>&reg.cs; is pushed as well as &reg.ip; if and only if the call
   is a far call, i.e. a destination segment address is specified in
   the instruction. The forms involving two colon-separated arguments
   are far calls; so are the <literal>CALL FAR mem</literal>
   forms.</para>

  <para>The immediate near call takes one of two forms (<literal>CALL
    imm16/imm32</literal>, determined by the current segment size
   limit).  For 16-bit operands, you would use <literal>CALL
    0x1234</literal>, and for 32-bit operands you would use
   <literal>CALL 0x12345678</literal>. The value passed as an operand
   is a relative offset.</para>

  <para>You can choose between the two immediate far call forms
   (<literal>CALL imm:imm</literal>) by the use of the
   <literal>WORD</literal> and <literal>DWORD</literal> keywords:
   <literal>CALL WORD 0x1234:0x5678</literal>) or <literal>CALL DWORD
    0x1234:0x56789abc</literal>.</para>

  <para>The <literal>CALL FAR mem</literal> forms execute a far call
   by loading the destination address out of memory. The address
   loaded consists of 16 or 32 bits of offset (depending on the
   operand size), and 16 bits of segment. The operand size may be
   overridden using <literal>CALL WORD FAR mem</literal> or
   <literal>CALL DWORD FAR mem</literal>.</para>

  <para>The <literal>CALL r/m</literal> forms execute a near call
   (within the same segment), loading the destination address out of
   memory or out of a register. The keyword <literal>NEAR</literal>
   may be specified, for clarity, in these forms, but is not
   necessary. Again, operand size can be overridden using
   <literal>CALL WORD mem</literal> or <literal>CALL DWORD
    mem</literal>.</para>

  <para>As a convenience, NASM does not require you to call a far
   procedure symbol by coding the cumbersome <literal>CALL SEG
    routine:routine</literal>, but instead allows the easier synonym
   <literal>CALL FAR routine</literal>.</para>

  <para>The <literal>CALL r/m</literal> forms given above are near
   calls; NASM will accept the <literal>NEAR</literal> keyword (e.g.
   <literal>CALL NEAR [address]</literal>), even though it is not
   strictly necessary.</para>
 </sect1>

 <sect1 id="inst-ref-cbw">
  <title><literal>CBW</literal>, <literal>CWD</literal>,
   <literal>CDQ</literal>, <literal>CWDE</literal>: Sign
   Extensions</title>

  <indexterm>
   <primary><literal>CBW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CWD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CDQ</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CWDE</literal></primary>
  </indexterm>

  <screen>CBW                           ; o16 98               [8086]
CWDE                          ; o32 98               [386]

CWD                           ; o16 99               [8086]
CDQ                           ; o32 99               [386]</screen>

  <para>All these instructions sign-extend a short value into a longer
   one, by replicating the top bit of the original value to fill the
   extended one.</para>

  <para><literal>CBW</literal> extends &reg.al; into &reg.ax; by
   repeating the top bit of &reg.al; in every bit of &reg.ah;.
   <literal>CWDE</literal> extends &reg.ax; into &reg.eax;.
   <literal>CWD</literal> extends &reg.ax; into
   <literal>&reg.dx;:&reg.ax;</literal> by repeating the top bit of
   &reg.ax; throughout &reg.dx;, and <literal>CDQ</literal> extends
   &reg.eax; into <literal>&reg.edx;:&reg.eax;</literal>.</para>
 </sect1>

 <sect1 id="inst-ref-clc">
  <title><literal>CLC</literal>, <literal>CLD</literal>,
   <literal>CLI</literal>, <literal>CLTS</literal>: Clear
   Flags</title>

  <indexterm>
   <primary><literal>CLC</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CLD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CLI</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CLTS</literal></primary>
  </indexterm>

  <screen>CLC                           ; F8                   [8086]
CLD                           ; FC                   [8086]
CLI                           ; FA                   [8086]
CLTS                          ; 0F 06                [286,PRIV]</screen>

  <para>These instructions clear various flags. <literal>CLC</literal>
   clears the carry flag; <literal>CLD</literal> clears the direction
   flag; <literal>CLI</literal> clears the interrupt flag (thus
   disabling interrupts); and <literal>CLTS</literal> clears the
   task-switched (&flag.ts;) flag in &reg.cr0;.</para>

  <para>To set the carry, direction, or interrupt flags, use the
   <literal>STC</literal>, <literal>STD</literal> and
   <literal>STI</literal> instructions (<xref
    linkend="inst-ref-stc">). To invert the carry flag, use
   <literal>CMC</literal> (<xref
    linkend="inst-ref-cmc">).</para>
 </sect1>

 <sect1 id="inst-ref-clflush">
  <title><literal>CLFLUSH</literal>: Flush Cache Line</title>

  <indexterm>
   <primary><literal>CLFLUSH</literal></primary>
  </indexterm>

  <screen>CLFLUSH mem                   ; 0F AE /7        [WILLAMETTE,SSE2]</screen>

  <para><literal>CLFLUSH</literal> invalidates the cache line that
   contains the linear address specified by the source operand from
   all levels of the processor cache hierarchy (data and instruction).
   If, at any level of the cache hierarchy, the line is inconsistent
   with memory (dirty) it is written to memory before invalidation.
   The source operand points to a byte-sized memory location.</para>

  <para>Although <literal>CLFLUSH</literal>s flagged
   <literal>SSE2</literal>nd above, it may not be present on all
   processors which have <literal>SSE2</literal> support, and it may
   be supported on other processors; the <literal>CPUID</literal>
   instruction (<xref linkend="inst-ref-cpuid">) will return a bit
   which indicates support for the <literal>CLFLUSH</literal>
   instruction.</para>
 </sect1>

 <sect1 id="inst-ref-cmc">
  <title><literal>CMC</literal>: Complement Carry Flag</title>

  <indexterm>
   <primary><literal>CMC</literal></primary>
  </indexterm>

  <screen>CMC                           ; F5                   [8086]</screen>

  <para><literal>CMC</literal> changes the value of the carry flag: if
   it was 0, it sets it to 1, and vice versa.</para>
 </sect1>

 <sect1 id="inst-ref-cmovcc">
  <title><literal>CMOVcc</literal>: Conditional Move</title>

  <indexterm>
   <primary><literal>CMOVcc</literal></primary>
  </indexterm>

  <screen>CMOVcc reg16,r/m16            ; o16 0F 40+cc /r      [P6]
CMOVcc reg32,r/m32            ; o32 0F 40+cc /r      [P6]</screen>

  <para><literal>CMOV</literal> moves its source (second) operand into
   its destination (first) operand if the given condition code is
   satisfied; otherwise it does nothing.</para>

  <para>For a list of condition codes, see <xref
    linkend="inst-ref-opcode-desc-cond-codes">.</para>

  <para>Although the <literal>CMOV</literal> instructions are flagged
   <literal>P6</literal> and above, they may not be supported by all
   Pentium Pro processors; the <literal>CPUID</literal> instruction
   (<xref linkend="inst-ref-cpuid">) will return a bit which indicates
   whether conditional moves are supported.</para>
 </sect1>

 <sect1 id="inst-ref-cmp">
  <title><literal>CMP</literal>: Compare Integers</title>

  <indexterm>
   <primary><literal>CMP</literal></primary>
  </indexterm>

  <screen>CMP r/m8,reg8                 ; 38 /r                [8086]
CMP r/m16,reg16               ; o16 39 /r            [8086]
CMP r/m32,reg32               ; o32 39 /r            [386]

CMP reg8,r/m8                 ; 3A /r                [8086]
CMP reg16,r/m16               ; o16 3B /r            [8086]
CMP reg32,r/m32               ; o32 3B /r            [386]

CMP r/m8,imm8                 ; 80 /0 ib             [8086]
CMP r/m16,imm16               ; o16 81 /0 iw         [8086]
CMP r/m32,imm32               ; o32 81 /0 id         [386]

CMP r/m16,imm8                ; o16 83 /0 ib         [8086]
CMP r/m32,imm8                ; o32 83 /0 ib         [386]

CMP AL,imm8                   ; 3C ib                [8086]
CMP AX,imm16                  ; o16 3D iw            [8086]
CMP EAX,imm32                 ; o32 3D id            [386]</screen>

  <para><literal>CMP</literal> performs a `mental' subtraction of its
   second operand from its first operand, and affects the flags as if
   the subtraction had taken place, but does not store the result of
   the subtraction anywhere.</para>

  <para>In the forms with an 8-bit immediate second operand and a
   longer first operand, the second operand is considered to be
   signed, and is sign-extended to the length of the first operand. In
   these cases, the <literal>BYTE</literal> qualifier is necessary to
   force NASM to generate this form of the instruction.</para>

  <para>The destination operand can be a register or a memory
   location. The source can be a register, memory location, or an
   immediate value of the same size as the destination.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-cmpccpd">
  <title><literal>CMPccPD</literal>: Packed Double-Precision FP
   Compare</title>

  <indexterm>
   <primary><literal>CMPccPD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPEQPD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPLTPD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPLEPD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPUNORDPD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPNEQPD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPNLTPD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPNLEPD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMDORDPD</literal></primary>
  </indexterm>

  <indexterm>
   <primary>Condition Predicates</primary>
  </indexterm>

  <screen>CMPPD xmm1,xmm2/mem128,imm8   ; 66 0F C2 /r ib  [WILLAMETTE,SSE2]

CMPEQPD xmm1,xmm2/mem128      ; 66 0F C2 /r 00  [WILLAMETTE,SSE2]
CMPLTPD xmm1,xmm2/mem128      ; 66 0F C2 /r 01  [WILLAMETTE,SSE2]
CMPLEPD xmm1,xmm2/mem128      ; 66 0F C2 /r 02  [WILLAMETTE,SSE2]
CMPUNORDPD xmm1,xmm2/mem128   ; 66 0F C2 /r 03  [WILLAMETTE,SSE2]
CMPNEQPD xmm1,xmm2/mem128     ; 66 0F C2 /r 04  [WILLAMETTE,SSE2]
CMPNLTPD xmm1,xmm2/mem128     ; 66 0F C2 /r 05  [WILLAMETTE,SSE2]
CMPNLEPD xmm1,xmm2/mem128     ; 66 0F C2 /r 06  [WILLAMETTE,SSE2]
CMPORDPD xmm1,xmm2/mem128     ; 66 0F C2 /r 07  [WILLAMETTE,SSE2]</screen>

  <para>The <literal>CMPccPD</literal> instructions compare the two
   packed double-precision FP values in the source and destination
   operands, and returns the result of the comparison in the
   destination register. The result of each comparison is a quadword
   mask of all 1s (comparison true) or all 0s (comparison
   false).</para>

  <para>The destination is an &reg.xmm; register. The source can be
   either an &reg.xmm; register or a 128-bit memory location.</para>

  <para>The third operand is an 8-bit immediate value, of which the
   low 3 bits define the type of comparison. For ease of programming,
   the 8 two-operand pseudo-instructions are provided, with the third
   operand already filled in. The <quote>Condition Predicates</quote>
   are:</para>

  <informaltable frame="none">
   <tgroup cols="3">
    <colspec colname="cc">
    <colspec colname="value">
    <colspec colname="description">

    <tbody>
     <row>
      <entry>EQ</entry>
      <entry>0</entry>
      <entry>Equal</entry>
     </row>

     <row>
      <entry>LT</entry>
      <entry>1</entry>
      <entry>Less than</entry>
     </row>

     <row>
      <entry>LE</entry>
      <entry>2</entry>
      <entry>Less than or equal</entry>
     </row>

     <row>
      <entry>UNORD</entry>
      <entry>3</entry>
      <entry>Unordered</entry>
     </row>

     <row>
      <entry>NE</entry>
      <entry>4</entry>
      <entry>Not equal</entry>
     </row>

     <row>
      <entry>NLT</entry>
      <entry>5</entry>
      <entry>Not less than</entry>
     </row>

     <row>
      <entry>NLE</entry>
      <entry>6</entry>
      <entry>Not less than or equal</entry>
     </row>

     <row>
      <entry>ORD</entry>
      <entry>7</entry>
      <entry>Ordered</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <para>For more details of the comparison predicates, and details of
   how to emulate the <quote>greater than</quote> equivalents, see
   <xref linkend="inst-ref-opcode-desc-sse-cc">.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-cmpccps">
  <title><literal>CMPccPS</literal>: Packed Single-Precision FP
   Compare</title>

  <indexterm>
   <primary><literal>CMPccPS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPEQPS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPLTPS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPLEPS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPUNORDPS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPNEQPS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPNLTPS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPNLEPS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMDORDPS</literal></primary>
  </indexterm>

  <indexterm>
   <primary>Condition Predicates</primary>
  </indexterm>

  <screen>CMPPS xmm1,xmm2/mem128,imm8   ; 0F C2 /r ib     [KATMAI,SSE]

CMPEQPS xmm1,xmm2/mem128      ; 0F C2 /r 00     [KATMAI,SSE]
CMPLTPS xmm1,xmm2/mem128      ; 0F C2 /r 01     [KATMAI,SSE]
CMPLEPS xmm1,xmm2/mem128      ; 0F C2 /r 02     [KATMAI,SSE]
CMPUNORDPS xmm1,xmm2/mem128   ; 0F C2 /r 03     [KATMAI,SSE]
CMPNEQPS xmm1,xmm2/mem128     ; 0F C2 /r 04     [KATMAI,SSE]
CMPNLTPS xmm1,xmm2/mem128     ; 0F C2 /r 05     [KATMAI,SSE]
CMPNLEPS xmm1,xmm2/mem128     ; 0F C2 /r 06     [KATMAI,SSE]
CMPORDPS xmm1,xmm2/mem128     ; 0F C2 /r 07     [KATMAI,SSE]</screen>

  <para>The <literal>CMPccPS</literal> instructions compare the two
   packed single-precision FP values in the source and destination
   operands, and returns the result of the comparison in the
   destination register. The result of each comparison is a quadword
   mask of all 1s (comparison true) or all 0s (comparison
   false).</para>

  <para>The destination is an &reg.xmm; register. The source can be
   either an &reg.xmm; register or a 128-bit memory location.</para>

  <para>The third operand is an 8-bit immediate value, of which the
   low 3 bits define the type of comparison. For ease of programming,
   the 8 two-operand pseudo-instructions are provided, with the third
   operand already filled in. The <quote>Condition Predicates</quote>
   are:</para>

  <informaltable frame="none">
   <tgroup cols="3">
    <colspec colname="cc">
    <colspec colname="value">
    <colspec colname="description">

    <tbody>
     <row>
      <entry>EQ</entry>
      <entry>0</entry>
      <entry>Equal</entry>
     </row>

     <row>
      <entry>LT</entry>
      <entry>1</entry>
      <entry>Less than</entry>
     </row>

     <row>
      <entry>LE</entry>
      <entry>2</entry>
      <entry>Less than or equal</entry>
     </row>

     <row>
      <entry>UNORD</entry>
      <entry>3</entry>
      <entry>Unordered</entry>
     </row>

     <row>
      <entry>NE</entry>
      <entry>4</entry>
      <entry>Not equal</entry>
     </row>

     <row>
      <entry>NLT</entry>
      <entry>5</entry>
      <entry>Not less than</entry>
     </row>

     <row>
      <entry>NLE</entry>
      <entry>6</entry>
      <entry>Not less than or equal</entry>
     </row>

     <row>
      <entry>ORD</entry>
      <entry>7</entry>
      <entry>Ordered</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <para>For more details of the comparison predicates, and details of
   how to emulate the <quote>greater than</quote> equivalents, see
   <xref linkend="inst-ref-opcode-desc-sse-cc">.</para>
 </sect1>

 <sect1 id="inst-ref-cmpsb">
  <title><literal>CMPSB</literal>, <literal>CMPSW</literal>,
   <literal>CMPSD</literal>: Compare Strings</title>

  <indexterm>
   <primary><literal>CMPSB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPSW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>CMPSD</literal></primary>
  </indexterm>

  <screen>CMPSB                         ; A6                   [8086]
CMPSW                         ; o16 A7               [8086]
CMPSD                         ; o32 A7               [386]</screen>

  <para><literal>CMPSB</literal> compares the byte at
   <literal>[&reg.ds;:&reg.si;]</literal> or
   <literal>[&reg.ds;:&reg.esi;]</literal> with the byte at
   <literal>[&reg.es;:&reg.di;]</literal> or
   <literal>[&reg.es;:&reg.edi;]</literal>, and sets the flags
   accordingly.  It then increments or decrements (depending on the
   direction flag: increments if the flag is clear, decrements if it
   is set) &reg.si; and &reg.di; (or &reg.esi; and &reg.edi;).</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The registers used are &reg.si; and &reg.di; if the address
   size is 16 bits, and &reg.esi; and &reg.edi; if it is 32 bits. If
   you need to use an address size not equal to the current
   <literal>BITS</literal> setting, you can use an explicit
   <literal>a16</literal> or <literal>a32</literal> prefix.</para>

  <para>The segment register used to load from
   <literal>[&reg.si;]</literal> or <literal>[&reg.esi;]</literal> can
   be overridden by using a segment register name as a prefix (for
   example, <literal>&reg.es; CMPSB</literal>). The use of &reg.es;
   for the load from <literal>[&reg.di;]</literal> or
   <literal>[&reg.edi;]</literal> cannot be overridden.</para>

  <para><literal>CMPSW</literal> and <literal>CMPSD</literal> work in
   the same way, but they compare a word or a doubleword instead of a
   byte, and increment or decrement the addressing registers by 2 or 4
   instead of 1.</para>

  <para>The <literal>REPE</literal> and <literal>REPNE</literal>
   prefixes (equivalently, <literal>REPZ</literal> and
   <literal>REPNZ</literal>) may be used to repeat the instruction up
   to &reg.cx; (or &reg.ecx; - again, the address size chooses which)
   times until the first unequal or equal byte is found.</para>
 </sect1>

 <sect1 id="inst-ref-cmpxchg">
  <title><literal>CMPXCHG</literal>: Compare and Exchange</title>

  <indexterm>
   <primary><literal>CMPXCHG</literal></primary>
  </indexterm>
  <screen>CMPXCHG r/m8,reg8             ; 0F B0 /r             [PENT]
CMPXCHG r/m16,reg16           ; o16 0F B1 /r         [PENT]
CMPXCHG r/m32,reg32           ; o32 0F B1 /r         [PENT]</screen>

  <para><literal>CMPXCHG</literal> compares its destination (first)
   operand to the value in &reg.al;, &reg.ax; or &reg.eax; (depending
   on the operand size of the instruction). If they are equal, it
   copies its source (second) operand into the destination and sets
   the zero flag. Otherwise, it clears the zero flag and leaves the
   destination alone.</para>

  <para>The destination can be either a register or a memory location.
   The source is a register.</para>

  <para><literal>CMPXCHG</literal> is intended to be used for atomic
   operations in multitasking or multiprocessor environments. To
   safely update a value in shared memory, for example, you might load
   the value into &reg.eax;, load the updated value into &reg.ebx;,
   and then execute the instruction <literal>LOCK CMPXCHG
    [value],&reg.ebx;</literal>.  If <literal>value</literal> has not
   changed since being loaded, it is updated with your desired new
   value, and the zero flag is set to let you know it has worked. (The
   <literal>LOCK</literal> prefix prevents another processor doing
   anything in the middle of this operation: it guarantees atomicity.)
   However, if another processor has modified the value in between
   your load and your attempted store, the store does not happen, and
   you are notified of the failure by a cleared zero flag, so you can
   go round and try again.</para>
 </sect1>

 <sect1 id="inst-ref-cmpxchg8b">
  <title><literal>CMPXCHG8B</literal>: Compare and Exchange Eight
   Bytes</title>

  <indexterm>
   <primary><literal>CMPXCHG8B</literal></primary>
  </indexterm>

  <screen>CMPXCHG8B mem                 ; 0F C7 /1             [PENT]</screen>

  <para>This is a larger and more unwieldy version of
   <literal>CMPXCHG</literal>: it compares the 64-bit (eight-byte)
   value stored at <literal>[mem]</literal> with the value in
   <literal>&reg.edx;:&reg.eax;</literal>.  If they are equal, it sets
   the zero flag and stores <literal>&reg.ecx;:&reg.ebx;</literal>
   into the memory area. If they are unequal, it clears the zero flag
   and leaves the memory area untouched.</para>

  <para><literal>CMPXCHG8B</literal> can be used with the
   <literal>LOCK</literal> prefix, to allow atomic execution. This is
   useful in multi-processor and multi-tasking environments.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-comisd">
  <title><literal>COMISD</literal>: Scalar Ordered Double-Precision FP
   Compare and Set <literal>EFLAGS</literal></title>

  <indexterm>
   <primary><literal>COMISD</literal></primary>
  </indexterm>

  <screen>COMISD xmm1,xmm2/mem64        ; 66 0F 2F /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>COMISD</literal> compares the low-order
   double-precision FP value in the two source operands.  &flag.zf;,
   &flag.pf;, and &flag.cf; are set according to the result.
   &flag.of;, &flag.af;, and &flag.af; are cleared. The unordered
   result is returned if either source is a <literal>NaN</literal>
   (<literal>QNaN</literal> or <literal>SNaN</literal>).</para>

  <para>The destination operand is an &reg.xmm; register. The source
   can be either an &reg.xmm; register or a memory location.</para>

  <para>The flags are set according to the following rules:</para>

  <informaltable frame="none">
   <tgroup cols="4">
    <colspec colname="result">
    <colspec colname="flags">
    <colspec colname="arrow">
    <colspec colname="values">

    <thead>
     <row>
      <entry>Result</entry>
      <entry>Flags</entry>
      <entry></entry>
      <entry>Values</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>Unordered</entry>
      <entry>&flag.zf;,&flag.pf;,&flag.cf;</entry>
      <entry></entry>
      <entry>111</entry>
     </row>

     <row>
      <entry>Greater than</entry>
      <entry>&flag.zf;,&flag.pf;,&flag.cf;</entry>
      <entry></entry>
      <entry>000</entry>
     </row>

     <row>
      <entry>Less than</entry>
      <entry>&flag.zf;,&flag.pf;,&flag.cf;</entry>
      <entry></entry>
      <entry>001</entry>
     </row>

     <row>
      <entry>Equal</entry>
      <entry>&flag.zf;,&flag.pf;,&flag.cf;</entry>
      <entry></entry>
      <entry>100</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </sect1>
]]>
 <sect1 id="inst-ref-comiss">
  <title><literal>COMISS</literal>: Scalar Ordered Single-Precision FP
   Compare and Set <literal>EFLAGS</literal></title>

  <indexterm>
   <primary><literal>COMISS</literal></primary>
  </indexterm>

  <screen>COMISS xmm1,xmm2/mem64        ; 66 0F 2F /r     [KATMAI,SSE]</screen>

  <para><literal>COMISS</literal> compares the low-order
   single-precision FP value in the two source operands.  &flag.zf;,
   &flag.pf;, and &flag.cf; are set according to the result.
   &flag.of;, &flag.af;, and &flag.af; are cleared. The unordered
   result is returned if either source is a <literal>NaN</literal>
   (<literal>QNaN</literal> or <literal>SNaN</literal>).</para>

  <para>The destination operand is an &reg.xmm; register. The source
   can be either an &reg.xmm; register or a memory location.</para>

  <para>The flags are set according to the following rules:</para>

  <informaltable frame="none">
   <tgroup cols="4">
    <colspec colname="result">
    <colspec colname="flags">
    <colspec colname="arrow">
    <colspec colname="values">

    <thead>
     <row>
      <entry>Result</entry>
      <entry>Flags</entry>
      <entry></entry>
      <entry>Values</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>Unordered</entry>
      <entry>&flag.zf;,&flag.pf;,&flag.cf;</entry>
      <entry></entry>
      <entry>111</entry>
     </row>

     <row>
      <entry>Greater than</entry>
      <entry>&flag.zf;,&flag.pf;,&flag.cf;</entry>
      <entry></entry>
      <entry>000</entry>
     </row>

     <row>
      <entry>Less than</entry>
      <entry>&flag.zf;,&flag.pf;,&flag.cf;</entry>
      <entry></entry>
      <entry>001</entry>
     </row>

     <row>
      <entry>Equal</entry>
      <entry>&flag.zf;,&flag.pf;,&flag.cf;</entry>
      <entry></entry>
      <entry>100</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </sect1>

 <sect1 id="inst-ref-cpuid">
  <title><literal>CPUID</literal>: Get CPU Identification Code</title>

  <indexterm>
   <primary><literal>CPUID</literal></primary>
  </indexterm>

  <screen>CPUID                         ; 0F A2                [PENT]</screen>

  <para><literal>CPUID</literal> returns various information about the
   processor it is being executed on. It fills the four registers
   &reg.eax;, &reg.ebx;, &reg.ecx; and &reg.edx; with information,
   which varies depending on the input contents of &reg.eax;.</para>

  <para><literal>CPUID</literal> also acts as a barrier to serialise
   instruction execution: executing the <literal>CPUID</literal>
   instruction guarantees that all the effects (memory modification,
   flag modification, register modification) of previous instructions
   have been completed before the next instruction gets
   fetched.</para>

  <para>The information returned is as follows:</para>

  <itemizedlist>
   <listitem>
    <para>If &reg.eax; is zero on input, &reg.eax; on output holds the
     maximum acceptable input value of &reg.eax;, and
     <literal>&reg.ebx;:&reg.edx;:&reg.ecx;</literal> contain the
     string <literal>"GenuineIntel"</literal> (or not, if you have a
     clone processor).  That is to say, &reg.ebx; contains
     <literal>"Genu"</literal> (in NASM's own sense of character
     constants, described in <xref linkend="nasm-const-char">),
     &reg.edx; contains <literal>"ineI"</literal> and &reg.ecx;
     contains <literal>"ntel"</literal>.</para>
   </listitem>

   <listitem>
    <para>If &reg.eax; is one on input, &reg.eax; on output contains
     version information about the processor, and &reg.edx; contains a
     set of feature flags, showing the presence and absence of various
     features. For example, bit 8 is set if the
     <literal>CMPXCHG8B</literal> instruction (<xref
      linkend="inst-ref-cmpxchg8b">) is supported, bit 15 is set if
     the conditional move instructions (<xref
      linkend="inst-ref-cmovcc"> and <xref linkend="inst-ref-fcmovb">)
     are supported, and bit 23 is set if &reg.mmx; instructions are
     supported.</para>
   </listitem>

   <listitem>
    <para>If &reg.eax; is two on input, &reg.eax;, &reg.ebx;,
     &reg.ecx; and &reg.edx; all contain information about caches and
     TLBs (Translation Lookahead Buffers).</para>
   </listitem>
  </itemizedlist>

  <para>For more information on the data returned from
   <literal>CPUID</literal>, see the documentation from Intel and
   other processor manufacturers.</para>
 </sect1>
<![%inst-ref.sse2;[
\H{insCVTDQ2PD} \i\c{CVTDQ2PD}:
Packed Signed INT32 to Packed Double-Precision FP Conversion

\c CVTDQ2PD xmm1,xmm2/mem64      ; F3 0F E6 /r     [WILLAMETTE,SSE2] 

\c{CVTDQ2PD} converts two packed signed doublewords from the source
operand to two packed double-precision FP values in the destination
operand.

The destination operand is an \c{XMM} register. The source can be
either an \c{XMM} register or a 64-bit memory location. If the
source is a register, the packed integers are in the low quadword.

\H{insCVTDQ2PS} \i\c{CVTDQ2PS}:
Packed Signed INT32 to Packed Single-Precision FP Conversion

\c CVTDQ2PS xmm1,xmm2/mem128     ; 0F 5B /r        [WILLAMETTE,SSE2] 

\c{CVTDQ2PS} converts four packed signed doublewords from the source
operand to four packed single-precision FP values in the destination
operand.

The destination operand is an \c{XMM} register. The source can be
either an \c{XMM} register or a 128-bit memory location.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTPD2DQ} \i\c{CVTPD2DQ}:
Packed Double-Precision FP to Packed Signed INT32 Conversion

\c CVTPD2DQ xmm1,xmm2/mem128     ; F2 0F E6 /r     [WILLAMETTE,SSE2]

\c{CVTPD2DQ} converts two packed double-precision FP values from the
source operand to two packed signed doublewords in the low quadword
of the destination operand. The high quadword of the destination is
set to all 0s.

The destination operand is an \c{XMM} register. The source can be
either an \c{XMM} register or a 128-bit memory location.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTPD2PI} \i\c{CVTPD2PI}:
Packed Double-Precision FP to Packed Signed INT32 Conversion

\c CVTPD2PI mm,xmm/mem128        ; 66 0F 2D /r     [WILLAMETTE,SSE2]

\c{CVTPD2PI} converts two packed double-precision FP values from the
source operand to two packed signed doublewords in the destination
operand.

The destination operand is an \c{MMX} register. The source can be
either an \c{XMM} register or a 128-bit memory location.

For more details of this instruction, see the Intel Processor manuals.

\H{insCVTPD2PS} \i\c{CVTPD2PS}:
Packed Double-Precision FP to Packed Single-Precision FP Conversion

\c CVTPD2PS xmm1,xmm2/mem128     ; 66 0F 5A /r     [WILLAMETTE,SSE2]

\c{CVTPD2PS} converts two packed double-precision FP values from the
source operand to two packed single-precision FP values in the low
quadword of the destination operand. The high quadword of the
destination is set to all 0s.

The destination operand is an \c{XMM} register. The source can be
either an \c{XMM} register or a 128-bit memory location.

For more details of this instruction, see the Intel Processor manuals.

\H{insCVTPI2PD} \i\c{CVTPI2PD}:
Packed Signed INT32 to Packed Double-Precision FP Conversion

\c CVTPI2PD xmm,mm/mem64         ; 66 0F 2A /r     [WILLAMETTE,SSE2]

\c{CVTPI2PD} converts two packed signed doublewords from the source
operand to two packed double-precision FP values in the destination
operand.

The destination operand is an \c{XMM} register. The source can be
either an \c{MMX} register or a 64-bit memory location.

For more details of this instruction, see the Intel Processor manuals.

\H{insCVTPI2PS} \i\c{CVTPI2PS}:
Packed Signed INT32 to Packed Single-FP Conversion

\c CVTPI2PS xmm,mm/mem64         ; 0F 2A /r        [KATMAI,SSE] 

\c{CVTPI2PS} converts two packed signed doublewords from the source
operand to two packed single-precision FP values in the low quadword
of the destination operand. The high quadword of the destination
remains unchanged.

The destination operand is an \c{XMM} register. The source can be
either an \c{MMX} register or a 64-bit memory location.

For more details of this instruction, see the Intel Processor manuals.

\H{insCVTPS2DQ} \i\c{CVTPS2DQ}:
Packed Single-Precision FP to Packed Signed INT32 Conversion

\c CVTPS2DQ xmm1,xmm2/mem128     ; 66 0F 5B /r     [WILLAMETTE,SSE2]

\c{CVTPS2DQ} converts four packed single-precision FP values from the
source operand to four packed signed doublewords in the destination operand.

The destination operand is an \c{XMM} register. The source can be
either an \c{XMM} register or a 128-bit memory location.

For more details of this instruction, see the Intel Processor manuals.

\H{insCVTPS2PD} \i\c{CVTPS2PD}:
Packed Single-Precision FP to Packed Double-Precision FP Conversion

\c CVTPS2PD xmm1,xmm2/mem64      ; 0F 5A /r        [WILLAMETTE,SSE2]

\c{CVTPS2PD} converts two packed single-precision FP values from the
source operand to two packed double-precision FP values in the destination
operand.

The destination operand is an \c{XMM} register. The source can be
either an \c{XMM} register or a 64-bit memory location. If the source
is a register, the input values are in the low quadword.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTPS2PI} \i\c{CVTPS2PI}:
Packed Single-Precision FP to Packed Signed INT32 Conversion

\c CVTPS2PI mm,xmm/mem64         ; 0F 2D /r        [KATMAI,SSE] 

\c{CVTPS2PI} converts two packed single-precision FP values from
the source operand to two packed signed doublewords in the destination
operand.

The destination operand is an \c{MMX} register. The source can be
either an \c{XMM} register or a 64-bit memory location. If the
source is a register, the input values are in the low quadword.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTSD2SI} \i\c{CVTSD2SI}:
Scalar Double-Precision FP to Signed INT32 Conversion

\c CVTSD2SI reg32,xmm/mem64      ; F2 0F 2D /r     [WILLAMETTE,SSE2]

\c{CVTSD2SI} converts a double-precision FP value from the source
operand to a signed doubleword in the destination operand.

The destination operand is a general purpose register. The source can be
either an \c{XMM} register or a 64-bit memory location. If the
source is a register, the input value is in the low quadword.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTSD2SS} \i\c{CVTSD2SS}:
Scalar Double-Precision FP to Scalar Single-Precision FP Conversion

\c CVTSD2SS xmm1,xmm2/mem64      ; F2 0F 5A /r     [KATMAI,SSE] 

\c{CVTSD2SS} converts a double-precision FP value from the source
perand to a single-precision FP value in the low doubleword of the
estination operand. The upper 3 doublewords are left unchanged.

The destination operand is an \c{XMM} register. The source can be
either an \c{XMM} register or a 64-bit memory location. If the
source is a register, the input value is in the low quadword.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTSI2SD} \i\c{CVTSI2SD}:
Signed INT32 to Scalar Double-Precision FP Conversion

\c CVTSI2SD xmm,r/m32            ; F2 0F 2A /r     [WILLAMETTE,SSE2]

\c{CVTSI2SD} converts a signed doubleword from the source operand to
a double-precision FP value in the low quadword of the destination
operand. The high quadword is left unchanged.

The destination operand is an \c{XMM} register. The source can be either
a general purpose register or a 32-bit memory location.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTSI2SS} \i\c{CVTSI2SS}:
Signed INT32 to Scalar Single-Precision FP Conversion

\c CVTSI2SS xmm,r/m32            ; F3 0F 2A /r     [KATMAI,SSE]

\c{CVTSI2SS} converts a signed doubleword from the source operand to a
single-precision FP value in the low doubleword of the destination operand.
The upper 3 doublewords are left unchanged.

The destination operand is an \c{XMM} register. The source can be either
a general purpose register or a 32-bit memory location.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTSS2SD} \i\c{CVTSS2SD}:
Scalar Single-Precision FP to Scalar Double-Precision FP Conversion

\c CVTSS2SD xmm1,xmm2/mem32      ; F3 0F 5A /r     [WILLAMETTE,SSE2]

\c{CVTSS2SD} converts a single-precision FP value from the source operand
to a double-precision FP value in the low quadword of the destination
operand. The upper quadword is left unchanged.

The destination operand is an \c{XMM} register. The source can be either
an \c{XMM} register or a 32-bit memory location. If the source is a
register, the input value is contained in the low doubleword.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTSS2SI} \i\c{CVTSS2SI}:
Scalar Single-Precision FP to Signed INT32 Conversion

\c CVTSS2SI reg32,xmm/mem32      ; F3 0F 2D /r     [KATMAI,SSE] 

\c{CVTSS2SI} converts a single-precision FP value from the source
operand to a signed doubleword in the destination operand.

The destination operand is a general purpose register. The source can be
either an \c{XMM} register or a 32-bit memory location. If the
source is a register, the input value is in the low doubleword.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTTPD2DQ} \i\c{CVTTPD2DQ}:
Packed Double-Precision FP to Packed Signed INT32 Conversion with Truncation

\c CVTTPD2DQ xmm1,xmm2/mem128    ; 66 0F E6 /r     [WILLAMETTE,SSE2]

\c{CVTTPD2DQ} converts two packed double-precision FP values in the source
operand to two packed single-precision FP values in the destination operand.
If the result is inexact, it is truncated (rounded toward zero). The high
quadword is set to all 0s.

The destination operand is an \c{XMM} register. The source can be
either an \c{XMM} register or a 128-bit memory location.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTTPD2PI} \i\c{CVTTPD2PI}:
Packed Double-Precision FP to Packed Signed INT32 Conversion with Truncation

\c CVTTPD2PI mm,xmm/mem128        ; 66 0F 2C /r     [WILLAMETTE,SSE2]

\c{CVTTPD2PI} converts two packed double-precision FP values in the source
operand to two packed single-precision FP values in the destination operand.
If the result is inexact, it is truncated (rounded toward zero).

The destination operand is an \c{MMX} register. The source can be
either an \c{XMM} register or a 128-bit memory location.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTTPS2DQ} \i\c{CVTTPS2DQ}:
Packed Single-Precision FP to Packed Signed INT32 Conversion with Truncation

\c CVTTPS2DQ xmm1,xmm2/mem128    ; F3 0F 5B /r     [WILLAMETTE,SSE2]

\c{CVTTPS2DQ} converts four packed single-precision FP values in the source
operand to four packed signed doublewords in the destination operand.
If the result is inexact, it is truncated (rounded toward zero).

The destination operand is an \c{XMM} register. The source can be
either an \c{XMM} register or a 128-bit memory location.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTTPS2PI} \i\c{CVTTPS2PI}:
Packed Single-Precision FP to Packed Signed INT32 Conversion with Truncation

\c CVTTPS2PI mm,xmm/mem64         ; 0F 2C /r       [KATMAI,SSE] 

\c{CVTTPS2PI} converts two packed single-precision FP values in the source
operand to two packed signed doublewords in the destination operand.
If the result is inexact, it is truncated (rounded toward zero). If
the source is a register, the input values are in the low quadword.

The destination operand is an \c{MMX} register. The source can be
either an \c{XMM} register or a 64-bit memory location. If the source
is a register, the input value is in the low quadword.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTTSD2SI} \i\c{CVTTSD2SI}:
Scalar Double-Precision FP to Signed INT32 Conversion with Truncation

\c CVTTSD2SI reg32,xmm/mem64      ; F2 0F 2C /r    [WILLAMETTE,SSE2]

\c{CVTTSD2SI} converts a double-precision FP value in the source operand
to a signed doubleword in the destination operand. If the result is
inexact, it is truncated (rounded toward zero).

The destination operand is a general purpose register. The source can be
either an \c{XMM} register or a 64-bit memory location. If the source is a
register, the input value is in the low quadword.

For more details of this instruction, see the Intel Processor manuals.


\H{insCVTTSS2SI} \i\c{CVTTSS2SI}:
Scalar Single-Precision FP to Signed INT32 Conversion with Truncation

\c CVTTSD2SI reg32,xmm/mem32      ; F3 0F 2C /r    [KATMAI,SSE] 

\c{CVTTSS2SI} converts a single-precision FP value in the source operand
to a signed doubleword in the destination operand. If the result is
inexact, it is truncated (rounded toward zero).

The destination operand is a general purpose register. The source can be
either an \c{XMM} register or a 32-bit memory location. If the source is a
register, the input value is in the low doubleword.

For more details of this instruction, see the Intel Processor manuals.
]]>
 <sect1 id="inst-ref-daa">
  <title><literal>DAA</literal>, <literal>DAS</literal>: Decimal
   Adjustments</title>

  <indexterm>
   <primary><literal>DAA</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>DAS</literal></primary>
  </indexterm>

  <screen>DAA                           ; 27                   [8086]
DAS                           ; 2F                   [8086]</screen>

  <para>These instructions are used in conjunction with the add and
   subtract instructions to perform binary-coded decimal arithmetic in
   <emphasis>packed</emphasis> (one BCD digit per nibble) form.  For
   the unpacked equivalents, see <xref linkend="inst-ref-aaa">.</para>

  <para><literal>DAA</literal> should be used after a one-byte
   <literal>ADD</literal> instruction whose destination was the
   &reg.al; register: by means of examining the value in the &reg.al;
   and also the auxiliary carry flag &flag.af;, it determines whether
   either digit of the addition has overflowed, and adjusts it (and
   sets the carry and auxiliary-carry flags) if so.  You can add long
   BCD strings together by doing
   <literal>ADD</literal>/<literal>DAA</literal> on the low two
   digits, then doing <literal>ADC</literal>/<literal>DAA</literal> on
   each subsequent pair of digits.</para>

  <para><literal>DAS</literal> works similarly to
   <literal>DAA</literal>, but is for use after <literal>SUB</literal>
   instructions rather than <literal>ADD</literal>.</para>
 </sect1>

 <sect1 id="inst-ref-dec">
  <title><literal>DEC</literal>: Decrement Integer</title>

  <indexterm>
   <primary><literal>DEC</literal></primary>
  </indexterm>

  <screen>DEC reg16                     ; o16 48+r             [8086]
DEC reg32                     ; o32 48+r             [386]
DEC r/m8                      ; FE /1                [8086]
DEC r/m16                     ; o16 FF /1            [8086]
DEC r/m32                     ; o32 FF /1            [386]</screen>

  <para><literal>DEC</literal> subtracts 1 from its operand. It does
   <emphasis>not</emphasis> affect the carry flag: to affect the carry
   flag, use <literal>SUB something,1</literal> (see <xref
    linkend="inst-ref-sub">).  See also <literal>INC</literal> (<xref
    linkend="inst-ref-inc">).</para>

  <para>This instruction can be used with a \c{LOCK} prefix to allow
   atomic execution.</para>

  <para>See also <literal>INC</literal> (<xref
    linkend="inst-ref-inc">).</para>
 </sect1>

 <sect1 id="inst-ref-div">
  <title><literal>DIV</literal>: Unsigned Integer Divide</title>

  <indexterm>
   <primary><literal>DIV</literal></primary>
  </indexterm>

  <screen>DIV r/m8                      ; F6 /6                [8086]
DIV r/m16                     ; o16 F7 /6            [8086]
DIV r/m32                     ; o32 F7 /6            [386]</screen>

  <para><literal>DIV</literal> performs unsigned integer division. The
   explicit operand provided is the divisor; the dividend and
   destination operands are implicit, in the following way:</para>

  <itemizedlist>
   <listitem>
    <para>For <literal>DIV r/m8</literal>, &reg.ax; is divided by the
     given operand; the quotient is stored in &reg.al; and the
     remainder in &reg.ah;.</para>
   </listitem>

   <listitem>
    <para>For <literal>DIV r/m16</literal>,
     <literal>&reg.dx;:&reg.ax;</literal> is divided by the given
     operand; the quotient is stored in &reg.ax; and the remainder in
     &reg.dx;.</para>
   </listitem>

   <listitem>
    <para>For <literal>DIV r/m32</literal>,
     <literal>&reg.edx;:&reg.eax;</literal> is divided by the given
     operand; the quotient is stored in &reg.eax; and the remainder in
     &reg.edx;.</para>
   </listitem>
  </itemizedlist>

  <para>Signed integer division is performed by the
   <literal>IDIV</literal> instruction: see <xref
    linkend="inst-ref-idiv">.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-divpd">
  <title><literal>DIVPD</literal>: Packed Double-Precision FP
   Divide</title>

  <indexterm>
   <primary><literal>DIVPD</literal></primary>
  </indexterm>

  <screen>DIVPD xmm1,xmm2/mem128        ; 66 0F 5E /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>DIVPD</literal> divides the two packed
   double-precision FP values in the destination operand by the two
   packed double-precision FP values in the source operand, and stores
   the packed double-precision results in the destination
   register.</para>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 128-bit memory
   location.</para>

  <screen>   dst[0-63]   := dst[0-63]   / src[0-63],
   dst[64-127] := dst[64-127] / src[64-127].</screen>
 </sect1>
]]>
 <sect1 id="inst-ref-divps">
  <title><literal>DIVPS</literal>: Packed Single-Precision FP
   Divide</title>

  <indexterm>
   <primary><literal>DIVPS</literal></primary>
  </indexterm>

  <screen>DIVPS xmm1,xmm2/mem128        ; 0F 5E /r        [KATMAI,SSE]</screen>

  <para><literal>DIVPS</literal> divides the four packed
   single-precision FP values in the destination operand by the four
   packed single-precision FP values in the source operand, and stores
   the packed single-precision results in the destination
   register.</para>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 128-bit memory
   location.</para>

  <screen>   dst[0-31]   := dst[0-31]   / src[0-31],
   dst[32-63]  := dst[32-63]  / src[32-63],
   dst[64-95]  := dst[64-95]  / src[64-95],
   dst[96-127] := dst[96-127] / src[96-127].</screen>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-divsd">
  <title><literal>DIVSD</literal>: Scalar Double-Precision FP
   Divide</title>

  <indexterm>
   <primary><literal>DIVSD</literal></primary>
  </indexterm>

  <screen>DIVSD xmm1,xmm2/mem64         ; F2 0F 5E /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>DIVSD</literal> divides the low-order
   double-precision FP value in the destination operand by the
   low-order double-precision FP value in the source operand, and
   stores the double-precision result in the destination
   register.</para>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 64-bit memory
   location.</para>

  <screen>   dst[0-63]   := dst[0-63] / src[0-63],
   dst[64-127] remains unchanged.</screen>
 </sect1>
]]>
 <sect1 id="inst-ref-divss">
  <title><literal>DIVSS</literal>: Scalar Single-Precision FP
   Divide</title>

  <indexterm>
   <primary><literal>DIVSS</literal></primary>
  </indexterm>

  <screen>DIVSS xmm1,xmm2/mem32         ; F3 0F 5E /r     [KATMAI,SSE]</screen>

  <para><literal>DIVSS</literal> divides the low-order
   single-precision FP value in the destination operand by the
   low-order single-precision FP value in the source operand, and
   stores the single-precision result in the destination
   register.</para>

  <para>The destination is an &reg.xmm; register. The source operand
   can be either an &reg.xmm; register or a 32-bit memory
   location.</para>

  <screen>   dst[0-31]   := dst[0-31] / src[0-31],
   dst[32-127] remains unchanged.</screen>
 </sect1>

 <sect1 id="inst-ref-emms">
  <title><literal>EMMS</literal>: Empty MMX State</title>

  <indexterm>
   <primary><literal>EMMS</literal></primary>
  </indexterm>

  <screen>EMMS                          ; 0F 77                [PENT,MMX]</screen>

  <para><literal>EMMS</literal> sets the FPU tag word (marking which
   floating-point registers are available) to all ones, meaning all
   registers are available for the FPU to use. It should be used after
   executing &reg.mmx; instructions and before executing any
   subsequent floating-point operations.</para>
 </sect1>

 <sect1 id="inst-ref-enter">
  <title><literal>ENTER</literal>: Create Stack Frame</title>

  <indexterm>
   <primary><literal>ENTER</literal></primary>
  </indexterm>

  <screen>ENTER imm,imm                 ; C8 iw ib             [186]</screen>

  <para><literal>ENTER</literal> constructs a stack frame for a
   high-level language procedure call. The first operand (the
   <literal>iw</literal> in the opcode definition above refers to the
   first operand) gives the amount of stack space to allocate for
   local variables; the second (the <literal>ib</literal> above) gives
   the nesting level of the procedure (for languages like Pascal, with
   nested procedures).</para>

  <para>The function of <literal>ENTER</literal>, with a nesting level
   of zero, is equivalent to</para>

  <programlisting>        PUSH    EBP             ; or PUSH BP          in 16 bits
        MOV     EBP, ESP        ; or MOV BP, SP       in 16 bits
        SUB     ESP, operand1   ; or SUB SP, operand1 in 16 bits</programlisting>

  <para>This creates a stack frame with the procedure parameters
   accessible upwards from &reg.ebp;, and local variables accessible
   downwards from &reg.ebp;.</para>

  <para>With a nesting level of one, the stack frame created is 4 (or
   2) bytes bigger, and the value of the final frame pointer &reg.ebp;
   is accessible in memory at <literal>[&reg.ebp;-4]</literal>.</para>

  <para>This allows <literal>ENTER</literal>, when called with a
   nesting level of two, to look at the stack frame described by the
   <emphasis>previous</emphasis> value of &reg.ebp;, find the frame
   pointer at offset -4 from that, and push it along with its new
   frame pointer, so that when a level-two procedure is called from
   within a level-one procedure, <literal>[&reg.ebp;-4]</literal>
   holds the frame pointer of the most recent level-one procedure call
   and <literal>[&reg.ebp;-8]</literal> holds that of the most recent
   level-two call.  And so on, for nesting levels up to 31.</para>

  <para>Stack frames created by <literal>ENTER</literal> can be
   destroyed by the <literal>LEAVE</literal> instruction: see
   <xref linkend="inst-ref-leave">.</para>
 </sect1>

 <sect1 id="inst-ref-f2xm1">
  <title><literal>F2XM1</literal>: Calculate 2**X-1</title>

  <indexterm>
   <primary><literal>F2XM1</literal></primary>
  </indexterm>

  <screen>F2XM1                         ; D9 F0                [8086,FPU]</screen>

  <para><literal>F2XM1</literal> raises 2 to the power of &reg.st0;,
   subtracts one, and stores the result back into &reg.st0;. The
   initial contents of &reg.st0; must be a number in the range -1.0 to
   +1.0.</para>
 </sect1>

 <sect1 id="inst-ref-fabs">
  <title><literal>FABS</literal>: Floating-Point Absolute Value</title>

  <indexterm>
   <primary><literal>FABS</literal></primary>
  </indexterm>

  <screen>FABS                          ; D9 E1                [8086,FPU]</screen>

  <para><literal>FABS</literal> computes the absolute value of
   &reg.st0;, by clearing the sign bit, and stores the result back
   into &reg.st0;.</para>
 </sect1>

 <sect1 id="inst-ref-fadd">
  <title><literal>FADD</literal>, <literal>FADDP</literal>:
   Floating-Point Addition</title>

  <indexterm>
   <primary><literal>FADD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FADDP</literal></primary>
  </indexterm>

  <screen>FADD mem32                    ; D8 /0                [8086,FPU]
FADD mem64                    ; DC /0                [8086,FPU]

FADD fpureg                   ; D8 C0+r              [8086,FPU]
FADD ST0,fpureg               ; D8 C0+r              [8086,FPU]

FADD TO fpureg                ; DC C0+r              [8086,FPU]
FADD fpureg,ST0               ; DC C0+r              [8086,FPU]

FADDP fpureg                  ; DE C0+r              [8086,FPU]
FADDP fpureg,ST0              ; DE C0+r              [8086,FPU]</screen>

  <para><literal>FADD</literal>, given one operand, adds the operand
   to &reg.st0; and stores the result back in &reg.st0;. If the
   operand has the <literal>TO</literal> modifier, the result is
   stored in the register given rather than in &reg.st0;.</para>

  <para><literal>FADDP</literal> performs the same function as
   <literal>FADD TO</literal>, but pops the register stack after
   storing the result.</para>

  <para>The given two-operand forms are synonyms for the one-operand
   forms.</para>

  <para>To add an integer value to &reg.st0;, use the
   <literal>FIADD</literal> instruction (<xref
    linkend="inst-ref-fiadd">).</para>
 </sect1>

 <sect1 id="inst-ref-fbld">
  <title><literal>FBLD</literal>, <literal>FBSTP</literal>: BCD
   Floating-Point Load and Store</title>

  <indexterm>
   <primary><literal>FBLD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FBSTP</literal></primary>
  </indexterm>

  <screen>FBLD mem80                    ; DF /4                [8086,FPU]
FBSTP mem80                   ; DF /6                [8086,FPU]</screen>

  <para><literal>FBLD</literal> loads an 80-bit (ten-byte) packed
   binary-coded decimal number from the given memory address, converts
   it to a real, and pushes it on the register stack.
   <literal>FBSTP</literal> stores the value of &reg.st0;, in packed
   BCD, at the given address and then pops the register stack.</para>
 </sect1>

 <sect1 id="inst-ref-fchs">
  <title><literal>FCHS</literal>: Floating-Point Change Sign</title>

  <indexterm>
   <primary><literal>FCHS</literal></primary>
  </indexterm>

  <screen>FCHS                          ; D9 E0                [8086,FPU]</screen>

  <para><literal>FCHS</literal> negates the number in &reg.st0; by
   inverting the sign bit: negative numbers become positive, and vice
   versa.</para>
 </sect1>

 <sect1 id="inst-ref-fclex">
  <title><literal>FCLEX</literal>, <literal>FNCLEX</literal>: Clear
   Floating-Point Exceptions</title>

  <indexterm>
   <primary><literal>FCLEX</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FNCLEX</literal></primary>
  </indexterm>

  <screen>FCLEX                         ; 9B DB E2             [8086,FPU]
FNCLEX                        ; DB E2                [8086,FPU]</screen>

  <para><literal>FCLEX</literal> clears any floating-point exceptions
   which may be pending. <literal>FNCLEX</literal> does the same thing
   but doesn't wait for previous floating-point operations (including
   the <emphasis>handling</emphasis> of pending exceptions) to finish
   first.</para>
 </sect1>

 <sect1 id="inst-ref-fcmovb">
  <title><literal>FCMOVcc</literal>: Floating-Point Conditional
   Move</title>

  <indexterm>
   <primary><literal>FCMOVcc</literal></primary>
  </indexterm>

  <screen>FCMOVB fpureg                 ; DA C0+r              [P6,FPU]
FCMOVB ST0,fpureg             ; DA C0+r              [P6,FPU]

FCMOVE fpureg                 ; DA C8+r              [P6,FPU]
FCMOVE ST0,fpureg             ; DA C8+r              [P6,FPU]

FCMOVBE fpureg                ; DA D0+r              [P6,FPU]
FCMOVBE ST0,fpureg            ; DA D0+r              [P6,FPU]

FCMOVU fpureg                 ; DA D8+r              [P6,FPU]
FCMOVU ST0,fpureg             ; DA D8+r              [P6,FPU]

FCMOVNB fpureg                ; DB C0+r              [P6,FPU]
FCMOVNB ST0,fpureg            ; DB C0+r              [P6,FPU]

FCMOVNE fpureg                ; DB C8+r              [P6,FPU]
FCMOVNE ST0,fpureg            ; DB C8+r              [P6,FPU]

FCMOVNBE fpureg               ; DB D0+r              [P6,FPU]
FCMOVNBE ST0,fpureg           ; DB D0+r              [P6,FPU]

FCMOVNU fpureg                ; DB D8+r              [P6,FPU]
FCMOVNU ST0,fpureg            ; DB D8+r              [P6,FPU]</screen>

  <para>The <literal>FCMOV</literal> instructions perform conditional
   move operations: each of them moves the contents of the given
   register into &reg.st0; if its condition is satisfied, and does
   nothing if not.</para>

  <para>The conditions are not the same as the standard condition
   codes used with conditional jump instructions. The conditions
   <literal>B</literal>, <literal>BE</literal>, <literal>NB</literal>,
   <literal>NBE</literal>, <literal>E</literal> and
   <literal>NE</literal> are exactly as normal, but none of the other
   standard ones are supported. Instead, the condition
   <literal>U</literal> and its counterpart <literal>NU</literal> are
   provided; the <literal>U</literal> condition is satisfied if the
   last two floating-point numbers compared were
   <emphasis>unordered</emphasis>, i.e. they were not equal but
   neither one could be said to be greater than the other, for example
   if they were NaNs. (The flag state which signals this is the
   setting of the parity flag: so the <literal>U</literal> condition
   is notionally equivalent to <literal>PE</literal>, and
   <literal>NU</literal> is equivalent to
   <literal>PO</literal>.)</para>

  <para>The <literal>FCMOV</literal> conditions test the main
   processor's status flags, not the FPU status flags, so using
   <literal>FCMOV</literal> directly after <literal>FCOM</literal>
   will not work. Instead, you should either use
   <literal>FCOMI</literal> which writes directly to the main CPU
   flags word, or use <literal>FSTSW</literal> to extract the FPU
   flags.</para>

  <para>Although the <literal>FCMOV</literal> instructions are flagged
   <literal>P6</literal> above, they may not be supported by all
   Pentium Pro processors; the <literal>CPUID</literal> instruction
   (<xref linkend="inst-ref-cpuid">) will return a bit which indicates
   whether conditional moves are supported.</para>
 </sect1>

 <sect1 id="inst-ref-fcom">
  <title><literal>FCOM</literal>, <literal>FCOMP</literal>,
   <literal>FCOMPP</literal>, <literal>FCOMI</literal>,
   <literal>FCOMIP</literal>: Floating-Point Compare</title>

  <indexterm>
   <primary><literal>FCOM</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FCOMP</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FCOMPP</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FCOMI</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FCOMIP</literal></primary>
  </indexterm>

  <screen>FCOM mem32                    ; D8 /2                [8086,FPU]
FCOM mem64                    ; DC /2                [8086,FPU]
FCOM fpureg                   ; D8 D0+r              [8086,FPU]
FCOM ST0,fpureg               ; D8 D0+r              [8086,FPU]

FCOMP mem32                   ; D8 /3                [8086,FPU]
FCOMP mem64                   ; DC /3                [8086,FPU]
FCOMP fpureg                  ; D8 D8+r              [8086,FPU]
FCOMP ST0,fpureg              ; D8 D8+r              [8086,FPU]

FCOMPP                        ; DE D9                [8086,FPU]

FCOMI fpureg                  ; DB F0+r              [P6,FPU]
FCOMI ST0,fpureg              ; DB F0+r              [P6,FPU]

FCOMIP fpureg                 ; DF F0+r              [P6,FPU]
FCOMIP ST0,fpureg             ; DF F0+r              [P6,FPU]</screen>

  <para><literal>FCOM</literal> compares &reg.st0; with the given
   operand, and sets the FPU flags accordingly. &reg.st0; is treated
   as the left-hand side of the comparison, so that the carry flag is
   set (for a <quote>less-than</quote> result) if &reg.st0; is less
   than the given operand.</para>

  <para><literal>FCOMP</literal> does the same as
   <literal>FCOM</literal>, but pops the register stack afterwards.
   <literal>FCOMPP</literal> compares &reg.st0; with &reg.st1; and
   then pops the register stack twice.</para>

  <para><literal>FCOMI</literal> and <literal>FCOMIP</literal> work
   like the corresponding forms of <literal>FCOM</literal> and
   <literal>FCOMP</literal>, but write their results directly to the
   CPU flags register rather than the FPU status word, so they can be
   immediately followed by conditional jump or conditional move
   instructions.</para>

  <para>The <literal>FCOM</literal> instructions differ from the
   <literal>FUCOM</literal> instructions (<xref
    linkend="inst-ref-fucom">) only in the way they handle quiet NaNs:
   <literal>FUCOM</literal> will handle them silently and set the
   condition code flags to an <quote>unordered</quote> result, whereas
   <literal>FCOM</literal> will generate an exception.</para>
 </sect1>

 <sect1 id="inst-ref-fcos">
  <title><literal>FCOS</literal>: Cosine</title>

  <indexterm>
   <primary><literal>FCOS</literal></primary>
  </indexterm>

  <screen>FCOS                          ; D9 FF                [386,FPU]</screen>

  <para><literal>FCOS</literal> computes the cosine of &reg.st0; (in
   radians), and stores the result in &reg.st0;.  The absolute value
   of &reg.st0; must be less than
   2<superscript>63</superscript>.</para>

  <para>See also <literal>FSINCOS</literal> (<xref
    linkend="inst-ref-fsin">).</para>
 </sect1>

 <sect1 id="inst-ref-fdecstp">
  <title><literal>FDECSTP</literal>: Decrement Floating-Point Stack
   Pointer</title>

  <indexterm>
   <primary><literal>FDECSTP</literal></primary>
  </indexterm>

  <screen>FDECSTP                       ; D9 F6                [8086,FPU]</screen>

  <para><literal>FDECSTP</literal> decrements the `top' field in the
   floating-point status word. This has the effect of rotating the FPU
   register stack by one, as if the contents of &reg.st7; had been
   pushed on the stack. See also <literal>FINCSTP</literal> (<xref
    linkend="inst-ref-fincstp">).</para>
 </sect1>

 <sect1 id="inst-ref-fdisi">
  <title><literal>FxDISI</literal>, <literal>FxENI</literal>: Disable
   and Enable Floating-Point Interrupts</title>

  <indexterm>
   <primary><literal>FDISI</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FNDISI</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FENI</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FNENI</literal></primary>
  </indexterm>

  <screen>FDISI                         ; 9B DB E1             [8086,FPU]
FNDISI                        ; DB E1                [8086,FPU]

FENI                          ; 9B DB E0             [8086,FPU]
FNENI                         ; DB E0                [8086,FPU]</screen>

  <para><literal>FDISI</literal> and <literal>FENI</literal> disable
   and enable floating-point interrupts. These instructions are only
   meaningful on original 8087 processors: the 287 and above treat
   them as no-operation instructions.</para>

  <para><literal>FNDISI</literal> and <literal>FNENI</literal> do the
   same thing as <literal>FDISI</literal> and <literal>FENI</literal>
   respectively, but without waiting for the floating-point processor
   to finish what it was doing first.</para>
 </sect1>

 <sect1 id="inst-ref-fdiv">
  <title><literal>FDIV</literal>, <literal>FDIVP</literal>,
   <literal>FDIVR</literal>, <literal>FDIVRP</literal>: Floating-Point
   Division</title>

  <indexterm>
   <primary><literal>FDIV</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FDIVP</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FDIVR</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FDIVRP</literal></primary>
  </indexterm>

  <screen>FDIV mem32                    ; D8 /6                [8086,FPU]
FDIV mem64                    ; DC /6                [8086,FPU]

FDIV fpureg                   ; D8 F0+r              [8086,FPU]
FDIV ST0,fpureg               ; D8 F0+r              [8086,FPU]

FDIV TO fpureg                ; DC F8+r              [8086,FPU]
FDIV fpureg,ST0               ; DC F8+r              [8086,FPU]

FDIVR mem32                   ; D8 /0                [8086,FPU]
FDIVR mem64                   ; DC /0                [8086,FPU]

FDIVR fpureg                  ; D8 F8+r              [8086,FPU]
FDIVR ST0,fpureg              ; D8 F8+r              [8086,FPU]

FDIVR TO fpureg               ; DC F0+r              [8086,FPU]
FDIVR fpureg,ST0              ; DC F0+r              [8086,FPU]

FDIVP fpureg                  ; DE F8+r              [8086,FPU]
FDIVP fpureg,ST0              ; DE F8+r              [8086,FPU]

FDIVRP fpureg                 ; DE F0+r              [8086,FPU]
FDIVRP fpureg,ST0             ; DE F0+r              [8086,FPU]</screen>

  <itemizedlist>
   <listitem>
    <para><literal>FDIV</literal> divides &reg.st0; by the given
     operand and stores the result back in &reg.st0;, unless the
     <literal>TO</literal> qualifier is given, in which case it
     divides the given operand by &reg.st0; and stores the result in
     the operand.</para>
   </listitem>

   <listitem>
    <para><literal>FDIVR</literal> does the same thing, but does the
     division the other way up: so if <literal>TO</literal> is not
     given, it divides the given operand by &reg.st0; and stores the
     result in &reg.st0;, whereas if <literal>TO</literal> is given it
     divides &reg.st0; by its operand and stores the result in the
     operand.</para>
   </listitem>

   <listitem>
    <para><literal>FDIVP</literal> operates like <literal>FDIV
      TO</literal>, but pops the register stack once it has
     finished.</para>
   </listitem>

   <listitem>
    <para><literal>FDIVRP</literal> operates like <literal>FDIVR
      TO</literal>, but pops the register stack once it has
     finished.</para>
   </listitem>
  </itemizedlist>

  <para>For FP/Integer divisions, see <literal>FIDIV</literal> (<xref
    linkend="inst-ref-fidiv">).</para>
 </sect1>

 <sect1 id="inst-ref-ffree">
  <title><literal>FFREE</literal>: Flag Floating-Point Register as
   Unused</title>

  <indexterm>
   <primary><literal>FFREE</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FFREEP</literal></primary>
  </indexterm>

  <screen>FFREE fpureg                  ; DD C0+r              [8086,FPU]
FFREEP fpureg                 ; DF C0+r              [286,FPU,UNDOC]</screen>

  <para><literal>FFREE</literal> marks the given register as being
   empty.</para>

  <para><literal>FFREEP</literal> marks the given register as being
   empty, and then pops the register stack.</para>

 </sect1>

 <sect1 id="inst-ref-fiadd">
  <title><literal>FIADD</literal>: Floating-Point/Integer
   Addition</title>

  <indexterm>
   <primary><literal>FIADD</literal></primary>
  </indexterm>

  <screen>FIADD mem16                   ; DE /0                [8086,FPU]
FIADD mem32                   ; DA /0                [8086,FPU]</screen>

  <para><literal>FIADD</literal> adds the 16-bit or 32-bit integer
   stored in the given memory location to &reg.st0;, storing the
   result in &reg.st0;.</para>
 </sect1>

 <sect1 id="inst-ref-ficom">
  <title><literal>FICOM</literal>, <literal>FICOMP</literal>:
   Floating-Point/Integer Compare</title>

  <indexterm>
   <primary><literal>FICOM</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FICOMP</literal></primary>
  </indexterm>

  <screen>FICOM mem16                   ; DE /2                [8086,FPU]
FICOM mem32                   ; DA /2                [8086,FPU]

FICOMP mem16                  ; DE /3                [8086,FPU]
FICOMP mem32                  ; DA /3                [8086,FPU]</screen>

  <para><literal>FICOM</literal> compares &reg.st0; with the 16-bit or
   32-bit integer stored in the given memory location, and sets the
   FPU flags accordingly. <literal>FICOMP</literal> does the same, but
   pops the register stack afterwards.</para>
 </sect1>

 <sect1 id="inst-ref-fidiv">
  <title><literal>FIDIV</literal>, <literal>FIDIVR</literal>:
   Floating-Point/Integer Division</title>

  <indexterm>
   <primary><literal>FIDIV</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FIDIVR</literal></primary>
  </indexterm>

  <screen>FIDIV mem16                   ; DE /6                [8086,FPU]
FIDIV mem32                   ; DA /6                [8086,FPU]

FIDIVR mem16                  ; DE /7                [8086,FPU]
FIDIVR mem32                  ; DA /7                [8086,FPU]</screen>

  <para><literal>FIDIV</literal> divides &reg.st0; by the 16-bit or
   32-bit integer stored in the given memory location, and stores the
   result in &reg.st0;. <literal>FIDIVR</literal> does the division
   the other way up: it divides the integer by &reg.st0;, but still
   stores the result in &reg.st0;.</para>
 </sect1>

 <sect1 id="inst-ref-fild">
  <title><literal>FILD</literal>, <literal>FIST</literal>,
   <literal>FISTP</literal>: Floating-Point/Integer Conversion</title>

  <indexterm>
   <primary><literal>FILD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FIST</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FISTP</literal></primary>
  </indexterm>

  <screen>FILD mem16                    ; DF /0                [8086,FPU]
FILD mem32                    ; DB /0                [8086,FPU]
FILD mem64                    ; DF /5                [8086,FPU]

FIST mem16                    ; DF /2                [8086,FPU]
FIST mem32                    ; DB /2                [8086,FPU]

FISTP mem16                   ; DF /3                [8086,FPU]
FISTP mem32                   ; DB /3                [8086,FPU]
FISTP mem64                   ; DF /7                [8086,FPU]</screen>

  <para><literal>FILD</literal> loads an integer out of a memory
   location, converts it to a real, and pushes it on the FPU register
   stack. <literal>FIST</literal> converts &reg.st0; to an integer and
   stores that in memory; <literal>FISTP</literal> does the same as
   <literal>FIST</literal>, but pops the register stack
   afterwards.</para>
 </sect1>

 <sect1 id="inst-ref-fimul">
  <title><literal>FIMUL</literal>: Floating-Point/Integer
   Multiplication</title>

  <indexterm>
   <primary><literal>FIMUL</literal></primary>
  </indexterm>

  <screen>FIMUL mem16                   ; DE /1                [8086,FPU]
FIMUL mem32                   ; DA /1                [8086,FPU]</screen>

  <para><literal>FIMUL</literal> multiplies &reg.st0; by the 16-bit or
   32-bit integer stored in the given memory location, and stores the
   result in &reg.st0;.</para>
 </sect1>

 <sect1 id="inst-ref-fincstp">
  <title><literal>FINCSTP</literal>: Increment Floating-Point Stack
   Pointer</title>

  <indexterm>
   <primary><literal>FINCSTP</literal></primary>
  </indexterm>

  <screen>FINCSTP                       ; D9 F7                [8086,FPU]</screen>

  <para><literal>FINCSTP</literal> increments the `top' field in the
   floating-point status word. This has the effect of rotating the FPU
   register stack by one, as if the register stack had been popped;
   however, unlike the popping of the stack performed by many FPU
   instructions, it does not flag the new &reg.st7; (previously
   &reg.st0;) as empty. See also <literal>FDECSTP</literal> (<xref
    linkend="inst-ref-fdecstp">).</para>
 </sect1>

 <sect1 id="inst-ref-finit">
  <title><literal>FINIT</literal>, <literal>FNINIT</literal>:
   Initialise Floating-Point Unit</title>

  <indexterm>
   <primary><literal>FINIT</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FNINIT</literal></primary>
  </indexterm>

  <screen>FINIT                         ; 9B DB E3             [8086,FPU]
FNINIT                        ; DB E3                [8086,FPU]</screen>

  <para><literal>FINIT</literal> initialises the FPU to its default
   state. It flags all registers as empty, without actually changing
   their values. <literal>FNINIT</literal> does the same, without
   first waiting for pending exceptions to clear.</para>
 </sect1>

 <sect1 id="inst-ref-fisub">
  <title><literal>FISUB</literal>: Floating-Point/Integer
   Subtraction</title>

  <indexterm>
   <primary><literal>FISUB</literal></primary>
  </indexterm>

  <screen>FISUB mem16                   ; DE /4                [8086,FPU]
FISUB mem32                   ; DA /4                [8086,FPU]

FISUBR mem16                  ; DE /5                [8086,FPU]
FISUBR mem32                  ; DA /5                [8086,FPU]</screen>

  <para><literal>FISUB</literal> subtracts the 16-bit or 32-bit
   integer stored in the given memory location from &reg.st0;, and
   stores the result in &reg.st0;. <literal>FISUBR</literal> does the
   subtraction the other way round, i.e. it subtracts &reg.st0; from
   the given integer, but still stores the result in &reg.st0;.</para>
 </sect1>

 <sect1 id="inst-ref-fld">
  <title><literal>FLD</literal>: Floating-Point Load</title>

  <indexterm>
   <primary><literal>FLD</literal></primary>
  </indexterm>

  <screen>FLD mem32                     ; D9 /0                [8086,FPU]
FLD mem64                     ; DD /0                [8086,FPU]
FLD mem80                     ; DB /5                [8086,FPU]
FLD fpureg                    ; D9 C0+r              [8086,FPU]</screen>

  <para><literal>FLD</literal> loads a floating-point value out of the
   given register or memory location, and pushes it on the FPU
   register stack.</para>
 </sect1>

 <sect1 id="inst-ref-fldxx">
  <title><literal>FLDxx</literal>: Floating-Point Load
   Constants</title>

  <indexterm>
   <primary><literal>FLDxx</literal></primary>
  </indexterm>

  <screen>FLD1                          ; D9 E8                [8086,FPU]
FLDL2E                        ; D9 EA                [8086,FPU]
FLDL2T                        ; D9 E9                [8086,FPU]
FLDLG2                        ; D9 EC                [8086,FPU]
FLDLN2                        ; D9 ED                [8086,FPU]
FLDPI                         ; D9 EB                [8086,FPU]
FLDZ                          ; D9 EE                [8086,FPU]</screen>

  <para>These instructions push specific standard constants on the FPU
   register stack:</para>

  <informaltable frame="none">
   <tgroup cols="2">
    <colspec colname="instruction">
    <colspec colname="constant">

    <thead>
     <row>
      <entry>Instruction</entry>
      <entry>Constant pushed</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>FLD1</literal></entry>
      <entry>1.0</entry>
     </row>

     <row>
      <entry><literal>FLDL2E</literal></entry>
      <entry>base-2 logarithm of e</entry>
     </row>

     <row>
      <entry><literal>FLDL2T</literal></entry>
      <entry>base-2 log of 10</entry>

     <row>
      <entry><literal>FLDLG2</literal></entry>
      <entry>base-10 log of 2</entry>

     <row>
      <entry><literal>FLDLN2</literal></entry>
      <entry>base-e log of 2</entry>

     <row>
      <entry><literal>FLDPI</literal></entry>
      <entry>pi</entry>

     <row>
      <entry><literal>FLDZ</literal></entry>
      <entry>zero</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </sect1>

 <sect1 id="inst-ref-fldcw">
  <title><literal>FLDCW</literal>: Load Floating-Point Control
   Word</title>

  <indexterm>
   <primary><literal>FLDCW</literal></primary>
  </indexterm>

  <screen>FLDCW mem16                   ; D9 /5                [8086,FPU]</screen>

  <para><literal>FLDCW</literal> loads a 16-bit value out of memory
   and stores it into the FPU control word (governing things like the
   rounding mode, the precision, and the exception masks).  See also
   <literal>FSTCW</literal> (<xref linkend="inst-ref-fstcw">).  If
   instructions are enabled and you don't want to generate one, use
   <literal>FCLEX</literal> or <literal>FNCLEX</literal> (<xref
    linkend="inst-ref-fclex">) before loading the new control
   word.</para>
 </sect1>

 <sect1 id="inst-ref-fldenv">
  <title><literal>FLDENV</literal>: Load Floating-Point
   Environment</title>

  <indexterm>
   <primary><literal>FLDENV</literal></primary>
  </indexterm>

  <screen>FLDENV mem                    ; D9 /4                [8086,FPU]</screen>

  <para><literal>FLDENV</literal> loads the FPU operating environment
   (control word, status word, tag word, instruction pointer, data
   pointer and last opcode) from memory. The memory area is 14 or 28
   bytes long, depending on the CPU mode at the time. See also
   <literal>FSTENV</literal> (<xref
    linkend="inst-ref-fstenv">).</para>
 </sect1>

 <sect1 id="inst-ref-fmul">
  <title><literal>FMUL</literal>, <literal>FMULP</literal>:
   Floating-Point Multiply</title>

  <indexterm>
   <primary><literal>FMUL</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FMULP</literal></primary>
  </indexterm>

  <screen>FMUL mem32                    ; D8 /1                [8086,FPU]
FMUL mem64                    ; DC /1                [8086,FPU]

FMUL fpureg                   ; D8 C8+r              [8086,FPU]
FMUL ST0,fpureg               ; D8 C8+r              [8086,FPU]

FMUL TO fpureg                ; DC C8+r              [8086,FPU]
FMUL fpureg,ST0               ; DC C8+r              [8086,FPU]

FMULP fpureg                  ; DE C8+r              [8086,FPU]
FMULP fpureg,ST0              ; DE C8+r              [8086,FPU]</screen>

  <para><literal>FMUL</literal> multiplies &reg.st0; by the given
   operand, and stores the result in &reg.st0;, unless the
   <literal>TO</literal> qualifier is used in which case it stores the
   result in the operand. <literal>FMULP</literal> performs the same
   operation as <literal>FMUL TO</literal>, and then pops the register
   stack.</para>
 </sect1>

 <sect1 id="inst-ref-fnop">
  <title><literal>FNOP</literal>: Floating-Point No Operation</title>

  <indexterm>
   <primary><literal>FNOP</literal></primary>
  </indexterm>

  <screen>FNOP                          ; D9 D0                [8086,FPU]</screen>

  <para><literal>FNOP</literal> does nothing.</para>
 </sect1>

 <sect1 id="inst-ref-fpatan">
  <title><literal>FPATAN</literal>, <literal>FPTAN</literal>:
   Arctangent and Tangent</title>

  <indexterm>
   <primary><literal>FPATAN</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FPTAN</literal></primary>
  </indexterm>

  <screen>FPATAN                        ; D9 F3                [8086,FPU]
FPTAN                         ; D9 F2                [8086,FPU]</screen>

  <para><literal>FPATAN</literal> computes the arctangent, in radians,
   of the result of dividing &reg.st1; by &reg.st0;, stores the result
   in &reg.st1;, and pops the register stack. It works like the C
   <literal>atan2</literal> function, in that changing the sign of
   both &reg.st0; and &reg.st1; changes the output value by pi (so it
   performs true rectangular-to-polar coordinate conversion, with
   &reg.st1; being the Y coordinate and &reg.st0; being the X
   coordinate, not merely an arctangent).</para>

  <para><literal>FPTAN</literal> computes the tangent of the value in
   &reg.st0; (in radians), and stores the result back into
   &reg.st0;.</para>

  <para>The absolute value of &reg.st0; must be less than
   2<superscript>63</superscript>.</para>
 </sect1>

 <sect1 id="inst-ref-fprem">
  <title><literal>FPREM</literal>, <literal>FPREM1</literal>:
   Floating-Point Partial Remainder</title>

  <indexterm>
   <primary><literal>FPREM</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FPREM1</literal></primary>
  </indexterm>

  <screen>FPREM                         ; D9 F8                [8086,FPU]
FPREM1                        ; D9 F5                [386,FPU]</screen>

  <para>These instructions both produce the remainder obtained by
   dividing &reg.st0; by &reg.st1;. This is calculated, notionally, by
   dividing &reg.st0; by &reg.st1;, rounding the result to an integer,
   multiplying by &reg.st1; again, and computing the value which would
   need to be added back on to the result to get back to the original
   value in &reg.st0;.</para>

  <para>The two instructions differ in the way the notional
   round-to-integer operation is performed. <literal>FPREM</literal>
   does it by rounding towards zero, so that the remainder it returns
   always has the same sign as the original value in &reg.st0;;
   <literal>FPREM1</literal> does it by rounding to the nearest
   integer, so that the remainder always has at most half the
   magnitude of &reg.st1;.</para>

  <para>Both instructions calculate <emphasis>partial</emphasis> remainders, meaning
   that they may not manage to provide the final result, but might
   leave intermediate results in &reg.st0; instead. If this happens,
   they will set the C2 flag in the FPU status word; therefore, to
   calculate a remainder, you should repeatedly execute
   <literal>FPREM</literal> or <literal>FPREM1</literal> until C2
   becomes clear.</para>
 </sect1>

 <sect1 id="inst-ref-frndint">
  <title><literal>FRNDINT</literal>: Floating-Point Round to
   Integer</title>

  <indexterm>
   <primary><literal>FRNDINT</literal></primary>
  </indexterm>

  <screen>FRNDINT                       ; D9 FC                [8086,FPU]</screen>

  <para><literal>FRNDINT</literal> rounds the contents of &reg.st0; to
   an integer, according to the current rounding mode set in the FPU
   control word, and stores the result back in &reg.st0;.</para>
 </sect1>

 <sect1 id="inst-ref-frstor">
  <title><literal>FSAVE</literal>, <literal>FRSTOR</literal>:
   Save/Restore Floating-Point State</title>

  <indexterm>
   <primary><literal>FSAVE</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FNSAVE</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FRSTOR</literal></primary>
  </indexterm>

  <screen>FSAVE mem                     ; 9B DD /6             [8086,FPU]
FNSAVE mem                    ; DD /6                [8086,FPU]

FRSTOR mem                    ; DD /4                [8086,FPU]</screen>

  <para><literal>FSAVE</literal> saves the entire floating-point unit
   state, including all the information saved by
   <literal>FSTENV</literal> (<xref linkend="inst-ref-fstenv">) plus
   the contents of all the registers, to a 94 or 108 byte area of
   memory (depending on the CPU mode). <literal>FRSTOR</literal>
   restores the floating-point state from the same area of
   memory.</para>

  <para><literal>FNSAVE</literal> does the same as
   <literal>FSAVE</literal>, without first waiting for pending
   floating-point exceptions to clear.</para>
 </sect1>

 <sect1 id="inst-ref-fscale">
  <title><literal>FSCALE</literal>: Scale Floating-Point Value by
   Power of Two</title>

  <indexterm>
   <primary><literal>FSCALE</literal></primary>
  </indexterm>

  <screen>FSCALE                        ; D9 FD                [8086,FPU]</screen>

  <para><literal>FSCALE</literal> scales a number by a power of two:
   it rounds &reg.st1; towards zero to obtain an integer, then
   multiplies &reg.st0; by two to the power of that integer, and
   stores the result in &reg.st0;.</para>
 </sect1>

 <sect1 id="inst-ref-fsetpm">
  <title><literal>FSETPM</literal>: Set Protected Mode</title>

  <indexterm>
   <primary><literal>FSETPM</literal></primary>
  </indexterm>

  <screen>FSETPM                        ; DB E4                [286,FPU]</screen>

  <para>This instruction initializes protected mode on the 287
   floating-point coprocessor. It is only meaningful on that
   processor: the 387 and above treat the instruction as a
   no-operation.</para>
 </sect1>

 <sect1 id="inst-ref-fsin">
  <title><literal>FSIN</literal>, <literal>FSINCOS</literal>: Sine and
   Cosine</title>

  <indexterm>
   <primary><literal>FSIN</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FSINCOS</literal></primary>
  </indexterm>

  <screen>FSIN                          ; D9 FE                [386,FPU]
FSINCOS                       ; D9 FB                [386,FPU]</screen>

  <para><literal>FSIN</literal> calculates the sine of &reg.st0; (in
   radians) and stores the result in &reg.st0;.
   <literal>FSINCOS</literal> does the same, but then pushes the
   cosine of the same value on the register stack, so that the sine
   ends up in &reg.st1; and the cosine in &reg.st0;.
   <literal>FSINCOS</literal> is faster than executing
   <literal>FSIN</literal> and <literal>FCOS</literal> (see
   <xref linkend="inst-ref-fcos">) in succession.</para>

  <para>The absolute value of &reg.st0; must be less than
   2<superscript>63</superscript>.</para>
 </sect1>

 <sect1 id="inst-ref-fsqrt">
  <title><literal>FSQRT</literal>: Floating-Point Square Root</title>

  <indexterm>
   <primary><literal>FSQRT</literal></primary>
  </indexterm>

  <screen>FSQRT                         ; D9 FA                [8086,FPU]</screen>

  <para><literal>FSQRT</literal> calculates the square root of
   &reg.st0; and stores the result in &reg.st0;.</para>
 </sect1>

 <sect1 id="inst-ref-fst">
  <title><literal>FST</literal>, <literal>FSTP</literal>:
   Floating-Point Store</title>

  <indexterm>
   <primary><literal>FST</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FSTP</literal></primary>
  </indexterm>

  <screen>FST mem32                     ; D9 /2                [8086,FPU]
FST mem64                     ; DD /2                [8086,FPU]
FST fpureg                    ; DD D0+r              [8086,FPU]

FSTP mem32                    ; D9 /3                [8086,FPU]
FSTP mem64                    ; DD /3                [8086,FPU]
FSTP mem80                    ; DB /7                [8086,FPU]
FSTP fpureg                   ; DD D8+r              [8086,FPU]</screen>

  <para><literal>FST</literal> stores the value in &reg.st0; into the
   given memory location or other FPU register.
   <literal>FSTP</literal> does the same, but then pops the register
   stack.</para>
 </sect1>

 <sect1 id="inst-ref-fstcw">
  <title><literal>FSTCW</literal>: Store Floating-Point Control Word</title>

  <indexterm>
   <primary><literal>FSTCW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FNSTCW</literal></primary>
  </indexterm>

  <screen>FSTCW mem16                   ; 9B D9 /7             [8086,FPU]
FNSTCW mem16                  ; D9 /7                [8086,FPU]</screen>

  <para><literal>FSTCW</literal> stores the &reg.fpu; control word
   (governing things like the rounding mode, the precision, and the
   exception masks) into a 2-byte memory area. See also
   <literal>FLDCW</literal> (<xref linkend="inst-ref-fldcw">).</para>

  <para><literal>FNSTCW</literal> does the same thing as
   <literal>FSTCW</literal>, without first waiting for pending
   floating-point exceptions to clear.</para>
 </sect1>

 <sect1 id="inst-ref-fstenv">
  <title><literal>FSTENV</literal>: Store Floating-Point
   Environment</title>

  <indexterm>
   <primary><literal>FSTENV</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FNSTENV</literal></primary>
  </indexterm>

  <screen>FSTENV mem                    ; 9B D9 /6             [8086,FPU]
FNSTENV mem                   ; D9 /6                [8086,FPU]</screen>

  <para><literal>FSTENV</literal> stores the &reg.fpu; operating
   environment (control word, status word, tag word, instruction
   pointer, data pointer and last opcode) into memory. The memory area
   is 14 or 28 bytes long, depending on the CPU mode at the time. See
   also <literal>FLDENV</literal> (<xref
    linkend="inst-ref-fldenv">).</para>

  <para><literal>FNSTENV</literal> does the same thing as
   <literal>FSTENV</literal>, without first waiting for pending
   floating-point exceptions to clear.</para>
 </sect1>

 <sect1 id="inst-ref-fstsw">
  <title><literal>FSTSW</literal>: Store Floating-Point Status
   Word</title>

  <indexterm>
   <primary><literal>FSTSW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FNSTSW</literal></primary>
  </indexterm>

  <screen>FSTSW mem16                   ; 9B DD /7             [8086,FPU]
FSTSW AX                      ; 9B DF E0             [286,FPU]

FNSTSW mem16                  ; DD /7                [8086,FPU]
FNSTSW AX                     ; DF E0                [286,FPU]</screen>

  <para><literal>FSTSW</literal> stores the &reg.fpu; status word into
   &reg.ax; or into a 2-byte memory area.</para>

  <para><literal>FNSTSW</literal> does the same thing as
   <literal>FSTSW</literal>, without first waiting for pending
   floating-point exceptions to clear.</para>
 </sect1>

 <sect1 id="inst-ref-fsub">
  <title><literal>FSUB</literal>, <literal>FSUBP</literal>,
   <literal>FSUBR</literal>, <literal>FSUBRP</literal>: Floating-Point
   Subtract</title>

  <indexterm>
   <primary><literal>FSUB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FSUBP</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FSUBR</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FSUBRP</literal></primary>
  </indexterm>

  <screen>FSUB mem32                    ; D8 /4                [8086,FPU]
FSUB mem64                    ; DC /4                [8086,FPU]

FSUB fpureg                   ; D8 E0+r              [8086,FPU]
FSUB ST0,fpureg               ; D8 E0+r              [8086,FPU]

FSUB TO fpureg                ; DC E8+r              [8086,FPU]
FSUB fpureg,ST0               ; DC E8+r              [8086,FPU]

FSUBR mem32                   ; D8 /5                [8086,FPU]
FSUBR mem64                   ; DC /5                [8086,FPU]

FSUBR fpureg                  ; D8 E8+r              [8086,FPU]
FSUBR ST0,fpureg              ; D8 E8+r              [8086,FPU]

FSUBR TO fpureg               ; DC E0+r              [8086,FPU]
FSUBR fpureg,ST0              ; DC E0+r              [8086,FPU]

FSUBP fpureg                  ; DE E8+r              [8086,FPU]
FSUBP fpureg,ST0              ; DE E8+r              [8086,FPU]

FSUBRP fpureg                 ; DE E0+r              [8086,FPU]
FSUBRP fpureg,ST0             ; DE E0+r              [8086,FPU]</screen>

  <para><literal>FSUB</literal> subtracts the given operand from
   &reg.st0; and stores the result back in &reg.st0;, unless the
   <literal>TO</literal> qualifier is given, in which case it
   subtracts &reg.st0; from the given operand and stores the result in
   the operand.</para>

  <para><literal>FSUBR</literal> does the same thing, but does the
   subtraction the other way up: so if <literal>TO</literal> is not
   given, it subtracts &reg.st0; from the given operand and stores the
   result in &reg.st0;, whereas if <literal>TO</literal> is given it
   subtracts its operand from &reg.st0; and stores the result in the
   operand.</para>

  <para><literal>FSUBP</literal> operates like <literal>FSUB
    TO</literal>, but pops the register stack once it has
   finished.</para>

  <para><literal>FSUBRP</literal> operates like <literal>FSUBR
    TO</literal>, but pops the register stack once it has
   finished.</para>
 </sect1>

 <sect1 id="inst-ref-ftst">
  <title><literal>FTST</literal>: Test &reg.st0; Against Zero</title>

  <indexterm>
   <primary><literal>FTST</literal></primary>
  </indexterm>

  <screen>FTST                          ; D9 E4                [8086,FPU]</screen>

  <para><literal>FTST</literal> compares &reg.st0; with zero and sets
   the FPU flags accordingly. &reg.st0; is treated as the left-hand
   side of the comparison, so that a <quote>less-than</quote> result
   is generated if &reg.st0; is negative.</para>
 </sect1>

 <sect1 id="inst-ref-fucom">
  <title><literal>FUCOMxx</literal>: Floating-Point Unordered
   Compare</title>

  <indexterm>
   <primary><literal>FUCOMxx</literal></primary>
  </indexterm>

  <screen>FUCOM fpureg                  ; DD E0+r              [386,FPU]
FUCOM ST0,fpureg              ; DD E0+r              [386,FPU]

FUCOMP fpureg                 ; DD E8+r              [386,FPU]
FUCOMP ST0,fpureg             ; DD E8+r              [386,FPU]

FUCOMPP                       ; DA E9                [386,FPU]

FUCOMI fpureg                 ; DB E8+r              [P6,FPU]
FUCOMI ST0,fpureg             ; DB E8+r              [P6,FPU]

FUCOMIP fpureg                ; DF E8+r              [P6,FPU]
FUCOMIP ST0,fpureg            ; DF E8+r              [P6,FPU]</screen>

  <para><literal>FUCOM</literal> compares &reg.st0; with the given
   operand, and sets the &reg.fpu; flags accordingly. &reg.st0; is
   treated as the left-hand side of the comparison, so that the carry
   flag is set (for a <quote>less-than</quote> result) if &reg.st0; is
   less than the given operand.</para>

  <para><literal>FUCOMP</literal> does the same as
   <literal>FUCOM</literal>, but pops the register stack afterwards.
   <literal>FUCOMPP</literal> compares &reg.st0; with &reg.st1; and
   then pops the register stack twice.</para>

  <para><literal>FUCOMI</literal> and <literal>FUCOMIP</literal> work
   like the corresponding forms of <literal>FUCOM</literal> and
   <literal>FUCOMP</literal>, but write their results directly to the
   CPU flags register rather than the &reg.fpu; status word, so they
   can be immediately followed by conditional jump or conditional move
   instructions.</para>

  <para>The <literal>FUCOM</literal> instructions differ from the
   <literal>FCOM</literal> instructions (<xref
    linkend="inst-ref-fcom">) only in the way they handle quiet NaNs:
   <literal>FUCOM</literal> will handle them silently and set the
   condition code flags to an <quote>unordered</quote> result, whereas
   <literal>FCOM</literal> will generate an exception.</para>
 </sect1>

 <sect1 id="inst-ref-fxam">
  <title><literal>FXAM</literal>: Examine Class of Value in
   &reg.st0;</title>

  <indexterm>
   <primary><literal>FXAM</literal></primary>
  </indexterm>

  <screen>FXAM                          ; D9 E5                [8086,FPU]</screen>

  <para><literal>FXAM</literal> sets the FPU flags C3, C2 and C0
   depending on the type of value stored in &reg.st0;:</para>

  <informaltable frame="none">
   <tgroup cols="2">
    <colspec colname="regcontents">
    <colspec colname="flags">

    <thead>
     <row>
      <entry>Register contents</entry>
      <entry>Flags</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>Unsupported format</entry>
      <entry>000</entry>
     </row>

     <row>
      <entry>NaN</entry>
      <entry>001</entry>
     </row>

     <row>
      <entry>Finite number</entry>
      <entry>010</entry>
     </row>

     <row>
      <entry>Infinity</entry>
      <entry>011</entry>
     </row>

     <row>
      <entry>Zero</entry>
      <entry>100</entry>
     </row>

     <row>
      <entry>Empty register</entry>
      <entry>101</entry>
     </row>

     <row>
      <entry>Denormal</entry>
      <entry>110</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <para>Additionally, the <literal>C1</literal> flag is set to the
   sign of the number.</para>
 </sect1>

 <sect1 id="inst-ref-fxch">
  <title><literal>FXCH</literal>: Floating-Point Exchange</title>

  <indexterm>
   <primary><literal>FXCH</literal></primary>
  </indexterm>

  <screen>FXCH                          ; D9 C9                [8086,FPU]
FXCH fpureg                   ; D9 C8+r              [8086,FPU]
FXCH fpureg,ST0               ; D9 C8+r              [8086,FPU]
FXCH ST0,fpureg               ; D9 C8+r              [8086,FPU]</screen>

  <para><literal>FXCH</literal> exchanges &reg.st0; with a given FPU
   register. The no-operand form exchanges &reg.st0; with
   &reg.st1;.</para>
 </sect1>

 <sect1 id="inst-ref-fxrstor">
  <title><literal>FXRSTOR</literal>: Restore &reg.fpu;, &reg.mmx;, and
   &reg.xmm; State</title>

  <indexterm>
   <primary><literal>FXRSTOR</literal></primary>
  </indexterm>

  <screen>FXRSTOR memory           ; 0F,AE,/1               [P6,SSE,FPU]</screen>

  <para>The <literal>FXRSTOR</literal> instruction reloads the
   &reg.fpu;, &reg.mmx;, and &reg.xmm; states (environment and
   registers), from the 512-byte memory area defined by the source
   operand.  This data should have been written by a previous
   <literal>FXSAVE</literal>.</para>
 </sect1>

 <sect1 id="inst-ref-fxsave">
  <title><literal>FXSAVE</literal>: Store &reg.fpu;, &reg.mmx;, and
   &reg.xmm; State</title>

  <indexterm>
   <primary><literal>FXSAVE</literal></primary>
  </indexterm>

  <screen>FXSAVE memory           ; 0F,AE,/0         [P6,SSE,FPU]</screen>

  <para><literal>FXSAVE</literal>The FXSAVE instruction writes the
   current &reg.fpu;, &reg.mmx;, and &reg.xmm; states (environment and
   registers) to the specified 512-byte destination defined by the
   destination operand.  It does this without checking for pending
   unmasked floating-point exceptions (similar to the operation of
   <literal>FNSAVE</literal>).</para>

  <para>Unlike the <literal>FSAVE</literal>/<literal>FNSAVE</literal>
   instructions, the processor retains the contents of the &reg.fpu;,
   &reg.mmx;, and &reg.xmm; state in the processor after the state has
   been saved.  This instruction has been optimized to maximize
   floating-point save performance.</para>
 </sect1>

 <sect1 id="inst-ref-fxtract">
  <title><literal>FXTRACT</literal>: Extract Exponent and
   Significand</title>

  <indexterm>
   <primary><literal>FXTRACT</literal></primary>
  </indexterm>

  <screen>FXTRACT                       ; D9 F4                [8086,FPU]</screen>

  <para><literal>FXTRACT</literal> separates the number in &reg.st0;
   into its exponent and significand (mantissa), stores the exponent
   back into &reg.st0;, and then pushes the significand on the
   register stack (so that the significand ends up in &reg.st0;, and
   the exponent in &reg.st1;).</para>
 </sect1>

 <sect1 id="inst-ref-fyl2x">
  <title><literal>FYL2X</literal>, <literal>FYL2XP1</literal>: Compute
   Y times Log2(X) or Log2(X+1)</title>

  <indexterm>
   <primary><literal>FYL2X</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>FYL2XP1</literal></primary>
  </indexterm>

  <screen>FYL2X                         ; D9 F1                [8086,FPU]
FYL2XP1                       ; D9 F9                [8086,FPU]</screen>

  <para><literal>FYL2X</literal> multiplies &reg.st1; by the base-2
   logarithm of &reg.st0;, stores the result in &reg.st1;, and pops
   the register stack (so that the result ends up in &reg.st0;).
   &reg.st0; must be non-zero and positive.</para>

  <para><literal>FYL2XP1</literal> works the same way, but replacing
   the base-2 log of &reg.st0; with that of &reg.st0; plus one. This
   time, &reg.st0; must have magnitude no greater than 1 minus half
   the square root of two.</para>
 </sect1>

 <sect1 id="inst-ref-hlt">
  <title><literal>HLT</literal>: Halt Processor</title>

  <indexterm>
   <primary><literal>HLT</literal></primary>
  </indexterm>

  <screen>HLT                           ; F4                   [8086,PRIV]</screen>

  <para><literal>HLT</literal> puts the processor into a halted state,
   where it will perform no more operations until restarted by an
   interrupt or a reset.</para>

  <para>On the 286 and later processors, this is a privileged
   instruction.</para>
 </sect1>
<![%inst-ref.undoc;[
 <sect1 id="inst-ref-ibts">
  <title><literal>IBTS</literal>: Insert Bit String</title>

  <indexterm>
   <primary><literal>IBTS</literal></primary>
  </indexterm>

  <screen>IBTS r/m16,reg16              ; o16 0F A7 /r         [386,UNDOC]
IBTS r/m32,reg32              ; o32 0F A7 /r         [386,UNDOC]</screen>

  <para>The implied operation of this instruction is:</para>

  <programlisting>IBTS r/m16,AX,CL,reg16
IBTS r/m32,EAX,CL,reg32</programlisting>

  <para>Writes a bit string from the source operand to the
   destination.  &reg.cl; indicates the number of bits to be copied,
   from the low bits of the source. &reg.ax;/&reg.eax; indicates the
   low order bit offset in the destination that is written to.  For
   example, if &reg.cl; is set to 4 and &reg.ax; (for 16-bit code) is
   set to 5, bits 0-3 of <literal>src</literal> will be copied to bits
   5-8 of <literal>dst</literal>. This instruction is very poorly
   documented, and I have been unable to find any official source of
   documentation on it.</para>

  <para><literal>IBTS</literal> is supported only on the early Intel
   386s, and conflicts with the opcodes for
   <literal>CMPXCHG486</literal> (on early Intel 486s).  NASM supports
   it only for completeness. Its counterpart is
   <literal>XBTS</literal> (see <xref
    linkend="inst-ref-xbts">).</para>
 </sect1>
]]>
 <sect1 id="inst-ref-idiv">
  <title><literal>IDIV</literal>: Signed Integer Divide</title>

  <indexterm>
   <primary><literal>IDIV</literal></primary>
  </indexterm>

  <screen>IDIV r/m8                     ; F6 /7                [8086]
IDIV r/m16                    ; o16 F7 /7            [8086]
IDIV r/m32                    ; o32 F7 /7            [386]</screen>

  <para><literal>IDIV</literal> performs signed integer division. The
   explicit operand provided is the divisor; the dividend and
   destination operands are implicit, in the following way:</para>

  <itemizedlist>
   <listitem>
    <para>For <literal>IDIV r/m8</literal>, &reg.ax; is divided by the
     given operand; the quotient is stored in &reg.al; and the
     remainder in &reg.ah;.</para>
   </listitem>

   <listitem>
    <para>For <literal>IDIV r/m16</literal>,
     <literal>&reg.dx;:&reg.ax;</literal> is divided by the given
     operand; the quotient is stored in &reg.ax; and the remainder in
     &reg.dx;.</para>
   </listitem>

   <listitem>
    <para>For <literal>IDIV r/m32</literal>,
     <literal>&reg.edx;:&reg.eax;</literal> is divided by the given
     operand; the quotient is stored in &reg.eax; and the remainder in
     &reg.edx;.</para>
   </listitem>
  </itemizedlist>

  <para>Unsigned integer division is performed by the
   <literal>DIV</literal> instruction: see <xref
    linkend="inst-ref-div">.</para>
 </sect1>

 <sect1 id="inst-ref-imul">
  <title><literal>IMUL</literal>: Signed Integer Multiply</title>

  <indexterm>
   <primary><literal>IMUL</literal></primary>
  </indexterm>

  <screen>IMUL r/m8                     ; F6 /5                [8086]
IMUL r/m16                    ; o16 F7 /5            [8086]
IMUL r/m32                    ; o32 F7 /5            [386]

IMUL reg16,r/m16              ; o16 0F AF /r         [386]
IMUL reg32,r/m32              ; o32 0F AF /r         [386]

IMUL reg16,imm8               ; o16 6B /r ib         [286]
IMUL reg16,imm16              ; o16 69 /r iw         [286]
IMUL reg32,imm8               ; o32 6B /r ib         [386]
IMUL reg32,imm32              ; o32 69 /r id         [386]

IMUL reg16,r/m16,imm8         ; o16 6B /r ib         [286]
IMUL reg16,r/m16,imm16        ; o16 69 /r iw         [286]
IMUL reg32,r/m32,imm8         ; o32 6B /r ib         [386]
IMUL reg32,r/m32,imm32        ; o32 69 /r id         [386]</screen>

  <para><literal>IMUL</literal> performs signed integer
   multiplication. For the single-operand form, the other operand and
   destination are implicit, in the following way:</para>

  <itemizedlist>
   <listitem>
    <para>For <literal>IMUL r/m8</literal>, &reg.al; is multiplied by
     the given operand; the product is stored in &reg.ax;.</para>
   </listitem>

   <listitem>
    <para>For <literal>IMUL r/m16</literal>, &reg.ax; is multiplied by
     the given operand; the product is stored in
     <literal>&reg.dx;:&reg.ax;</literal>.</para>
   </listitem>

   <listitem>
    <para>For <literal>IMUL r/m32</literal>, &reg.eax; is multiplied
     by the given operand; the product is stored in
     <literal>&reg.edx;:&reg.eax;</literal>.</para>
   </listitem>
  </itemizedlist>

  <para>The two-operand form multiplies its two operands and stores
   the result in the destination (first) operand. The three-operand
   form multiplies its last two operands and stores the result in the
   first operand.</para>

  <para>The two-operand form with an immediate second operand is in
   fact a shorthand for the three-operand form, as can be seen by
   examining the opcode descriptions: in the two-operand form, the
   code <literal>/r</literal> takes both its register and
   <literal>r/m</literal> parts from the same operand (the first
   one).</para>

  <para>In the forms with an 8-bit immediate operand and another
   longer source operand, the immediate operand is considered to be
   signed, and is sign-extended to the length of the other source
   operand. In these cases, the <literal>BYTE</literal> qualifier is
   necessary to force NASM to generate this form of the
   instruction.</para>

  <para>Unsigned integer multiplication is performed by the
   <literal>MUL</literal> instruction: see <xref
    linkend="inst-ref-mul">.</para>
 </sect1>

 <sect1 id="inst-ref-in">
  <title><literal>IN</literal>: Input from I/O Port</title>

  <indexterm>
   <primary><literal>IN</literal></primary>
  </indexterm>

  <screen>IN AL,imm8                    ; E4 ib                [8086]
IN AX,imm8                    ; o16 E5 ib            [8086]
IN EAX,imm8                   ; o32 E5 ib            [386]
IN AL,DX                      ; EC                   [8086]
IN AX,DX                      ; o16 ED               [8086]
IN EAX,DX                     ; o32 ED               [386]</screen>

  <para><literal>IN</literal> reads a byte, word or doubleword from
   the specified I/O port, and stores it in the given destination
   register. The port number may be specified as an immediate value if
   it is between 0 and 255, and otherwise must be stored in
   <literal>DX</literal>. See also <literal>OUT</literal> (<xref
    linkend="inst-ref-out">).</para>
 </sect1>

 <sect1 id="inst-ref-inc">
  <title><literal>INC</literal>: Increment Integer</title>

  <indexterm>
   <primary><literal>INC</literal></primary>
  </indexterm>

  <screen>INC reg16                     ; o16 40+r             [8086]
INC reg32                     ; o32 40+r             [386]
INC r/m8                      ; FE /0                [8086]
INC r/m16                     ; o16 FF /0            [8086]
INC r/m32                     ; o32 FF /0            [386]</screen>

  <para><literal>INC</literal> adds 1 to its operand. It does
   <emphasis>not</emphasis> affect the carry flag: to affect the carry
   flag, use <literal>ADD something,1</literal> (see <xref
    linkend="inst-ref-add">).  <literal>INC</literal> affects all the
   other flags according to the result.</para>

  <para>This instruction can be used with the <literal>LOCK</literal>
   prefix to allow atomic execution.</para>

  <para>See also <literal>DEC</literal> (<xref
    linkend="inst-ref-dec">).</para>
 </sect1>

 <sect1 id="inst-ref-insb">
  <title><literal>INSB</literal>, <literal>INSW</literal>,
   <literal>INSD</literal>: Input String from I/O Port</title>

  <indexterm>
   <primary><literal>INSB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>INSW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>INSD</literal></primary>
  </indexterm>

  <screen>INSB                          ; 6C                   [186]
INSW                          ; o16 6D               [186]
INSD                          ; o32 6D               [386]</screen>

  <para><literal>INSB</literal> inputs a byte from the I/O port
   specified in &reg.dx; and stores it at
   <literal>[&reg.es;:&reg.di;]</literal> or
   <literal>[&reg.es;:&reg.edi;]</literal>. It then increments or
   decrements (depending on the direction flag: increments if the flag
   is clear, decrements if it is set) &reg.di; or &reg.edi;.</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The register used is &reg.di; if the address size is 16 bits,
   and &reg.edi; if it is 32 bits. If you need to use an address size
   not equal to the current <literal>BITS</literal> setting, you can
   use an explicit <literal>a16</literal> or <literal>a32</literal>
   prefix.</para>

  <para>Segment override prefixes have no effect for this instruction:
   the use of &reg.es; for the load from <literal>[DI]</literal> or
   <literal>[&reg.edi;]</literal> cannot be overridden.</para>

  <para><literal>INSW</literal> and <literal>INSD</literal> work in
   the same way, but they input a word or a doubleword instead of a
   byte, and increment or decrement the addressing register by 2 or 4
   instead of 1.</para>

  <para>The <literal>REP</literal> prefix may be used to repeat the
   instruction &reg.cx; (or &reg.ecx; - again, the address size
   chooses which) times.</para>

  <para>See also <literal>OUTSB</literal>, <literal>OUTSW</literal>
   and <literal>OUTSD</literal> (<xref
    linkend="inst-ref-outsb">).</para>
 </sect1>

 <sect1 id="inst-ref-int">
  <title><literal>INT</literal>: Software Interrupt</title>

  <indexterm>
   <primary><literal>INT</literal></primary>
  </indexterm>

  <screen>INT imm8                      ; CD ib                [8086]</screen>

  <para><literal>INT</literal> causes a software interrupt through a
   specified vector number from 0 to 255.</para>

  <para>The code generated by the <literal>INT</literal> instruction
   is always two bytes long: although there are short forms for some
   <literal>INT</literal> instructions, NASM does not generate them
   when it sees the <literal>INT</literal> mnemonic. In order to
   generate single-byte breakpoint instructions, use the
   <literal>INT3</literal> or <literal>INT1</literal> instructions
   (see <xref linkend="inst-ref-int1">) instead.</para>
 </sect1>

 <sect1 id="inst-ref-int1">
  <title><literal>INT3</literal>, <literal>INT1</literal>,
   <literal>ICEBP</literal>, <literal>INT01</literal>:
   Breakpoints</title>

  <indexterm>
   <primary><literal>INT3</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>INT1</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>ICEBP</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>INT01</literal></primary>
  </indexterm>

  <screen>INT1                          ; F1                   [P6]
ICEBP                         ; F1                   [P6]
INT01                         ; F1                   [P6]

INT3                          ; CC                   [8086]
INT03                         ; CC                   [8086]</screen>

  <para><literal>INT1</literal> and <literal>INT3</literal> are short
   one-byte forms of the instructions <literal>INT 1</literal> and
   <literal>INT 3</literal> (see <xref linkend="inst-ref-int">). They
   perform a similar function to their longer counterparts, but take
   up less code space. They are used as breakpoints by
   debuggers.</para>

  <para><literal>INT1</literal>, and its alternative synonyms
   <literal>INT01</literal> and <literal>ICEBP</literal>, is an
   instruction used by in-circuit emulators (ICEs). It is present,
   though not documented, on some processors down to the 286, but is
   only documented for the Pentium Pro. <literal>INT3</literal> is the
   instruction normally used as a breakpoint by debuggers.</para>

  <para><literal>INT3</literal> and its synonym
   <literal>INT03</literal> are not precisely equivalent to
   <literal>INT 3</literal>: the short form, since it is designed to
   be used as a breakpoint, bypasses the normal
   <literal>IOPL</literal> checks in virtual-8086 mode, and also does
   not go through interrupt redirection.</para>
 </sect1>

 <sect1 id="inst-ref-into">
  <title><literal>INTO</literal>: Interrupt if Overflow</title>

  <indexterm>
   <primary><literal>INTO</literal></primary>
  </indexterm>

  <screen>INTO                          ; CE                   [8086]</screen>

  <para><literal>INTO</literal> performs an <literal>INT 4</literal>
   software interrupt (see <xref linkend="inst-ref-int">) if and only
   if the overflow flag is set.</para>
 </sect1>

 <sect1 id="inst-ref-invd">
  <title><literal>INVD</literal>: Invalidate Internal Caches</title>

  <indexterm>
   <primary><literal>INVD</literal></primary>
  </indexterm>

  <screen>INVD                          ; 0F 08                [486]</screen>

  <para><literal>INVD</literal> invalidates and empties the
   processor's internal caches, and causes the processor to instruct
   external caches to do the same. It does not write the contents of
   the caches back to memory first: any modified data held in the
   caches will be lost. To write the data back first, use
   <literal>WBINVD</literal> (<xref
    linkend="inst-ref-wbinvd">).</para>
 </sect1>

 <sect1 id="inst-ref-invlpg">
  <title><literal>INVLPG</literal>: Invalidate TLB Entry</title>

  <indexterm>
   <primary><literal>INVLPG</literal></primary>
  </indexterm>

  <screen>INVLPG mem                    ; 0F 01 /7             [486]</screen>

  <para><literal>INVLPG</literal> invalidates the translation
   lookahead buffer (TLB) entry associated with the supplied memory
   address.</para>
 </sect1>

 <sect1 id="inst-ref-iret">
  <title><literal>IRET</literal>, <literal>IRETW</literal>,
   <literal>IRETD</literal>: Return from Interrupt</title>

  <indexterm>
   <primary><literal>IRET</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>IRETW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>IRETD</literal></primary>
  </indexterm>

  <screen>IRET                          ; CF                   [8086]
IRETW                         ; o16 CF               [8086]
IRETD                         ; o32 CF               [386]</screen>

  <para><literal>IRET</literal> returns from an interrupt (hardware or
   software) by means of popping &reg.ip; (or &reg.eip;), &reg.cs;,
   and the flags off the stack and then continuing execution from the
   new <literal>&reg.cs;:&reg.ip;</literal>.</para>

  <para><literal>IRETW</literal> pops &reg.ip;, &reg.cs; and the flags
   as 2 bytes each, taking 6 bytes off the stack in total.
   <literal>IRETD</literal> pops &reg.eip; as 4 bytes, pops a further
   4 bytes of which the top two are discarded and the bottom two go
   into &reg.cs;, and pops the flags as 4 bytes as well, taking 12
   bytes off the stack.</para>

  <para><literal>IRET</literal> is a shorthand for either
   <literal>IRETW</literal> or <literal>IRETD</literal>, depending on
   the default <literal>BITS</literal> setting at the time.</para>
 </sect1>

 <sect1 id="inst-ref-jcxz">
  <title><literal>JCXZ</literal>, <literal>JECXZ</literal>: Jump if
   CX/ECX Zero</title>

  <indexterm>
   <primary><literal>JCXZ</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>JECXZ</literal></primary>
  </indexterm>

  <screen>JCXZ imm                      ; a16 E3 rb            [8086]
JECXZ imm                     ; a32 E3 rb            [386]</screen>

  <para><literal>JCXZ</literal> performs a short jump (with maximum
   range 128 bytes) if and only if the contents of the &reg.cx;
   register is 0. <literal>JECXZ</literal> does the same thing, but
   with &reg.ecx;.</para>
 </sect1>

 <sect1 id="inst-ref-jcc">
  <title><literal>Jcc</literal>: Conditional Branch</title>

  <indexterm>
   <primary><literal>Jcc</literal></primary>
  </indexterm>

  <screen>Jcc imm                       ; 70+cc rb             [8086]
Jcc NEAR imm                  ; 0F 80+cc rw/rd       [386]</screen>

  <indexterm>
   <primary>conditional jump</primary>
  </indexterm>

  <para>The conditional jump instructions execute a near (same
   segment) jump if and only if their conditions are satisfied. For
   example, <literal>JNZ</literal> jumps only if the zero flag is not
   set.</para>

  <para>The ordinary form of the instructions has only a 128-byte
   range; the <literal>NEAR</literal> form is a 386 extension to the
   instruction set, and can span the full size of a segment. NASM will
   not override your choice of jump instruction: if you want
   <literal>Jcc NEAR</literal>, you have to use the
   <literal>NEAR</literal> keyword.</para>

  <para>The <literal>SHORT</literal> keyword is allowed on the first
   form of the instruction, for clarity, but is not necessary.</para>

  <para>For details on the condition codes, see <xref
    linkend="inst-ref-opcode-desc-cond-codes">.</para>
 </sect1>

 <sect1 id="inst-ref-jmp">
  <title><literal>JMP</literal>: Jump</title>

  <indexterm>
   <primary><literal>JMP</literal></primary>
  </indexterm>

  <screen>JMP imm                       ; E9 rw/rd             [8086]
JMP SHORT imm                 ; EB rb                [8086]
JMP imm:imm16                 ; o16 EA iw iw         [8086]
JMP imm:imm32                 ; o32 EA id iw         [386]
JMP FAR mem                   ; o16 FF /5            [8086]
JMP FAR mem32                 ; o32 FF /5            [386]
JMP r/m16                     ; o16 FF /4            [8086]
JMP r/m32                     ; o32 FF /4            [386]</screen>

  <para><literal>JMP</literal> jumps to a given address. The address
   may be specified as an absolute segment and offset, or as a
   relative jump within the current segment.</para>

  <para><literal>JMP SHORT imm</literal> has a maximum range of 128
   bytes, since the displacement is specified as only 8 bits, but
   takes up less code space. NASM does not choose when to generate
   <literal>JMP SHORT</literal> for you: you must explicitly code
   <literal>SHORT</literal> every time you want a short jump.</para>

  <indexterm>
   <primary>far jump</primary>
  </indexterm>

  <para>You can choose between the two immediate far jump forms
   (<literal>JMP imm:imm</literal>) by the use of the
   <literal>WORD</literal> and <literal>DWORD</literal> keywords:
   <literal>JMP WORD 0x1234:0x5678</literal>) or <literal>JMP DWORD
    0x1234:0x56789abc</literal>.</para>

  <para>The <literal>JMP FAR mem</literal> forms execute a far jump by
   loading the destination address out of memory. The address loaded
   consists of 16 or 32 bits of offset (depending on the operand
   size), and 16 bits of segment. The operand size may be overridden
   using <literal>JMP WORD FAR mem</literal> or <literal>JMP DWORD FAR
    mem</literal>.</para>

  <indexterm>
   <primary>near jump</primary>
  </indexterm>

  <para>The <literal>JMP r/m</literal> forms execute a near jump
   (within the same segment), loading the destination address out of
   memory or out of a register. The keyword <literal>NEAR</literal>
   may be specified, for clarity, in these forms, but is not
   necessary. Again, operand size can be overridden using <literal>JMP
    WORD mem</literal> or <literal>JMP DWORD mem</literal>.</para>

  <para>As a convenience, NASM does not require you to jump to a far
   symbol by coding the cumbersome <literal>JMP SEG
    routine:routine</literal>, but instead allows the easier synonym
   <literal>JMP FAR routine</literal>.</para>

  <para>The <literal>CALL r/m</literal> forms given above are near
   calls; NASM will accept the <literal>NEAR</literal> keyword (e.g.
   <literal>CALL NEAR [address]</literal>), even though it is not
   strictly necessary.</para>
 </sect1>

 <sect1 id="inst-ref-lahf">
  <title><literal>LAHF</literal>: Load &reg.ah; from Flags</title>

  <indexterm>
   <primary><literal>LAHF</literal></primary>
  </indexterm>

  <screen>LAHF                          ; 9F                   [8086]</screen>

  <para><literal>LAHF</literal> sets the &reg.ah; register according
   to the contents of the low byte of the flags word.</para>

  <para>The operation of <literal>LAHF</literal> is:</para>

  <screen>AH <-- SF:ZF:0:AF:0:PF:1:CF</screen>

  <para>See also <literal>SAHF</literal> (<xref
    linkend="inst-ref-sahf">).</para>
 </sect1>

 <sect1 id="inst-ref-lar">
  <title><literal>LAR</literal>: Load Access Rights</title>

  <indexterm>
   <primary><literal>LAR</literal></primary>
  </indexterm>

  <screen>LAR reg16,r/m16               ; o16 0F 02 /r         [286,PRIV]
LAR reg32,r/m32               ; o32 0F 02 /r         [286,PRIV]</screen>

  <para><literal>LAR</literal> takes the segment selector specified by
   its source (second) operand, finds the corresponding segment
   descriptor in the GDT or LDT, and loads the access-rights byte of
   the descriptor into its destination (first) operand.</para>
 </sect1>

 <sect1 id="inst-ref-ldmxcsr">
  <title><literal>LDMXCSR</literal>: Load Streaming SIMD Extension
   Control/Status</title>

  <indexterm>
   <primary><literal>LDMXCSR</literal></primary>
  </indexterm>

  <screen>LDMXCSR mem32                 ; 0F AE /2        [KATMAI,SSE]</screen>

  <para><literal>LDMXCSR</literal> loads 32-bits of data from the
   specified memory location into the <literal>MXCSR</literal>
   control/status register. <literal>MXCSR</literal> is used to enable
   masked/unmasked exception handling, to set rounding modes, to set
   flush-to-zero mode, and to view exception status flags.</para>

  <para>For details of the <literal>MXCSR</literal> register, see the
   Intel processor docs.</para>

  <para>See also <literal>STMXCSR</literal> (<xref
    linkend="inst-ref-stmxcsr">).</para>
 </sect1>

 <sect1 id="inst-ref-lds">
  <title><literal>LDS</literal>, <literal>LES</literal>,
   <literal>LFS</literal>, <literal>LGS</literal>,
   <literal>LSS</literal>: Load Far Pointer</title>

  <indexterm>
   <primary><literal>LDS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LES</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LFS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LGS</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LSS</literal></primary>
  </indexterm>

  <screen>LDS reg16,mem                 ; o16 C5 /r            [8086]
LDS reg32,mem                 ; o32 C5 /r            [386]

LES reg16,mem                 ; o16 C4 /r            [8086]
LES reg32,mem                 ; o32 C4 /r            [386]

LFS reg16,mem                 ; o16 0F B4 /r         [386]
LFS reg32,mem                 ; o32 0F B4 /r         [386]

LGS reg16,mem                 ; o16 0F B5 /r         [386]
LGS reg32,mem                 ; o32 0F B5 /r         [386]

LSS reg16,mem                 ; o16 0F B2 /r         [386]
LSS reg32,mem                 ; o32 0F B2 /r         [386]</screen>

  <para>These instructions load an entire far pointer (16 or 32 bits
   of offset, plus 16 bits of segment) out of memory in one go.
   <literal>LDS</literal>, for example, loads 16 or 32 bits from the
   given memory address into the given register (depending on the size
   of the register), then loads the <emphasis>next</emphasis> 16 bits
   from memory into &reg.ds;. <literal>LES</literal>,
   <literal>LFS</literal>, <literal>LGS</literal> and
   <literal>LSS</literal> work in the same way but use the other
   segment registers.</para>
 </sect1>

 <sect1 id="inst-ref-lea">
  <title><literal>LEA</literal>: Load Effective Address</title>

  <indexterm>
   <primary><literal>LEA</literal></primary>
  </indexterm>

  <screen>LEA reg16,mem                 ; o16 8D /r            [8086]
LEA reg32,mem                 ; o32 8D /r            [386]</screen>

  <para><literal>LEA</literal>, despite its syntax, does not access
   memory. It calculates the effective address specified by its second
   operand as if it were going to load or store data from it, but
   instead it stores the calculated address into the register
   specified by its first operand. This can be used to perform quite
   complex calculations (e.g. <literal>LEA
    EAX,[EBX+ECX*4+100]</literal>) in one instruction.</para>

  <para><literal>LEA</literal>, despite being a purely arithmetic
   instruction which accesses no memory, still requires square
   brackets around its second operand, as if it were a memory
   reference.</para>

  <para>The size of the calculation is the current
   <emphasis>address</emphasis> size, and the size that the result is
   stored as is the current <emphasis>operand</emphasis> size.  If the
   address and operand size are not the same, then if the addressing
   mode was 32-bits, the low 16-bits are stored, and if the address
   was 16-bits, it is zero-extended to 32-bits before storing.</para>
 </sect1>

 <sect1 id="inst-ref-leave">
  <title><literal>LEAVE</literal>: Destroy Stack Frame</title>

  <indexterm>
   <primary><literal>LEAVE</literal></primary>
  </indexterm>

  <screen>LEAVE                         ; C9                   [186]</screen>

  <para><literal>LEAVE</literal> destroys a stack frame of the form
   created by the <literal>ENTER</literal> instruction (see
   <xref linkend="inst-ref-enter">). It is functionally equivalent to
   <literal>MOV ESP,EBP</literal> followed by <literal>POP
    EBP</literal> (or <literal>MOV SP,BP</literal> followed by
   <literal>POP BP</literal> in 16-bit mode).</para>
 </sect1>

 <sect1 id="inst-ref-lfence">
  <title><literal>LFENCE</literal>: Load Fence</title>

  <indexterm>
   <primary><literal>LFENCE</literal></primary>
  </indexterm>

  <screen>LFENCE                        ; 0F AE /5        [WILLAMETTE,SSE2]</screen>

  <para><literal>LFENCE</literal> performs a serializing operation on
   all loads from memory that were issued before the
   <literal>LFENCE</literal> instruction. This guarantees that all
   memory reads before the <literal>LFENCE</literal> instruction are
   visible before any reads after the <literal>LFENCE</literal>
   instruction.</para>

  <para><literal>LFENCE</literal> is ordered respective to other
   <literal>LFENCE</literal> instruction, <literal>MFENCE</literal>,
   any memory read and any other serializing instruction (such as
   <literal>CPUID</literal>).</para>

  <para>Weakly ordered memory types can be used to achieve higher
   processor performance through such techniques as out-of-order issue
   and speculative reads. The degree to which a consumer of data
   recognizes or knows that the data is weakly ordered varies among
   applications and may be unknown to the producer of this data. The
   <literal>LFENCE</literal> instruction provides a
   performance-efficient way of ensuring load ordering between
   routines that produce weakly-ordered results and routines that
   consume that data.</para>

  <para><literal>LFENCE</literal> uses the following ModRM
   encoding:</para>

  <screen>           Mod (7:6)        = 11B
           Reg/Opcode (5:3) = 101B
           R/M (2:0)        = 000B</screen>

  <para>All other ModRM encodings are defined to be reserved, and use
   of these encodings risks incompatibility with future
   processors.</para>

  <para>see also <literal>SFENCE</literal> (<xref
    linkend="inst-ref-sfence">) and <literal>MFENCE</literal> (<xref
    linkend="inst-ref-mfence">).</para>
 </sect1>

 <sect1 id="inst-ref-lgdt">
  <title><literal>LGDT</literal>, <literal>LIDT</literal>,
   <literal>LLDT</literal>: Load Descriptor Tables</title>

  <indexterm>
   <primary><literal>LGDT</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LIDT</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LLDT</literal></primary>
  </indexterm>

  <screen>LGDT mem                      ; 0F 01 /2             [286,PRIV]
LIDT mem                      ; 0F 01 /3             [286,PRIV]
LLDT r/m16                    ; 0F 00 /2             [286,PRIV]</screen>

  <para><literal>LGDT</literal> and <literal>LIDT</literal> both take
   a 6-byte memory area as an operand: they load a 32-bit linear
   address and a 16-bit size limit from that area (in the opposite
   order) into the <literal>GDTR</literal> (global descriptor table
   register) or <literal>IDTR</literal> (interrupt descriptor table
   register). These are the only instructions which directly use
   <emphasis>linear</emphasis> addresses, rather than segment/offset
   pairs.</para>

  <para><literal>LLDT</literal> takes a segment selector as an
   operand. The processor looks up that selector in the
   <literal>GDT</literal> and stores the limit and base address given
   there into the <literal>LDTR</literal> (local descriptor table
   register).</para>

  <para>See also <literal>SGDT</literal>, <literal>SIDT</literal> and
   <literal>SLDT</literal> (<xref linkend="inst-ref-sgdt">).</para>
 </sect1>

 <sect1 id="inst-ref-lmsw">
  <title><literal>LMSW</literal>: Load/Store Machine Status
   Word</title>

  <indexterm>
   <primary><literal>LMSW</literal></primary>
  </indexterm>

  <screen>LMSW r/m16                    ; 0F 01 /6             [286,PRIV]</screen>

  <para><literal>LMSW</literal> loads the bottom four bits of the
   source operand into the bottom four bits of the
   <literal>CR0</literal> control register (or the Machine Status
   Word, on 286 processors). See also <literal>SMSW</literal> (<xref
    linkend="inst-ref-smsw">).</para>
 </sect1>

 <sect1 id="inst-ref-lodsb">
  <title><literal>LODSB</literal>, <literal>LODSW</literal>,
   <literal>LODSD</literal>: Load from String</title>

  <indexterm>
   <primary><literal>LODSB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LODSW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LODSD</literal></primary>
  </indexterm>

  <screen>LODSB                         ; AC                   [8086]
LODSW                         ; o16 AD               [8086]
LODSD                         ; o32 AD               [386]</screen>

  <para><literal>LODSB</literal> loads a byte from
   <literal>[&reg.ds;:&reg.si;]</literal> or
   <literal>[&reg.ds;:&reg.esi;]</literal> into &reg.al;. It then
   increments or decrements (depending on the direction flag:
   increments if the flag is clear, decrements if it is set) &reg.si;
   or &reg.esi;.</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The register used is &reg.si; if the address size is 16 bits,
   and &reg.esi; if it is 32 bits. If you need to use an address size
   not equal to the current <literal>BITS</literal> setting, you can
   use an explicit <literal>a16</literal> or <literal>a32</literal>
   prefix.</para>

  <para>The segment register used to load from
   <literal>[&reg.si;]</literal> or <literal>[&reg.esi;]</literal> can
   be overridden by using a segment register name as a prefix (for
   example, <literal>&reg.es; LODSB</literal>).</para>

  <para><literal>LODSW</literal> and <literal>LODSD</literal> work in
   the same way, but they load a word or a doubleword instead of a
   byte, and increment or decrement the addressing registers by 2 or 4
   instead of 1.</para>
 </sect1>

 <sect1 id="inst-ref-loop">
  <title><literal>LOOP</literal>, <literal>LOOPE</literal>,
   <literal>LOOPZ</literal>, <literal>LOOPNE</literal>,
   <literal>LOOPNZ</literal>: Loop with Counter</title>

  <indexterm>
   <primary><literal>LOOP</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LOOPE</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LOOPZ</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LOOPNE</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>LOOPNZ</literal></primary>
  </indexterm>

  <screen>LOOP imm                      ; E2 rb                [8086]
LOOP imm,CX                   ; a16 E2 rb            [8086]
LOOP imm,ECX                  ; a32 E2 rb            [386]

LOOPE imm                     ; E1 rb                [8086]
LOOPE imm,CX                  ; a16 E1 rb            [8086]
LOOPE imm,ECX                 ; a32 E1 rb            [386]
LOOPZ imm                     ; E1 rb                [8086]
LOOPZ imm,CX                  ; a16 E1 rb            [8086]
LOOPZ imm,ECX                 ; a32 E1 rb            [386]

LOOPNE imm                    ; E0 rb                [8086]
LOOPNE imm,CX                 ; a16 E0 rb            [8086]
LOOPNE imm,ECX                ; a32 E0 rb            [386]
LOOPNZ imm                    ; E0 rb                [8086]
LOOPNZ imm,CX                 ; a16 E0 rb            [8086]
LOOPNZ imm,ECX                ; a32 E0 rb            [386]</screen>

  <para><literal>LOOP</literal> decrements its counter register
   (either &reg.cx; or &reg.ecx;&mdash;if one is not specified
   explicitly, the <literal>BITS</literal> setting dictates which is
   used) by one, and if the counter does not become zero as a result
   of this operation, it jumps to the given label. The jump has a
   range of 128 bytes.</para>

  <para><literal>LOOPE</literal> (or its synonym
   <literal>LOOPZ</literal>) adds the additional condition that it
   only jumps if the counter is nonzero <emphasis>and</emphasis> the
   zero flag is set. Similarly, <literal>LOOPNE</literal> (and
   <literal>LOOPNZ</literal>) jumps only if the counter is nonzero and
   the zero flag is clear.</para>
 </sect1>

 <sect1 id="inst-ref-lsl">
  <title><literal>LSL</literal>: Load Segment Limit</title>

  <indexterm>
   <primary><literal>LSL</literal></primary>
  </indexterm>

  <screen>LSL reg16,r/m16               ; o16 0F 03 /r         [286,PRIV]
LSL reg32,r/m32               ; o32 0F 03 /r         [286,PRIV]</screen>

  <para><literal>LSL</literal> is given a segment selector in its
   source (second) operand; it computes the segment limit value by
   loading the segment limit field from the associated segment
   descriptor in the <literal>GDT</literal> or <literal>LDT</literal>.
   (This involves shifting left by 12 bits if the segment limit is
   page-granular, and not if it is byte-granular; so you end up with a
   byte limit in either case.) The segment limit obtained is then
   loaded into the destination (first) operand.</para>
 </sect1>

 <sect1 id="inst-ref-ltr">
  <title><literal>LTR</literal>: Load Task Register</title>

  <indexterm>
   <primary><literal>LTR</literal></primary>
  </indexterm>

  <screen>LTR r/m16                     ; 0F 00 /3             [286,PRIV]</screen>

  <para><literal>LTR</literal> looks up the segment base and limit in
   the GDT or LDT descriptor specified by the segment selector given
   as its operand, and loads them into the Task Register.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-maskmovdqu">
  <title><literal>MASKMOVDQU</literal>: Byte Mask Write</title>

  <indexterm>
   <primary><literal>MASKMOVDQU</literal></primary>
  </indexterm>

  <screen>MASKMOVDQU xmm1,xmm2          ; 66 0F F7 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MASKMOVDQU</literal> stores data from xmm1 to the
   location specified by <literal>&reg.es;:&reg.edi;</literal> (or
   <literal>&reg.es;:&reg.di;</literal>). The size of the store
   depends on the address-size attribute. The most significant bit in
   each byte of the mask register xmm2 is used to selectively write
   the data (0 = no write, 1 = write) on a per-byte basis.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-maskmovq">
  <title><literal>MASKMOVQ</literal>: Byte Mask Write</title>

  <indexterm>
   <primary><literal>MASKMOVQ</literal></primary>
  </indexterm>

  <screen>MASKMOVQ mm1,mm2              ; 0F F7 /r        [KATMAI,MMX]</screen>

  <para><literal>MASKMOVQ</literal> stores data from mm1 to the
   location specified by <literal>&reg.es;:&reg.edi;</literal> (or
   <literal>&reg.es;:&reg.di;</literal>). The size of the store
   depends on the address-size attribute. The most significant bit in
   each byte of the mask register mm2 is used to selectively write the
   data (0 = no write, 1 = write) on a per-byte basis.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-maxpd">
  <title><literal>MAXPD</literal>: Return Packed Double-Precision FP
   Maximum</title>

  <indexterm>
   <primary><literal>MAXPD</literal></primary>
  </indexterm>

  <screen>MAXPD xmm1,xmm2/m128          ; 66 0F 5F /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MAXPD</literal> performs a SIMD compare of the packed
   double-precision FP numbers from xmm1 and xmm2/mem, and stores the
   maximum values of each pair of values in xmm1. If the values being
   compared are both zeroes, source2 (xmm2/m128) would be returned. If
   source2 (xmm2/m128) is an <literal>SNaN</literal>, this
   <literal>SNaN</literal> is forwarded unchanged to the destination
   (i.e., a <literal>QNaN</literal> version of the
   <literal>SNaN</literal> is not returned).</para>
 </sect1>
]]>
 <sect1 id="inst-ref-maxps">
  <title><literal>MAXPS</literal>: Return Packed Single-Precision FP
   Maximum</title>

  <indexterm>
   <primary><literal>MAXPS</literal></primary>
  </indexterm>

  <screen>MAXPS xmm1,xmm2/m128          ; 0F 5F /r        [KATMAI,SSE]</screen>

  <para><literal>MAXPS</literal> performs a SIMD compare of the packed
   single-precision FP numbers from xmm1 and xmm2/mem, and stores the
   maximum values of each pair of values in xmm1. If the values being
   compared are both zeroes, source2 (xmm2/m128) would be returned. If
   source2 (xmm2/m128) is an <literal>SNaN</literal>, this
   <literal>SNaN</literal> is forwarded unchanged to the destination
   (i.e., a <literal>QNaN</literal> version of the
   <literal>SNaN</literal> is not returned).</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-maxsd">
  <title><literal>MAXSD</literal>: Return Scalar Double-Precision FP
   Maximum</title>

  <indexterm>
   <primary><literal>MAXSD</literal></primary>
  </indexterm>

  <screen>MAXSD xmm1,xmm2/m64           ; F2 0F 5F /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MAXSD</literal> compares the low-order
   double-precision FP numbers from xmm1 and xmm2/mem, and stores the
   maximum value in xmm1. If the values being compared are both
   zeroes, source2 (xmm2/m64) would be returned. If source2 (xmm2/m64)
   is an <literal>SNaN</literal>, this <literal>SNaN</literal> is
   forwarded unchanged to the destination (i.e., a
   <literal>QNaN</literal> version of the <literal>SNaN</literal> is
   not returned). The high quadword of the destination is left
   unchanged.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-maxss">
  <title><literal>MAXSS</literal>: Return Scalar Single-Precision FP
   Maximum</title>

  <indexterm>
   <primary><literal>MAXSS</literal></primary>
  </indexterm>

  <screen>MAXSS xmm1,xmm2/m32           ; F3 0F 5F /r     [KATMAI,SSE]</screen>

  <para><literal>MAXSS</literal> compares the low-order
   single-precision FP numbers from xmm1 and xmm2/mem, and stores the
   maximum value in xmm1. If the values being compared are both
   zeroes, source2 (xmm2/m32) would be returned. If source2 (xmm2/m32)
   is an <literal>SNaN</literal>, this <literal>SNaN</literal> is
   forwarded unchanged to the destination (i.e., a
   <literal>QNaN</literal> version of the <literal>SNaN</literal> is
   not returned). The high three doublewords of the destination are
   left unchanged.</para>
 </sect1>

 <sect1 id="inst-ref-mfence">
  <title><literal>MFENCE</literal>: Memory Fence</title>

  <indexterm>
   <primary><literal>MFENCE</literal></primary>
  </indexterm>

  <screen>MFENCE                        ; 0F AE /6        [WILLAMETTE,SSE2]</screen>

  <para><literal>MFENCE</literal> performs a serializing operation on
   all loads from memory and writes to memory that were issued before
   the <literal>MFENCE</literal> instruction. This guarantees that all
   memory reads and writes before the <literal>MFENCE</literal>
   instruction are completed before any reads and writes after the
   <literal>MFENCE</literal> instruction.</para>

  <para><literal>MFENCE</literal> is ordered respective to other
   <literal>MFENCE</literal> instructions, <literal>LFENCE</literal>,
   <literal>SFENCE</literal>, any memory read and any other
   serializing instruction (such as <literal>CPUID</literal>).</para>

  <para>Weakly ordered memory types can be used to achieve higher
   processor performance through such techniques as out-of-order
   issue, speculative reads, write-combining, and write-collapsing.
   The degree to which a consumer of data recognizes or knows that the
   data is weakly ordered varies among applications and may be unknown
   to the producer of this data. The <literal>MFENCE</literal>
   instruction provides a performance-efficient way of ensuring load
   and store ordering between routines that produce weakly-ordered
   results and routines that consume that data.</para>

  <para><literal>MFENCE</literal> uses the following ModRM
   encoding:</para>

  <screen>           Mod (7:6)        = 11B
           Reg/Opcode (5:3) = 110B
           R/M (2:0)        = 000B</screen>

  <para>All other ModRM encodings are defined to be reserved, and use
   of these encodings risks incompatibility with future
   processors.</para>

  <para>See also <literal>LFENCE</literal> (<xref
    linkend="inst-ref-lfence">) and <literal>SFENCE</literal> (<xref
    linkend="inst-ref-sfence">).</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-minpd">
  <title><literal>MINPD</literal>: Return Packed Double-Precision FP
   Minimum</title>

  <indexterm>
   <primary><literal>MINPD</literal></primary>
  </indexterm>

  <screen>MINPD xmm1,xmm2/m128          ; 66 0F 5D /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MINPD</literal> performs a SIMD compare of the packed
   double-precision FP numbers from xmm1 and xmm2/mem, and stores the
   minimum values of each pair of values in xmm1. If the values being
   compared are both zeroes, source2 (xmm2/m128) would be returned. If
   source2 (xmm2/m128) is an <literal>SNaN</literal>, this
   <literal>SNaN</literal> is forwarded unchanged to the destination
   (i.e., a <literal>QNaN</literal> version of the
   <literal>SNaN</literal> is not returned).</para>
 </sect1>
]]>
 <sect1 id="inst-ref-minps">
  <title><literal>MINPS</literal>: Return Packed Single-Precision FP
   Minimum</title>

  <indexterm>
   <primary><literal>MINPS</literal></primary>
  </indexterm>

  <screen>MINPS xmm1,xmm2/m128          ; 0F 5D /r        [KATMAI,SSE]</screen>

  <para><literal>MINPS</literal> performs a SIMD compare of the packed
   single-precision FP numbers from xmm1 and xmm2/mem, and stores the
   minimum values of each pair of values in xmm1. If the values being
   compared are both zeroes, source2 (xmm2/m128) would be returned. If
   source2 (xmm2/m128) is an <literal>SNaN</literal>, this
   <literal>SNaN</literal> is forwarded unchanged to the destination
   (i.e., a <literal>QNaN</literal> version of the
   <literal>SNaN</literal> is not returned).</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-minsd">
  <title><literal>MINSD</literal>: Return Scalar Double-Precision FP
   Minimum</title>

  <indexterm>
   <primary><literal>MINSD</literal></primary>
  </indexterm>

  <screen>MINSD xmm1,xmm2/m64           ; F2 0F 5D /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MINSD</literal> compares the low-order
   double-precision FP numbers from xmm1 and xmm2/mem, and stores the
   minimum value in xmm1. If the values being compared are both
   zeroes, source2 (xmm2/m64) would be returned. If source2 (xmm2/m64)
   is an <literal>SNaN</literal>, this <literal>SNaN</literal> is
   forwarded unchanged to the destination (i.e., a
   <literal>QNaN</literal> version of the <literal>SNaN</literal> is
   not returned). The high quadword of the destination is left
   unchanged.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-minss">
  <title><literal>MINSS</literal>: Return Scalar Single-Precision FP
   Minimum</title>

  <indexterm>
   <primary><literal>MINSS</literal></primary>
  </indexterm>

  <screen>MINSS xmm1,xmm2/m32           ; F3 0F 5D /r     [KATMAI,SSE]</screen>

  <para><literal>MINSS</literal> compares the low-order
   single-precision FP numbers from xmm1 and xmm2/mem, and stores the
   minimum value in xmm1. If the values being compared are both
   zeroes, source2 (xmm2/m32) would be returned. If source2 (xmm2/m32)
   is an <literal>SNaN</literal>, this <literal>SNaN</literal> is
   forwarded unchanged to the destination (i.e., a
   <literal>QNaN</literal> version of the <literal>SNaN</literal> is
   not returned). The high three doublewords of the destination are
   left unchanged.</para>
 </sect1>

 <sect1 id="inst-ref-mov">
  <title><literal>MOV</literal>: Move Data</title>

  <indexterm>
   <primary><literal>MOV</literal></primary>
  </indexterm>

  <screen>MOV r/m8,reg8                 ; 88 /r                [8086]
MOV r/m16,reg16               ; o16 89 /r            [8086]
MOV r/m32,reg32               ; o32 89 /r            [386]
MOV reg8,r/m8                 ; 8A /r                [8086]
MOV reg16,r/m16               ; o16 8B /r            [8086]
MOV reg32,r/m32               ; o32 8B /r            [386]

MOV reg8,imm8                 ; B0+r ib              [8086]
MOV reg16,imm16               ; o16 B8+r iw          [8086]
MOV reg32,imm32               ; o32 B8+r id          [386]
MOV r/m8,imm8                 ; C6 /0 ib             [8086]
MOV r/m16,imm16               ; o16 C7 /0 iw         [8086]
MOV r/m32,imm32               ; o32 C7 /0 id         [386]

MOV AL,memoffs8               ; A0 ow/od             [8086]
MOV AX,memoffs16              ; o16 A1 ow/od         [8086]
MOV EAX,memoffs32             ; o32 A1 ow/od         [386]
MOV memoffs8,AL               ; A2 ow/od             [8086]
MOV memoffs16,AX              ; o16 A3 ow/od         [8086]
MOV memoffs32,EAX             ; o32 A3 ow/od         [386]

MOV r/m16,segreg              ; o16 8C /r            [8086]
MOV r/m32,segreg              ; o32 8C /r            [386]
MOV segreg,r/m16              ; o16 8E /r            [8086]
MOV segreg,r/m32              ; o32 8E /r            [386]

MOV reg32,CR0/2/3/4           ; 0F 20 /r             [386]
MOV reg32,DR0/1/2/3/6/7       ; 0F 21 /r             [386]
MOV reg32,TR3/4/5/6/7         ; 0F 24 /r             [386]
MOV CR0/2/3/4,reg32           ; 0F 22 /r             [386]
MOV DR0/1/2/3/6/7,reg32       ; 0F 23 /r             [386]
MOV TR3/4/5/6/7,reg32         ; 0F 26 /r             [386]</screen>

  <para><literal>MOV</literal> copies the contents of its source
   (second) operand into its destination (first) operand.</para>

  <para>In all forms of the <literal>MOV</literal> instruction, the
   two operands are the same size, except for moving between a segment
   register and an <literal>r/m32</literal> operand. These
   instructions are treated exactly like the corresponding 16-bit
   equivalent (so that, for example, <literal>MOV DS,EAX</literal>
   functions identically to <literal>MOV DS,AX</literal> but saves a
   prefix when in 32-bit mode), except that when a segment register is
   moved into a 32-bit destination, the top two bytes of the result
   are undefined.</para>

  <para><literal>MOV</literal> may not use &reg.cs; as a
   destination.</para>

  <para>&reg.cr4; is only a supported register on the Pentium and
   above.</para>

  <para>Test registers are supported on 386/486 processors and on some
   non-Intel Pentium class processors.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-movapd">
  <title><literal>MOVAPD</literal>: Move Aligned Packed
   Double-Precision FP Values</title>

  <indexterm>
   <primary><literal>MOVAPD</literal></primary>
  </indexterm>

  <screen>MOVAPD xmm1,xmm2/mem128       ; 66 0F 28 /r     [WILLAMETTE,SSE2]
MOVAPD xmm1/mem128,xmm2       ; 66 0F 29 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MOVAPD</literal> moves a double quadword containing 2
   packed double-precision FP values from the source operand to the
   destination. When the source or destination operand is a memory
   location, it must be aligned on a 16-byte boundary.</para>

  <para>To move data in and out of memory locations that are not known
   to be on 16-byte boundaries, use the <literal>MOVUPD</literal>
   instruction (<xref linkend="inst-ref-movupd">).</para>
 </sect1>
]]>
 <sect1 id="inst-ref-movaps">
  <title><literal>MOVAPS</literal>: Move Aligned Packed
   Single-Precision FP Values</title>

  <indexterm>
   <primary><literal>MOVAPS</literal></primary>
  </indexterm>

  <screen>MOVAPS xmm1,xmm2/mem128       ; 0F 28 /r        [KATMAI,SSE]
MOVAPS xmm1/mem128,xmm2       ; 0F 29 /r        [KATMAI,SSE]</screen>

  <para><literal>MOVAPS</literal> moves a double quadword containing 4
   packed single-precision FP values from the source operand to the
   destination. When the source or destination operand is a memory
   location, it must be aligned on a 16-byte boundary.</para>

  <para>To move data in and out of memory locations that are not known
   to be on 16-byte boundaries, use the <literal>MOVUPS</literal>
   instruction (<xref linkend="inst-ref-movups">).</para>
 </sect1>

 <sect1 id="inst-ref-movd">
  <title><literal>MOVD</literal>: Move Doubleword to/from MMX
   Register</title>

  <indexterm>
   <primary><literal>MOVD</literal></primary>
  </indexterm>

  <screen>MOVD mm,r/m32                 ; 0F 6E /r             [PENT,MMX]
MOVD r/m32,mm                 ; 0F 7E /r             [PENT,MMX]<![%inst-ref.sse2;[
MOVD xmm,r/m32                ; 66 0F 6E /r     [WILLAMETTE,SSE2]
MOVD r/m32,xmm                ; 66 0F 7E /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>MOVD</literal> copies 32 bits from its source
   (second) operand into its destination (first) operand.  The input
   value is zero-extended to fill the destination register<![%inst-ref.sse2;[ when the
   destination is a 64-bit &reg.mmx; register or a 128-bit &reg.xmm;
   register]]>.</para>
 </sect1>
<![%inst-ref.sse2;[
\H{insMOVDQ2Q} \i\c{MOVDQ2Q}: Move Quadword from XMM to MMX register.

\c MOVDQ2Q mm,xmm                ; F2 OF D6 /r     [WILLAMETTE,SSE2]

\c{MOVDQ2Q} moves the low quadword from the source operand to the
destination operand.


\H{insMOVDQA} \i\c{MOVDQA}: Move Aligned Double Quadword

\c MOVDQA xmm1,xmm2/m128         ; 66 OF 6F /r     [WILLAMETTE,SSE2]
\c MOVDQA xmm1/m128,xmm2         ; 66 OF 7F /r     [WILLAMETTE,SSE2]

\c{MOVDQA} moves a double quadword from the source operand to the
destination operand. When the source or destination operand is a
memory location, it must be aligned to a 16-byte boundary.

To move a double quadword to or from unaligned memory locations,
use the \c{MOVDQU} instruction (\k{insMOVDQU}).


\H{insMOVDQU} \i\c{MOVDQU}: Move Unaligned Double Quadword

\c MOVDQU xmm1,xmm2/m128         ; F3 OF 6F /r     [WILLAMETTE,SSE2]
\c MOVDQU xmm1/m128,xmm2         ; F3 OF 7F /r     [WILLAMETTE,SSE2]

\c{MOVDQU} moves a double quadword from the source operand to the
destination operand. When the source or destination operand is a
memory location, the memory may be unaligned.

To move a double quadword to or from known aligned memory locations,
use the \c{MOVDQA} instruction (\k{insMOVDQA}).


\H{insMOVHLPS} \i\c{MOVHLPS}: Move Packed Single-Precision FP High to Low

\c MOVHLPS xmm1,xmm2             ; OF 12 /r        [KATMAI,SSE] 

\c{MOVHLPS} moves the two packed single-precision FP values from the
high quadword of the source register xmm2 to the low quadword of the
destination register, xmm2. The upper quadword of xmm1 is left unchanged.

The operation of this instruction is:

\c    dst[0-63]   := src[64-127],
\c    dst[64-127] remains unchanged.


\H{insMOVHPD} \i\c{MOVHPD}: Move High Packed Double-Precision FP

\c MOVHPD xmm,m64               ; 66 OF 16 /r      [WILLAMETTE,SSE2]
\c MOVHPD m64,xmm               ; 66 OF 17 /r      [WILLAMETTE,SSE2]

\c{MOVHPD} moves a double-precision FP value between the source and
destination operands. One of the operands is a 64-bit memory location,
the other is the high quadword of an \c{XMM} register.

The operation of this instruction is:

\c    mem[0-63]   := xmm[64-127];

or

\c    xmm[0-63]   remains unchanged;
\c    xmm[64-127] := mem[0-63].


\H{insMOVHPS} \i\c{MOVHPS}: Move High Packed Single-Precision FP

\c MOVHPS xmm,m64               ; 0F 16 /r         [KATMAI,SSE]
\c MOVHPS m64,xmm               ; 0F 17 /r         [KATMAI,SSE]

\c{MOVHPS} moves two packed single-precision FP values between the source
and destination operands. One of the operands is a 64-bit memory location,
the other is the high quadword of an \c{XMM} register.

The operation of this instruction is:

\c    mem[0-63]   := xmm[64-127];

or

\c    xmm[0-63]   remains unchanged;
\c    xmm[64-127] := mem[0-63].


\H{insMOVLHPS} \i\c{MOVLHPS}: Move Packed Single-Precision FP Low to High

\c MOVLHPS xmm1,xmm2             ; OF 16 /r         [KATMAI,SSE] 

\c{MOVLHPS} moves the two packed single-precision FP values from the
low quadword of the source register xmm2 to the high quadword of the
destination register, xmm2. The low quadword of xmm1 is left unchanged.

The operation of this instruction is:

\c    dst[0-63]   remains unchanged;
\c    dst[64-127] := src[0-63].

\H{insMOVLPD} \i\c{MOVLPD}: Move Low Packed Double-Precision FP

\c MOVLPD xmm,m64                ; 66 OF 12 /r     [WILLAMETTE,SSE2]
\c MOVLPD m64,xmm                ; 66 OF 13 /r     [WILLAMETTE,SSE2]

\c{MOVLPD} moves a double-precision FP value between the source and
destination operands. One of the operands is a 64-bit memory location,
the other is the low quadword of an \c{XMM} register.

The operation of this instruction is:

\c    mem(0-63)   := xmm(0-63);

or

\c    xmm(0-63)   := mem(0-63);
\c    xmm(64-127) remains unchanged.

\H{insMOVLPS} \i\c{MOVLPS}: Move Low Packed Single-Precision FP

\c MOVLPS xmm,m64                ; OF 12 /r        [KATMAI,SSE] 
\c MOVLPS m64,xmm                ; OF 13 /r        [KATMAI,SSE] 

\c{MOVLPS} moves two packed single-precision FP values between the source
and destination operands. One of the operands is a 64-bit memory location,
the other is the low quadword of an \c{XMM} register.

The operation of this instruction is:

\c    mem(0-63)   := xmm(0-63);

or

\c    xmm(0-63)   := mem(0-63);
\c    xmm(64-127) remains unchanged.


\H{insMOVMSKPD} \i\c{MOVMSKPD}: Extract Packed Double-Precision FP Sign Mask

\c MOVMSKPD reg32,xmm              ; 66 0F 50 /r   [WILLAMETTE,SSE2]

\c{MOVMSKPD} inserts a 2-bit mask in r32, formed of the most significant
bits of each double-precision FP number of the source operand.


\H{insMOVMSKPS} \i\c{MOVMSKPS}: Extract Packed Single-Precision FP Sign Mask

\c MOVMSKPS reg32,xmm              ; 0F 50 /r      [KATMAI,SSE] 

\c{MOVMSKPS} inserts a 4-bit mask in r32, formed of the most significant
bits of each single-precision FP number of the source operand.

\H{insMOVNTDQ} \i\c{MOVNTDQ}: Move Double Quadword Non Temporal

\c MOVNTDQ m128,xmm              ; 66 0F E7 /r     [WILLAMETTE,SSE2]

\c{MOVNTDQ} moves the double quadword from the \c{XMM} source
register to the destination memory location, using a non-temporal
hint. This store instruction minimizes cache pollution.

\H{insMOVNTI} \i\c{MOVNTI}: Move Doubleword Non Temporal

\c MOVNTI m32,reg32              ; 0F C3 /r        [WILLAMETTE,SSE2]

\c{MOVNTI} moves the doubleword in the source register
to the destination memory location, using a non-temporal
hint. This store instruction minimizes cache pollution.

\H{insMOVNTPD} \i\c{MOVNTPD}: Move Aligned Four Packed Single-Precision
FP Values Non Temporal

\H{insMOVNTPS} \i\c{MOVNTPS}: Move Aligned Four Packed Single-Precision
FP Values Non Temporal

\c MOVNTPS m128,xmm              ; 0F 2B /r        [KATMAI,SSE]

\c{MOVNTPS} moves the double quadword from the \c{XMM} source
register to the destination memory location, using a non-temporal
hint. This store instruction minimizes cache pollution. The memory
location must be aligned to a 16-byte boundary.


\H{insMOVNTQ} \i\c{MOVNTQ}: Move Quadword Non Temporal

\c MOVNTQ m64,mm                 ; 0F E7 /r        [KATMAI,MMX]

\c{MOVNTQ} moves the quadword in the \c{MMX} source register
to the destination memory location, using a non-temporal
hint. This store instruction minimizes cache pollution.
]]>
 <sect1 id="inst-ref-movq">
  <title><literal>MOVQ</literal>: Move Quadword to/from Packed Data
   Register</title>

  <indexterm>
   <primary><literal>MOVQ</literal></primary>
  </indexterm>

  <screen>MOVQ mm1,mm2/m64               ; 0F 6F /r             [PENT,MMX]
MOVQ mm1/m64,mm2               ; 0F 7F /r             [PENT,MMX]<![%inst-ref.sse2;[

MOVQ xmm1,xmm2/m64             ; F3 0F 7E /r    [WILLAMETTE,SSE2]
MOVQ xmm1/m64,xmm2             ; 66 0F D6 /r    [WILLAMETTE,SSE2]]]></screen>

  <para><literal>MOVQ</literal> copies 64 bits from its source
   (second) operand into its destination (first) operand.<![%inst-ref.sse2;[  When the
   source is an &reg.xmm; register, the low quadword is moved.  When
   the destination is an &reg.xmm; register, the destination is the
   low quadword, and the high quadword is cleared.]]></para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-movq2dq">
  <title><literal>MOVQ2DQ</literal>: Move Quadword from &reg.mmx; to
   &reg.xmm; Register</title>

  <indexterm>
   <primary><literal>MOVQ2DQ</literal></primary>
  </indexterm>

  <screen>MOVQ2DQ xmm,mm                 ; F3 OF D6 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MOVQ2DQ</literal> moves the quadword from the source
   operand to the low quadword of the destination operand, and clears
   the high quadword.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-movsb">
  <title><literal>MOVSB</literal>, <literal>MOVSW</literal>,
   <literal>MOVSD</literal>: Move String</title>

  <indexterm>
   <primary><literal>MOVSB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>MOVSW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>MOVSD</literal></primary>
  </indexterm>

  <screen>MOVSB                         ; A4                   [8086]
MOVSW                         ; o16 A5               [8086]
MOVSD                         ; o32 A5               [386]</screen>

  <para><literal>MOVSB</literal> copies the byte at
   <literal>[&reg.ds;:&reg.si;]</literal> or
   <literal>[&reg.ds;:&reg.esi;]</literal> to
   <literal>[&reg.es;:&reg.di;]</literal> or
   <literal>[&reg.es;:&reg.edi;]</literal>. It then increments or
   decrements (depending on the direction flag: increments if the flag
   is clear, decrements if it is set) &reg.si; and &reg.di; (or
   &reg.esi; and &reg.edi;).</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The registers used are &reg.si; and &reg.di; if the address
   size is 16 bits, and &reg.esi; and &reg.edi; if it is 32 bits. If
   you need to use an address size not equal to the current
   <literal>BITS</literal> setting, you can use an explicit
   <literal>a16</literal> or <literal>a32</literal> prefix.</para>

  <para>The segment register used to load from
   <literal>[&reg.si;]</literal> or <literal>[&reg.esi;]</literal> can
   be overridden by using a segment register name as a prefix (for
   example, <literal>es movsb</literal>). The use of &reg.es; for the
   store to <literal>[&reg.di;]</literal> or
   <literal>[&reg.edi;]</literal> cannot be overridden.</para>

  <para><literal>MOVSW</literal> and <literal>MOVSD</literal> work in
   the same way, but they copy a word or a doubleword instead of a
   byte, and increment or decrement the addressing registers by 2 or 4
   instead of 1.</para>

  <para>The <literal>REP</literal> prefix may be used to repeat the
   instruction &reg.cx; (or &reg.ecx; - again, the address size
   chooses which) times.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-movsd">
  <title><literal>MOVSD</literal>: Move Scalar Double-Precision FP
   Value</title>

  <indexterm>
   <primary><literal>MOVSD</literal></primary>
  </indexterm>

  <screen>MOVSD xmm1,xmm2/m64           ; F2 0F 10 /r     [WILLAMETTE,SSE2]
MOVSD xmm1/m64,xmm2           ; F2 0F 11 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MOVSD</literal> moves a double-precision FP value
   from the source operand to the destination operand. When the source
   or destination is a register, the low-order FP value is read or
   written.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-movss">
  <title><literal>MOVSS</literal>: Move Scalar Single-Precision FP
   Value</title>

  <indexterm>
   <primary><literal>MOVSS</literal></primary>
  </indexterm>

  <screen>MOVSS xmm1,xmm2/m32           ; F3 0F 10 /r     [KATMAI,SSE]
MOVSS xmm1/m32,xmm2           ; F3 0F 11 /r     [KATMAI,SSE]</screen>

  <para><literal>MOVSS</literal> moves a single-precision FP value
   from the source operand to the destination operand. When the source
   or destination is a register, the low-order FP value is read or
   written.</para>
 </sect1>

 <sect1 id="inst-ref-movsx">
  <title><literal>MOVSX</literal>, <literal>MOVZX</literal>: Move Data
   with Sign or Zero Extend</title>

  <indexterm>
   <primary><literal>MOVSX</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>MOVZX</literal></primary>
  </indexterm>

  <screen>MOVSX reg16,r/m8              ; o16 0F BE /r         [386]
MOVSX reg32,r/m8              ; o32 0F BE /r         [386]
MOVSX reg32,r/m16             ; o32 0F BF /r         [386]

MOVZX reg16,r/m8              ; o16 0F B6 /r         [386]
MOVZX reg32,r/m8              ; o32 0F B6 /r         [386]
MOVZX reg32,r/m16             ; o32 0F B7 /r         [386]</screen>

  <para><literal>MOVSX</literal> sign-extends its source (second)
   operand to the length of its destination (first) operand, and
   copies the result into the destination operand.
   <literal>MOVZX</literal> does the same, but zero-extends rather
   than sign-extending.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-movupd">
  <title><literal>MOVUPD</literal>: Move Unaligned Packed
   Double-Precision FP Values</title>

  <indexterm>
   <primary><literal>MOVUPD</literal></primary>
  </indexterm>

  <screen>MOVUPD xmm1,xmm2/mem128       ; 66 0F 10 /r     [WILLAMETTE,SSE2]
MOVUPD xmm1/mem128,xmm2       ; 66 0F 11 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MOVUPD</literal> moves a double quadword containing 2
   packed double-precision FP values from the source operand to the
   destination. This instruction makes no assumptions about alignment
   of memory operands.</para>

  <para>To move data in and out of memory locations that are known to
   be on 16-byte boundaries, use the <literal>MOVAPD</literal>
   instruction (<xref linkend="inst-ref-movapd">).</para>
 </sect1>
]]>
 <sect1 id="inst-ref-movups">
  <title><literal>MOVUPS</literal>: Move Unaligned Packed
   Single-Precision FP Values</title>

  <indexterm>
   <primary><literal>MOVUPS</literal></primary>
  </indexterm>

  <screen>MOVUPS xmm1,xmm2/mem128       ; 0F 10 /r        [KATMAI,SSE]
MOVUPS xmm1/mem128,xmm2       ; 0F 11 /r        [KATMAI,SSE]</screen>

  <para><literal>MOVUPS</literal> moves a double quadword containing 4
   packed single-precision FP values from the source operand to the
   destination. This instruction makes no assumptions about alignment
   of memory operands.</para>

  <para>To move data in and out of memory locations that are known to
   be on 16-byte boundaries, use the <literal>MOVAPS</literal>
   instruction (<xref linkend="inst-ref-movaps">).</para>
 </sect1>

 <sect1 id="inst-ref-mul">
  <title><literal>MUL</literal>: Unsigned Integer Multiply</title>

  <indexterm>
   <primary><literal>MUL</literal></primary>
  </indexterm>

  <screen>MUL r/m8                      ; F6 /4                [8086]
MUL r/m16                     ; o16 F7 /4            [8086]
MUL r/m32                     ; o32 F7 /4            [386]</screen>

  <para><literal>MUL</literal> performs unsigned integer
   multiplication. The other operand to the multiplication, and the
   destination operand, are implicit, in the following way:</para>

  <itemizedlist>
   <listitem>
    <para>For <literal>MUL r/m8</literal>, &reg.al; is multiplied by
     the given operand; the product is stored in &reg.ax;.</para>
   </listitem>

   <listitem>
    <para>For <literal>MUL r/m16</literal>, &reg.ax; is multiplied by
     the given operand; the product is stored in
     <literal>&reg.dx;:&reg.ax;</literal>.</para>
   </listitem>

   <listitem>
    <para>For <literal>MUL r/m32</literal>, &reg.eax; is multiplied by
     the given operand; the product is stored in
     <literal>&reg.edx;:&reg.eax;</literal>.</para>
   </listitem>
  </itemizedlist>

  <para>Signed integer multiplication is performed by the
   <literal>IMUL</literal> instruction: see <xref
    linkend="inst-ref-imul">.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-mulpd">
  <title><literal>MULPD</literal>: Packed Double-Precision FP
   Multiply</title>

  <indexterm>
   <primary><literal>MULPD</literal></primary>
  </indexterm>

  <screen>MULPD xmm1,xmm2/mem128        ; 66 0F 59 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MULPD</literal> performs a SIMD multiply of the
   packed double-precision FP values in both operands, and stores the
   results in the destination register.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-mulps">
  <title><literal>MULPS</literal>: Packed Single-Precision FP
   Multiply</title>

  <indexterm>
   <primary><literal>MULPS</literal></primary>
  </indexterm>

  <screen>MULPS xmm1,xmm2/mem128        ; 0F 59 /r        [KATMAI,SSE]</screen>

  <para><literal>MULPS</literal> performs a SIMD multiply of the
   packed single-precision FP values in both operands, and stores the
   results in the destination register.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-mulsd">
  <title><literal>MULSD</literal>: Scalar Double-Precision FP
   Multiply</title>

  <indexterm>
   <primary><literal>MULSD</literal></primary>
  </indexterm>

  <screen>MULSD xmm1,xmm2/mem32         ; F2 0F 59 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>MULSD</literal> multiplies the lowest
   double-precision FP values of both operands, and stores the result
   in the low quadword of xmm1.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-mulss">
  <title><literal>MULSS</literal>: Scalar Single-Precision FP
   Multiply</title>

  <indexterm>
   <primary><literal>MULSS</literal></primary>
  </indexterm>

  <screen>MULSS xmm1,xmm2/mem32         ; F3 0F 59 /r     [KATMAI,SSE]</screen>

  <para><literal>MULSS</literal> multiplies the lowest
   single-precision FP values of both operands, and stores the result
   in the low doubleword of xmm1.</para>
 </sect1>

 <sect1 id="inst-ref-neg">
  <title><literal>NEG</literal>, <literal>NOT</literal>: Two's and
   One's Complement</title>

  <indexterm>
   <primary><literal>NEG</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>NOT</literal></primary>
  </indexterm>

  <screen>NEG r/m8                      ; F6 /3                [8086]
NEG r/m16                     ; o16 F7 /3            [8086]
NEG r/m32                     ; o32 F7 /3            [386]

NOT r/m8                      ; F6 /2                [8086]
NOT r/m16                     ; o16 F7 /2            [8086]
NOT r/m32                     ; o32 F7 /2            [386]</screen>

  <para><literal>NEG</literal> replaces the contents of its operand by
   the two's complement negation (invert all the bits and then add
   one) of the original value. <literal>NOT</literal>, similarly,
   performs one's complement (inverts all the bits).</para>
 </sect1>

 <sect1 id="inst-ref-nop">
  <title><literal>NOP</literal>: No Operation</title>

  <indexterm>
   <primary><literal>NOP</literal></primary>
  </indexterm>

  <screen>NOP                           ; 90                   [8086]</screen>

  <para><literal>NOP</literal> performs no operation. Its opcode is
   the same as that generated by <literal>XCHG AX,AX</literal> or
   <literal>XCHG EAX,EAX</literal> (depending on the processor mode;
   see <xref linkend="inst-ref-xchg">).</para>
 </sect1>

 <sect1 id="inst-ref-or">
  <title><literal>OR</literal>: Bitwise OR</title>

  <indexterm>
   <primary><literal>OR</literal></primary>
  </indexterm>

  <screen>OR r/m8,reg8                  ; 08 /r                [8086]
OR r/m16,reg16                ; o16 09 /r            [8086]
OR r/m32,reg32                ; o32 09 /r            [386]

OR reg8,r/m8                  ; 0A /r                [8086]
OR reg16,r/m16                ; o16 0B /r            [8086]
OR reg32,r/m32                ; o32 0B /r            [386]

OR r/m8,imm8                  ; 80 /1 ib             [8086]
OR r/m16,imm16                ; o16 81 /1 iw         [8086]
OR r/m32,imm32                ; o32 81 /1 id         [386]

OR r/m16,imm8                 ; o16 83 /1 ib         [8086]
OR r/m32,imm8                 ; o32 83 /1 ib         [386]

OR AL,imm8                    ; 0C ib                [8086]
OR AX,imm16                   ; o16 0D iw            [8086]
OR EAX,imm32                  ; o32 0D id            [386]</screen>

  <para><literal>OR</literal> performs a bitwise OR operation between
   its two operands (i.e. each bit of the result is 1 if and only if
   at least one of the corresponding bits of the two inputs was 1),
   and stores the result in the destination (first) operand.</para>

  <para>In the forms with an 8-bit immediate second operand and a
   longer first operand, the second operand is considered to be
   signed, and is sign-extended to the length of the first operand. In
   these cases, the <literal>BYTE</literal> qualifier is necessary to
   force NASM to generate this form of the instruction.</para>

  <para>The MMX instruction <literal>POR</literal> (see <xref
    linkend="inst-ref-por">) performs the same operation on the 64-bit
   MMX registers.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-orpd">
  <title><literal>ORPD</literal>: Bit-wise Logical OR of
   Double-Precision FP Data</title>

  <indexterm>
   <primary><literal>ORPD</literal></primary>
  </indexterm>

  <screen>ORPD xmm1,xmm2/m128           ; 66 0F 56 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>ORPD</literal> return a bit-wise logical OR between
   xmm1 and xmm2/mem, and stores the result in xmm1. If the source
   operand is a memory location, it must be aligned to a 16-byte
   boundary.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-orps">
  <title><literal>ORPS</literal>: Bit-wise Logical OR of
   Single-Precision FP Data</title>

  <indexterm>
   <primary><literal>ORPS</literal></primary>
  </indexterm>

  <screen>ORPS xmm1,xmm2/m128           ; 0F 56 /r        [KATMAI,SSE]</screen>

  <para><literal>ORPS</literal> return a bit-wise logical OR between
   xmm1 and xmm2/mem, and stores the result in xmm1. If the source
   operand is a memory location, it must be aligned to a 16-byte
   boundary.</para>
 </sect1>

 <sect1 id="inst-ref-out">
  <title><literal>OUT</literal>: Output Data to I/O Port</title>

  <indexterm>
   <primary><literal>OUT</literal></primary>
  </indexterm>

  <screen>OUT imm8,AL                   ; E6 ib                [8086]
OUT imm8,AX                   ; o16 E7 ib            [8086]
OUT imm8,EAX                  ; o32 E7 ib            [386]
OUT DX,AL                     ; EE                   [8086]
OUT DX,AX                     ; o16 EF               [8086]
OUT DX,EAX                    ; o32 EF               [386]</screen>

  <para><literal>OUT</literal> writes the contents of the given source
   register to the specified I/O port. The port number may be
   specified as an immediate value if it is between 0 and 255, and
   otherwise must be stored in &reg.dx;. See also
   <literal>IN</literal> (<xref linkend="inst-ref-in">).</para>
 </sect1>

 <sect1 id="inst-ref-outsb">
  <title><literal>OUTSB</literal>, <literal>OUTSW</literal>,
   <literal>OUTSD</literal>: Output String to I/O Port</title>

  <indexterm>
   <primary><literal>OUTSB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>OUTSW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>OUTSD</literal></primary>
  </indexterm>

  <screen>OUTSB                         ; 6E                   [186]
OUTSW                         ; o16 6F               [186]
OUTSD                         ; o32 6F               [386]</screen>

  <para><literal>OUTSB</literal> loads a byte from
   <literal>[&reg.ds;:&reg.si;]</literal> or
   <literal>[&reg.ds;:&reg.esi;]</literal> and writes it to the I/O
   port specified in <literal>DX</literal>. It then increments or
   decrements (depending on the direction flag: increments if the flag
   is clear, decrements if it is set) &reg.si; or &reg.esi;.</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The register used is &reg.si; if the address size is 16 bits,
   and &reg.esi; if it is 32 bits. If you need to use an address size
   not equal to the current <literal>BITS</literal> setting, you can
   use an explicit <literal>a16</literal> or <literal>a32</literal>
   prefix.</para>

  <para>The segment register used to load from
   <literal>[&reg.si;]</literal> or <literal>[&reg.esi;]</literal> can
   be overridden by using a segment register name as a prefix (for
   example, <literal>es outsb</literal>).</para>

  <para><literal>OUTSW</literal> and <literal>OUTSD</literal> work in
   the same way, but they output a word or a doubleword instead of a
   byte, and increment or decrement the addressing registers by 2 or 4
   instead of 1.</para>

  <para>The <literal>REP</literal> prefix may be used to repeat the
   instruction &reg.cx; (or &reg.ecx; - again, the address size
   chooses which) times.</para>
 </sect1>

 <sect1 id="inst-ref-packssdw">
  <title><literal>PACKSSDW</literal>, <literal>PACKSSWB</literal>,
   <literal>PACKUSWB</literal>: Pack Data</title>

  <indexterm>
   <primary><literal>PACKSSDW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PACKSSWB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PACKUSWB</literal></primary>
  </indexterm>

  <screen>PACKSSDW mm1,mm2/m64          ; 0F 6B /r             [PENT,MMX]
PACKSSWB mm1,mm2/m64          ; 0F 63 /r             [PENT,MMX]
PACKUSWB mm1,mm2/m64          ; 0F 67 /r             [PENT,MMX]<![%inst-ref.sse2;[

PACKSSDW xmm1,xmm2/m128       ; 66 0F 6B /r     [WILLAMETTE,SSE2]
PACKSSWB xmm1,xmm2/m128       ; 66 0F 63 /r     [WILLAMETTE,SSE2]
PACKUSWB xmm1,xmm2/m128       ; 66 0F 67 /r     [WILLAMETTE,SSE2]]]></screen>

  <para>All these instructions start by combining the source and
   destination operands, and then splitting the result in smaller
   sections which it then packs into the destination register.  The
   two 64-bit operands are packed into one 64-bit register<![%inst-ref.sse2;[ in the
   &reg.mmx; versions, while the &reg.xmm; versions pack two 128-bit
   operands into one 128-bit register]]>.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PACKSSWB</literal> splits the combined value into
     words, and then reduces the words to bytes, using signed
     saturation. It then packs the bytes into the destination register
     in the same order the words were in.</para>
   </listitem>

   <listitem>
    <para><literal>PACKSSDW</literal> performs the same operation as
     <literal>PACKSSWB</literal>, except that it reduces doublewords
     to words, then packs them into the destination register.</para>
   </listitem>

   <listitem>
    <para><literal>PACKUSWB</literal> performs the same operation as
     <literal>PACKSSWB</literal>, except that it uses unsigned
     saturation when reducing the size of the elements.</para>
   </listitem>
  </itemizedlist>

  <para>To perform signed saturation on a number, it is replaced by
   the largest signed number (<literal>7FFFh</literal> or
   <literal>7Fh</literal>) that <emphasis>will</emphasis> fit, and if
   it is too small it is replaced by the smallest signed number
   (<literal>8000h</literal> or <literal>80h</literal>) that will fit.
   To perform unsigned saturation, the input is treated as unsigned,
   and the input is replaced by the largest unsigned number that will
   fit.</para>
</sect1>

 <sect1 id="inst-ref-paddb">
  <title><literal>PADDB</literal>, <literal>PADDW</literal>,
   <literal>PADDD</literal>: Add Packed Integers</title>

  <indexterm>
   <primary><literal>PADDB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PADDW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PADDD</literal></primary>
  </indexterm>

  <screen>PADDB mm1,mm2/m64             ; 0F FC /r             [PENT,MMX]
PADDW mm1,mm2/m64             ; 0F FD /r             [PENT,MMX]
PADDD mm1,mm2/m64             ; 0F FE /r             [PENT,MMX]<![%inst-ref.sse2;[

PADDB xmm1,xmm2/m128          ; 66 0F FC /r     [WILLAMETTE,SSE2]
PADDW xmm1,xmm2/m128          ; 66 0F FD /r     [WILLAMETTE,SSE2]
PADDD xmm1,xmm2/m128          ; 66 0F FE /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PADDx</literal> performs packed addition of the two
   operands, storing the result in the destination (first)
   operand.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PADDB</literal> treats the operands as packed
     bytes, and adds each byte individually;</para>
   </listitem>

   <listitem>
    <para><literal>PADDW</literal> treats the operands as packed
     words;</para>
   </listitem>

   <listitem>
    <para><literal>PADDD</literal> treats its operands as packed
     doublewords.</para>
   </listitem>
  </itemizedlist>

  <para>When an individual result is too large to fit in its
   destination, it is wrapped around and the low bits are stored, with
   the carry bit discarded.</para>
 </sect1>

 <sect1 id="inst-ref-paddq">
  <title><literal>PADDQ</literal>: Add Packed Quadword
   Integers</title>

  <indexterm>
   <primary><literal>PADDQ</literal></primary>
  </indexterm>

  <screen>PADDQ mm1,mm2/m64             ; 0F D4 /r             [PENT,MMX]<![%inst-ref.sse2;[

PADDQ xmm1,xmm2/m128          ; 66 0F D4 /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PADDQ</literal> adds the quadwords in the source and
   destination operands, and stores the result in the destination
   register.</para>

  <para>When an individual result is too large to fit in its
   destination, it is wrapped around and the low bits are stored, with
   the carry bit discarded.</para>
 </sect1>

 <sect1 id="inst-ref-paddsb">
  <title><literal>PADDSB</literal>, <literal>PADDSW</literal>: Add
   Packed Signed Integers with Saturation</title>

  <indexterm>
   <primary><literal>PADDSB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PADDSW</literal></primary>
  </indexterm>

  <screen>PADDSB mm1,mm2/m64            ; 0F EC /r             [PENT,MMX]
PADDSW mm1,mm2/m64            ; 0F ED /r             [PENT,MMX]<![%inst-ref.sse2;[

PADDSB xmm1,xmm2/m128         ; 66 0F EC /r     [WILLAMETTE,SSE2]
PADDSW xmm1,xmm2/m128         ; 66 0F ED /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PADDSx</literal> performs packed addition of the two
   operands, storing the result in the destination (first) operand.
   <literal>PADDSB</literal> treats the operands as packed bytes, and
   adds each byte individually; and <literal>PADDSW</literal> treats
   the operands as packed words.</para>

   <para>When an individual result is too large to fit in its
   destination, a saturated value is stored. The resulting value is
   the value with the largest magnitude of the same sign as the result
   which will fit in the available space.</para>
 </sect1>

 <sect1 id="inst-ref-paddusb">
  <title><literal>PADDUSB</literal>, <literal>PADDUSW</literal>: Add
   Packed Unsigned Integers with Saturation</title>

  <indexterm>
   <primary><literal>PADDUSB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PADDUSW</literal></primary>
  </indexterm>

  <screen>PADDUSB mm1,mm2/m64           ; 0F DC /r             [PENT,MMX]
PADDUSW mm1,mm2/m64           ; 0F DD /r             [PENT,MMX]<![%inst-ref.sse2;[

PADDUSB xmm1,xmm2/m128         ; 66 0F DC /r    [WILLAMETTE,SSE2]
PADDUSW xmm1,xmm2/m128         ; 66 0F DD /r    [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PADDUSx</literal> performs packed addition of the two
   operands, storing the result in the destination (first) operand.
   <literal>PADDUSB</literal> treats the operands as packed bytes, and
   adds each byte individually; and <literal>PADDUSW</literal> treats
   the operands as packed words.</para>

  <para>When an individual result is too large to fit in its
   destination, a saturated value is stored. The resulting value is
   the maximum value that will fit in the available space.</para>
 </sect1>

 <sect1 id="inst-ref-pand">
  <title><literal>PAND</literal>, <literal>PANDN</literal>: Packed
   Integer Bitwise AND and AND-NOT</title>

  <indexterm>
   <primary><literal>PAND</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PANDN</literal></primary>
  </indexterm>

  <screen>PAND mm1,mm2/m64              ; 0F DB /r             [PENT,MMX]
PANDN mm1,mm2/m64             ; 0F DF /r             [PENT,MMX]<![%inst-ref.sse2;[

PAND xmm1,xmm2/m128           ; 66 0F DB /r     [WILLAMETTE,SSE2]
PANDN xmm1,xmm2/m128          ; 66 0F DF /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PAND</literal> performs a bitwise AND operation
   between its two operands (i.e. each bit of the result is 1 if and
   only if the corresponding bits of the two inputs were both 1), and
   stores the result in the destination (first) operand.</para>

  <para><literal>PANDN</literal> performs the same operation, but
   performs a one's complement operation on the destination (first)
   operand first.</para>
 </sect1>

 <sect1 id="inst-ref-pause">
  <title><literal>PAUSE</literal>: Spin Loop Hint</title>

  <indexterm>
   <primary><literal>PAUSE</literal></primary>
  </indexterm>

  <screen>PAUSE                         ; F3 90           [WILLAMETTE,SSE2]</screen>

  <para><literal>PAUSE</literal> provides a hint to the processor that
   the following code is a spin loop. This improves processor
   performance by bypassing possible memory order violations. On older
   processors, this instruction operates as a
   <literal>NOP</literal>.</para>
 </sect1>

 <sect1 id="inst-ref-pavgb">
  <title><literal>PAVGB</literal>, <literal>PAVGW</literal>: Average
   Packed Integers</title>

  <indexterm>
   <primary><literal>PAVGB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PAVGW</literal></primary>
  </indexterm>

  <screen>PAVGB mm1,mm2/m64             ; 0F E0 /r        [KATMAI,MMX] 
PAVGW mm1,mm2/m64             ; 0F E3 /r        [KATMAI,MMX,SM]<![%inst-ref.sse2;[

PAVGB xmm1,xmm2/m128          ; 66 0F E0 /r     [WILLAMETTE,SSE2]
PAVGW xmm1,xmm2/m128          ; 66 0F E3 /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PAVGB</literal> and <literal>PAVGW</literal> add the
   unsigned data elements of the source operand to the unsigned data
   elements of the destination register, then adds 1 to the temporary
   results. The results of the add are then each independently
   right-shifted by one bit position. The high order bits of each
   element are filled with the carry bits of the corresponding
   sum.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PAVGB</literal> operates on packed unsigned
     bytes.</para>
   </listitem>
 
   <listitem>
    <para><literal>PAVGW</literal> operates on packed unsigned
     words.</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-pcmpeqb">
  <title><literal>PCMPxx</literal>: Compare Packed Integers</title>

  <indexterm>
   <primary><literal>PCMPxx</literal></primary>
  </indexterm>

  <screen>PCMPEQB mm1,mm2/m64           ; 0F 74 /r             [PENT,MMX]
PCMPEQW mm1,mm2/m64           ; 0F 75 /r             [PENT,MMX]
PCMPEQD mm1,mm2/m64           ; 0F 76 /r             [PENT,MMX]

PCMPGTB mm1,mm2/m64           ; 0F 64 /r             [PENT,MMX]
PCMPGTW mm1,mm2/m64           ; 0F 65 /r             [PENT,MMX]
PCMPGTD mm1,mm2/m64           ; 0F 66 /r             [PENT,MMX]<![%inst-ref.sse2;[

PCMPEQB xmm1,xmm2/m128        ; 66 0F 74 /r     [WILLAMETTE,SSE2]
PCMPEQW xmm1,xmm2/m128        ; 66 0F 75 /r     [WILLAMETTE,SSE2]
PCMPEQD xmm1,xmm2/m128        ; 66 0F 76 /r     [WILLAMETTE,SSE2]

PCMPGTB xmm1,xmm2/m128        ; 66 0F 64 /r     [WILLAMETTE,SSE2]
PCMPGTW xmm1,xmm2/m128        ; 66 0F 65 /r     [WILLAMETTE,SSE2]
PCMPGTD xmm1,xmm2/m128        ; 66 0F 66 /r     [WILLAMETTE,SSE2]]]></screen>

  <para>The <literal>PCMPxx</literal> instructions all treat their
   operands as vectors of bytes, words, or doublewords; corresponding
   elements of the source and destination are compared, and the
   corresponding element of the destination (first) operand is set to
   all zeros or all ones depending on the result of the
   comparison.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PCMPxxB</literal> treats the operands as vectors of
     bytes.</para>
   </listitem>

   <listitem>
    <para><literal>PCMPxxW</literal> treats the operands as vectors of
     words.</para>
   </listitem>

   <listitem>
    <para><literal>PCMPxxD</literal> treats the operands as vectors of
     doublewords.</para>
   </listitem>

   <listitem>
    <para><literal>PCMPEQx</literal> sets the corresponding element of
     the destination operand to all ones if the two elements compared
     are equal.</para>
   </listitem>

   <listitem>
    <para><literal>PCMPGTx</literal> sets the destination element to
     all ones if the element of the first (destination) operand is
     greater (treated as a signed integer) than that of the second
     (source) operand.</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-pextrw">
  <title><literal>PEXTRW</literal>: Extract Word</title>

  <indexterm>
   <primary><literal>PEXTRW</literal></primary>
  </indexterm>

  <screen>PEXTRW reg32,mm,imm8          ; 0F C5 /r ib     [KATMAI,MMX]<![%inst-ref.sse2;[
PEXTRW reg32,xmm,imm8         ; 66 0F C5 /r ib  [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PEXTRW</literal> moves the word in the source
   register (second operand) that is pointed to by the count operand
   (third operand), into the lower half of a 32-bit general purpose
   register. The upper half of the register is cleared to all
   0s.</para>

  <para>The two least significant bits of the count specify the source
   word<![%inst-ref.sse2;[ when the source operand is an &reg.mmx; register.  When it is
   an &reg.xmm; register, the three least significant bits specify the
   word location]]>.</para>
 </sect1>

 <sect1 id="inst-ref-pinsrw">
  <title><literal>PINSRW</literal>: Insert Word</title>

  <indexterm>
   <primary><literal>PINSRW</literal></primary>
  </indexterm>

  <screen>PINSRW mm,r16/r32/m16,imm8    ;0F C4 /r ib      [KATMAI,MMX]<![%inst-ref.sse2;[
PINSRW xmm,r16/r32/m16,imm8   ;66 0F C4 /r ib   [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PINSRW</literal> loads a word from a 16-bit register
   (or the low half of a 32-bit register), or from memory, and loads
   it to the word position in the destination register, pointed at by
   the count operand (third operand).  The low two bits of the count
   byte are used<![%inst-ref.sse2;[ if the destination is an &reg.mmx; register; if the
   destination is an &reg.xmm; register, the low 3 bits are used]]>. The
   insertion is done in such a way that the other words from the
   destination register are left untouched.</para>
 </sect1>

 <sect1 id="inst-ref-pmaddwd">
  <title><literal>PMADDWD</literal>: Packed Integer Multiply and
   Add</title>

  <indexterm>
   <primary><literal>PMADDWD</literal></primary>
  </indexterm>

  <screen>PMADDWD mm1,mm2/m64           ; 0F F5 /r             [PENT,MMX],<![%inst-ref.sse2;[
PMADDWD xmm1,xmm2/m128        ; 66 0F F5 /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PMADDWD</literal> treats its two inputs as vectors of
   signed words. It multiplies corresponding elements of the two
   operands, giving doubleword results. These are then added together
   in pairs and stored in the destination operand.</para>

  <para>The operation of this instruction is:</para>

  <screen>   dst[0-31]   := (dst[0-15] * src[0-15])
                               + (dst[16-31] * src[16-31]);
   dst[32-63]  := (dst[32-47] * src[32-47])
                               + (dst[48-63] * src[48-63]);</screen>
<![%inst-ref.sse2;[
  <para>The following apply to the &reg.xmm; version of the
   instruction:</para>

  <screen>   dst[64-95]  := (dst[64-79] * src[64-79])
                               + (dst[80-95] * src[80-95]);
   dst[96-127] := (dst[96-111] * src[96-111])
                               + (dst[112-127] * src[112-127]).</screen>
]]>
 </sect1>

 <sect1 id="inst-ref-pmaxsw">
  <title><literal>PMAXSW</literal>: Packed Signed Integer Word
   Maximum</title>

  <indexterm>
   <primary><literal>PMAXSW</literal></primary>
  </indexterm>

  <screen>PMAXSW mm1,mm2/m64            ; 0F EE /r        [KATMAI,MMX]<![%inst-ref.sse2;[
PMAXSW xmm1,xmm2/m128         ; 66 0F EE /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PMAXSW</literal> compares each pair of words in the
   two source operands, and for each pair it stores the maximum value
   in the destination register.</para>
 </sect1>

 <sect1 id="inst-ref-pmaxub">
  <title><literal>PMAXUB</literal>: Packed Unsigned Integer Byte
   Maximum</title>

  <indexterm>
   <primary><literal>PMAXUB</literal></primary>
  </indexterm>

  <screen>PMAXUB mm1,mm2/m64            ; 0F DE /r        [KATMAI,MMX]<![%inst-ref.sse2;[
PMAXUB xmm1,xmm2/m128         ; 66 0F DE /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PMAXUB</literal> compares each pair of bytes in the
   two source operands, and for each pair it stores the maximum value
   in the destination register.</para>
 </sect1>


 <sect1 id="inst-ref-pminsw">
  <title><literal>PMINSW</literal>: Packed Signed Integer Word
   Minimum</title>

  <indexterm>
   <primary><literal>PMINSW</literal></primary>
  </indexterm>

  <screen>PMINSW mm1,mm2/m64            ; 0F EA /r        [KATMAI,MMX]<![%inst-ref.sse2;[
PMINSW xmm1,xmm2/m128         ; 66 0F EA /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PMINSW</literal> compares each pair of words in the
   two source operands, and for each pair it stores the minimum value
   in the destination register.</para>
 </sect1>

 <sect1 id="inst-ref-pminub">
  <title><literal>PMINUB</literal>: Packed Unsigned Integer Byte
   Minimum</title>

  <indexterm>
   <primary><literal>PMINUB</literal></primary>
  </indexterm>

  <screen>PMINUB mm1,mm2/m64            ; 0F DA /r        [KATMAI,MMX]<![%inst-ref.sse2;[
PMINUB xmm1,xmm2/m128         ; 66 0F DA /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PMINUB</literal> compares each pair of bytes in the
   two source operands, and for each pair it stores the minimum value
   in the destination register.</para>
 </sect1>

 <sect1 id="inst-ref-pmovmskb">
  <title><literal>PMOVMSKB</literal>: Move Byte Mask To
   Integer</title>

  <indexterm>
   <primary><literal>PMOVMSKB</literal></primary>
  </indexterm>

  <screen>PMOVMSKB reg32,mm             ; 0F D7 /r        [KATMAI,MMX]<![%inst-ref.sse2;[
PMOVMSKB reg32,xmm            ; 66 0F D7 /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PMOVMSKB</literal> returns an 8-bit <![%inst-ref.sse2;[or 16-bit ]]>mask
   formed of the most significant bits of each byte of the source operand<![%inst-ref.sse2;[
   (8-bits for an &reg.mmx; register, 16-bits for an &reg.xmm;
   register)]]>.</para>
 </sect1>

 <sect1 id="inst-ref-pmulhuw">
  <title><literal>PMULHUW</literal>: Multiply Packed 16-bit Integers,
   and Store High Word</title>

  <indexterm>
   <primary><literal>PMULHUW</literal></primary>
  </indexterm>

  <screen>PMULHUW mm1,mm2/m64           ; 0F E4 /r        [KATMAI,MMX]<![%inst-ref.sse2;[
PMULHUW xmm1,xmm2/m128        ; 66 0F E4 /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PMULHUW</literal> takes two packed unsigned 16-bit
   integer inputs, multiplies the values in the inputs, then stores
   bits 16-31 of each result to the corresponding position of the
   destination register.</para>
 </sect1>

 <sect1 id="inst-ref-pmulhw">
  <title><literal>PMULHW</literal>, <literal>PMULLW</literal>:
   Multiply Packed 16-bit Integers and Store</title>

  <indexterm>
   <primary><literal>PMULHW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PMULLW</literal></primary>
  </indexterm>

  <screen>PMULHW mm1,mm2/m64            ; 0F E5 /r             [PENT,MMX]
PMULLW mm1,mm2/m64            ; 0F D5 /r             [PENT,MMX]<![%inst-ref.sse2;[
PMULHW xmm1,xmm2/m128         ; 66 0F E5 /r     [WILLAMETTE,SSE2]
PMULLW xmm1,xmm2/m128         ; 66 0F D5 /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PMULxW</literal> takes two packed unsigned 16-bit
   integer inputs, and multiplies the values in the inputs, forming
   doubleword results.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PMULHW</literal> then stores the top 16 bits of
     each doubleword in the destination (first) operand;</para>
   </listitem>

   <listitem>
    <para><literal>PMULLW</literal> stores the bottom 16 bits of each
     doubleword in the destination operand.</para>
   </listitem>
  </itemizedlist>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-pmuludq">
  <title><literal>PMULUDQ</literal>: Multiply Packed Unsigned 32-bit
   Integers, and Store.</title>

  <indexterm>
   <primary><literal>PMULUDQ</literal></primary>
  </indexterm>

  <screen>PMULUDQ mm1,mm2/m64           ; 0F F4 /r        [WILLAMETTE,SSE2]
PMULUDQ xmm1,xmm2/m128        ; 66 0F F4 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>PMULUDQ</literal> takes two packed unsigned 32-bit
   integer inputs, and multiplies the values in the inputs, forming
   quadword results. The source is either an unsigned doubleword in
   the low doubleword of a 64-bit operand, or it's two unsigned
   doublewords in the first and third doublewords of a 128-bit
   operand. This produces either one or two 64-bit results, which are
   stored in the respective quadword locations of the destination
   register.</para>

  <para>The operation is:</para>

  <screen>   dst[0-63]   := dst[0-31]  * src[0-31];
   dst[64-127] := dst[64-95] * src[64-95].</screen>
 </sect1>
]]>
 <sect1 id="inst-ref-pop">
  <title><literal>POP</literal>: Pop Data from Stack</title>

  <indexterm>
   <primary><literal>POP</literal></primary>
  </indexterm>

  <screen>POP reg16                     ; o16 58+r             [8086]
POP reg32                     ; o32 58+r             [386]

POP r/m16                     ; o16 8F /0            [8086]
POP r/m32                     ; o32 8F /0            [386]

<![%inst-ref.undoc;[POP CS                        ; 0F               [8086,UNDOC]]]>
POP DS                        ; 1F                   [8086]
POP ES                        ; 07                   [8086]
POP SS                        ; 17                   [8086]
POP FS                        ; 0F A1                [386]
POP GS                        ; 0F A9                [386]</screen>

  <para><literal>POP</literal> loads a value from the stack (from
   <literal>[&reg.ss;:&reg.sp;]</literal> or
   <literal>[&reg.ss;:&reg.esp;]</literal>) and then increments the
   stack pointer.</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The address-size attribute of the instruction determines
   whether &reg.sp; or &reg.esp; is used as the stack pointer: to
   deliberately override the default given by the
   <literal>BITS</literal> setting, you can use an
   <literal>a16</literal> or <literal>a32</literal> prefix.</para>

  <indexterm>
   <primary><literal>o16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>o32</literal></primary>
  </indexterm>

  <para>The operand-size attribute of the instruction determines
   whether the stack pointer is incremented by 2 or 4: this means that
   segment register pops in <literal>BITS 32</literal> mode will pop 4
   bytes off the stack and discard the upper two of them. If you need
   to override that, you can use an <literal>o16</literal> or
   <literal>o32</literal> prefix.</para>

  <para>The above opcode listings give two forms for general-purpose
   register pop instructions: for example, <literal>POP BX</literal>
   has the two forms <literal>5B</literal> and <literal>8F
    C3</literal>. NASM will always generate the shorter form when
   given <literal>POP BX</literal>.</para>

<![%inst-ref.undoc;[
  <para><literal>POP CS</literal> is not a documented instruction, and
   is not supported on any processor above the 8086 (since they use
   <literal>0Fh</literal> as an opcode prefix for instruction set
   extensions). However, at least some 8086 processors do support it,
   and so NASM generates it for completeness.</para>
]]>
 </sect1>

 <sect1 id="inst-ref-popa">
  <title><literal>POPAx</literal>: Pop All General-Purpose
   Registers</title>

  <indexterm>
   <primary><literal>POPAx</literal></primary>
  </indexterm>

  <screen>POPA                          ; 61                   [186]
POPAW                         ; o16 61               [186]
POPAD                         ; o32 61               [386]</screen>

  <itemizedlist>
   <listitem>
    <para><literal>POPAW</literal> pops a word from the stack into
     each of, successively, &reg.di;, &reg.si;, &reg.bp;, nothing (it
     discards a word from the stack which was a placeholder for
     &reg.sp;), &reg.bx;, &reg.dx;, &reg.cx; and &reg.ax;. It is
     intended to reverse the operation of <literal>PUSHAW</literal>
     (see <xref linkend="inst-ref-pusha">), but it ignores the value
     for &reg.sp; that was pushed on the stack by
     <literal>PUSHAW</literal>.</para>
   </listitem>

   <listitem>
    <para><literal>POPAD</literal> pops twice as much data, and places
     the results in &reg.edi;, &reg.esi;, &reg.ebp;, nothing
     (placeholder for &reg.esp;), &reg.ebx;, &reg.edx;, &reg.ecx; and
     &reg.eax;. It reverses the operation of
     <literal>PUSHAD</literal>.</para>
   </listitem>
  </itemizedlist>

  <para><literal>POPA</literal> is an alias mnemonic for either
   <literal>POPAW</literal> or <literal>POPAD</literal>, depending on
   the current <literal>BITS</literal> setting.</para>

  <para>Note that the registers are popped in reverse order of their
   numeric values in opcodes (see <xref
    linkend="inst-ref-opcode-desc-reg-values">).</para>
 </sect1>

 <sect1 id="inst-ref-popf">
  <title><literal>POPFx</literal>: Pop Flags Register</title>

  <indexterm>
   <primary><literal>POPFx</literal></primary>
  </indexterm>

  <screen>POPF                          ; 9D                   [8086]
POPFW                         ; o16 9D               [8086]
POPFD                         ; o32 9D               [386]</screen>

  <itemizedlist>
   <listitem>
    <para><literal>POPFW</literal> pops a word from the stack and
     stores it in the bottom 16 bits of the flags register (or the
     whole flags register, on processors below a 386).
     <literal>POPFD</literal> pops a doubleword and stores it in the
     entire flags register.</para>
   </listitem>

   <listitem>
    <para><literal>POPF</literal> is an alias mnemonic for either
     <literal>POPFW</literal> or <literal>POPFD</literal>, depending
     on the current <literal>BITS</literal> setting.</para>
   </listitem>
  </itemizedlist>

  <para>See also <literal>PUSHF</literal> (<xref
    linkend="inst-ref-pushf">).</para>
 </sect1>

 <sect1 id="inst-ref-por">
  <title><literal>POR</literal>: Packed Data Bitwise OR</title>

  <indexterm>
   <primary><literal>POR</literal></primary>
  </indexterm>

  <screen>POR mm1,mm2/m64               ; 0F EB /r             [PENT,MMX]<![%inst-ref.sse2;[
POR xmm1,xmm2/m128            ; 66 0F EB /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>POR</literal> performs a bitwise OR operation between
   its two operands (i.e. each bit of the result is 1 if and only if
   at least one of the corresponding bits of the two inputs was 1),
   and stores the result in the destination (first) operand.</para>
 </sect1>

 <sect1 id="inst-ref-prefetchh">
  <title><literal>PREFETCHh</literal>: Prefetch Data Into
   Caches</title>

  <indexterm>
   <primary><literal>PREFETCHh</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PREFETCHNTA</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PREFETCHT0</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PREFETCHT1</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PREFETCHT2</literal></primary>
  </indexterm>

  <screen>PREFETCHNTA m8                ; 0F 18 /0        [KATMAI]
PREFETCHT0 m8                 ; 0F 18 /1        [KATMAI]
PREFETCHT1 m8                 ; 0F 18 /2        [KATMAI]
PREFETCHT2 m8                 ; 0F 18 /3        [KATMAI]</screen>

  <para>The <literal>PREFETCHh</literal> instructions fetch the line
   of data from memory that contains the specified byte. It is placed
   in the cache according to rules specified by locality hints
   \c{h}:</para>

  <para>The hints are:</para>
  <itemizedlist>
   <listitem>
    <para><literal>T0</literal> (temporal data) &ndash; prefetch data
     into all levels of the cache hierarchy.</para>
   </listitem>

   <listitem>
    <para><literal>T1</literal> (temporal data with respect to first
     level cache) &ndash; prefetch data into level 2 cache and
     higher.</para>
   </listitem>

   <listitem>
    <para><literal>T2</literal> (temporal data with respect to second
     level cache) &ndash; prefetch data into level 2 cache and
     higher.</para>
   </listitem>

   <listitem>
    <para><literal>NTA</literal> (non-temporal data with respect to
     all cache levels) &ndash; prefetch data into non-temporal cache
     structure and into a location close to the processor, minimizing
     cache pollution.</para>
   </listitem>
  </itemizedlist>

  <para>Note that this group of instructions doesn't provide a
   guarantee that the data will be in the cache when it is needed. For
   more details, see the Intel IA32 Software Developer Manual, Volume
   2.</para>
 </sect1>

 <sect1 id="inst-ref-psadbw">
  <title><literal>PSADBW</literal>: Packed Sum of Absolute
   Differences</title>

  <indexterm>
   <primary><literal>PSADBW</literal></primary>
  </indexterm>

  <screen>PSADBW mm1,mm2/m64            ; 0F F6 /r        [KATMAI,MMX]<![%inst-ref.sse2;[
PSADBW xmm1,xmm2/m128         ; 66 0F F6 /r     [WILLAMETTE,SSE2]]]></screen>

  <para>The <literal>PSADBW</literal> instruction computes the
   absolute value of the difference of the packed unsigned bytes in
   the two source operands.  These differences are then summed to
   produce a word result in the lower 16-bit field of the destination
   register; the rest of the register is cleared.  The destination
   operand is an &reg.mmx; <![%inst-ref.sse2;[or an &reg.xmm; ]]>register.  The source
   operand can either be a register or a memory operand.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-pshufd">
  <title><literal>PSHUFD</literal>: Shuffle Packed Doublewords</title>

  <indexterm>
   <primary><literal>PSHUFD</literal></primary>
  </indexterm>

  <screen>PSHUFD xmm1,xmm2/m128,imm8    ; 66 0F 70 /r ib  [WILLAMETTE,SSE2]</screen>

  <para><literal>PSHUFD</literal> shuffles the doublewords in the
   source (second) operand according to the encoding specified by
   imm8, and stores the result in the destination (first)
   operand.</para>

  <para>Bits 0 and 1 of imm8 encode the source position of the
   doubleword to be copied to position 0 in the destination operand.
   Bits 2 and 3 encode for position 1, bits 4 and 5 encode for
   position 2, and bits 6 and 7 encode for position 3. For example, an
   encoding of 10 in bits 0 and 1 of imm8 indicates that the
   doubleword at bits 64-95 of the source operand will be copied to
   bits 0-31 of the destination.</para>
 </sect1>

 <sect1 id="inst-ref-pshufhw">
  <title><literal>PSHUFHW</literal>: Shuffle Packed High Words</title>

  <indexterm>
   <primary><literal>PSHUFHW</literal></primary>
  </indexterm>

  <screen>PSHUFHW xmm1,xmm2/m128,imm8   ; F3 0F 70 /r ib  [WILLAMETTE,SSE2]</screen>

  <para><literal>PSHUFHW</literal> shuffles the words in the high
   quadword of the source (second) operand according to the encoding
   specified by imm8, and stores the result in the high quadword of
   the destination (first) operand.</para>

  <para>The operation of this instruction is similar to the
   <literal>PSHUFW</literal> instruction, except that the source and
   destination are the high quadword of a 128-bit operand, instead of
   being 64-bit operands.  The low quadword is copied from the source
   to the destination without any changes.</para>
 </sect1>

 <sect1 id="inst-ref-pshuflw">
  <title><literal>PSHUFLW</literal>: Shuffle Packed Low Words</title>

  <indexterm>
   <primary><literal>PSHUFLW</literal></primary>
  </indexterm>

  <screen>PSHUFLW xmm1,xmm2/m128,imm8   ; F2 0F 70 /r ib  [WILLAMETTE,SSE2]</screen>

  <para><literal>PSHUFLW</literal> shuffles the words in the low
   quadword of the source (second) operand according to the encoding
   specified by imm8, and stores the result in the low quadword of the
   destination (first) operand.</para>

  <para>The operation of this instruction is similar to the
   <literal>PSHUFW</literal> instruction, except that the source and
   destination are the low quadword of a 128-bit operand, instead of
   being 64-bit operands.  The high quadword is copied from the source
   to the destination without any changes.</para>
 </sect1>
]]>

 <sect1 id="inst-ref-pshufw">
  <title><literal>PSHUFW</literal>: Shuffle Packed Words</title>

  <indexterm>
   <primary><literal>PSHUFW</literal></primary>
  </indexterm>

  <screen>PSHUFW mm1,mm2/m64,imm8       ; 0F 70 /r ib     [KATMAI,MMX]</screen>

  <para><literal>PSHUFW</literal> shuffles the words in the source
   (second) operand according to the encoding specified by imm8, and
   stores the result in the destination (first) operand.</para>

  <para>Bits 0 and 1 of imm8 encode the source position of the word to
   be copied to position 0 in the destination operand. Bits 2 and 3
   encode for position 1, bits 4 and 5 encode for position 2, and bits
   6 and 7 encode for position 3. For example, an encoding of 10 in
   bits 0 and 1 of imm8 indicates that the word at bits 32-47 of the
   source operand will be copied to bits 0-15 of the
   destination.</para>
 </sect1>

 <sect1 id="inst-ref-psllx">
  <title><literal>PSLLx</literal>: Packed Data Bit Shift Left
   Logical</title>

  <indexterm>
   <primary><literal>PSLLx</literal></primary>
  </indexterm>

  <screen>PSLLW mm1,mm2/m64             ; 0F F1 /r             [PENT,MMX]
PSLLW mm,imm8                 ; 0F 71 /6 ib          [PENT,MMX]<![%inst-ref.sse2;[
 
PSLLW xmm1,xmm2/m128          ; 66 0F F1 /r     [WILLAMETTE,SSE2]
PSLLW xmm,imm8                ; 66 0F 71 /6 ib  [WILLAMETTE,SSE2]]]>
 
PSLLD mm1,mm2/m64             ; 0F F2 /r             [PENT,MMX]
PSLLD mm,imm8                 ; 0F 72 /6 ib          [PENT,MMX]<![%inst-ref.sse2;[
 
PSLLD xmm1,xmm2/m128          ; 66 0F F2 /r     [WILLAMETTE,SSE2]
PSLLD xmm,imm8                ; 66 0F 72 /6 ib  [WILLAMETTE,SSE2]]]>

PSLLQ mm1,mm2/m64             ; 0F F3 /r             [PENT,MMX]
PSLLQ mm,imm8                 ; 0F 73 /6 ib          [PENT,MMX]<![%inst-ref.sse2;[
 
PSLLQ xmm1,xmm2/m128          ; 66 0F F3 /r     [WILLAMETTE,SSE2]
PSLLQ xmm,imm8                ; 66 0F 73 /6 ib  [WILLAMETTE,SSE2]

PSLLDQ xmm1,imm8              ; 66 0F 73 /7 ib  [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PSLLx</literal> performs logical left shifts of the
   data elements in the destination (first) operand, moving each bit
   in the separate elements left by the number of bits specified in
   the source (second) operand, clearing the low-order bits as they
   are vacated.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PSLLW</literal> shifts word sized elements.</para>
   </listitem> 

   <listitem>
    <para><literal>PSLLD</literal> shifts doubleword sized
     elements.</para>
   </listitem>

   <listitem>
    <para><literal>PSLLQ</literal> shifts quadword sized
     elements.</para>
   </listitem>
<![%inst-ref.sse2;[
   <listitem>
    <para><literal>PSLLDQ</literal> shifts double quadword sized
     elements.</para>
   </listitem>
]]>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-psrax">
  <title><literal>PSRAx</literal>: Packed Data Bit Shift Right
   Arithmetic</title>

  <indexterm>
   <primary><literal>PSRAx</literal></primary>
  </indexterm>

  <screen>PSRAW mm1,mm2/m64             ; 0F E1 /r             [PENT,MMX]
PSRAW mm,imm8                 ; 0F 71 /4 ib          [PENT,MMX]<![%inst-ref.sse2;[
 
PSRAW xmm1,xmm2/m128          ; 66 0F E1 /r     [WILLAMETTE,SSE2]
PSRAW xmm,imm8                ; 66 0F 71 /4 ib  [WILLAMETTE,SSE2]]]>
 
PSRAD mm1,mm2/m64             ; 0F E2 /r             [PENT,MMX]
PSRAD mm,imm8                 ; 0F 72 /4 ib          [PENT,MMX]<![%inst-ref.sse2;[
 
PSRAD xmm1,xmm2/m128          ; 66 0F E2 /r     [WILLAMETTE,SSE2]
PSRAD xmm,imm8                ; 66 0F 72 /4 ib  [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PSRAx</literal> performs arithmetic right shifts of
   the data elements in the destination (first) operand, moving each
   bit in the separate elements right by the number of bits specified
   in the source (second) operand, setting the high-order bits to the
   value of the original sign bit.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PSRAW</literal> shifts word sized elements.</para>
   </listitem> 

   <listitem>
    <para><literal>PSRAD</literal> shifts doubleword sized
     elements.</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-psrlx">
  <title><literal>PSRLx</literal>: Packed Data Bit Shift Right
   Logical</title>

  <indexterm>
   <primary><literal>PSRLx</literal></primary>
  </indexterm>

  <screen>PSRLW mm1,mm2/m64             ; 0F D1 /r             [PENT,MMX]
PSRLW mm,imm8                 ; 0F 71 /2 ib          [PENT,MMX]<![%inst-ref.sse2;[
 
PSRLW xmm1,xmm2/m128          ; 66 0F D1 /r     [WILLAMETTE,SSE2]
PSRLW xmm,imm8                ; 66 0F 71 /2 ib  [WILLAMETTE,SSE2]]]>
 
PSRLD mm1,mm2/m64             ; 0F D2 /r             [PENT,MMX]
PSRLD mm,imm8                 ; 0F 72 /2 ib          [PENT,MMX]<![%inst-ref.sse2;[
 
PSRLD xmm1,xmm2/m128          ; 66 0F D2 /r     [WILLAMETTE,SSE2]
PSRLD xmm,imm8                ; 66 0F 72 /2 ib  [WILLAMETTE,SSE2]]]>

PSRLQ mm1,mm2/m64             ; 0F D3 /r             [PENT,MMX]
PSRLQ mm,imm8                 ; 0F 73 /2 ib          [PENT,MMX]<![%inst-ref.sse2;[
 
PSRLQ xmm1,xmm2/m128          ; 66 0F D3 /r     [WILLAMETTE,SSE2]
PSRLQ xmm,imm8                ; 66 0F 73 /2 ib  [WILLAMETTE,SSE2]

PSRLDQ xmm1,imm8              ; 66 0F 73 /3 ib  [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PSRLx</literal> performs logical right shifts of the
   data elements in the destination (first) operand, moving each bit
   in the separate elements right by the number of bits specified in
   the source (second) operand, clearing the high-order bits as they
   are vacated.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PSRLW</literal> shifts word sized elements.</para>
   </listitem> 

   <listitem>
    <para><literal>PSRLD</literal> shifts doubleword sized
     elements.</para>
   </listitem>

   <listitem>
    <para><literal>PSRLQ</literal> shifts quadword sized
     elements.</para>
   </listitem>
<![%inst-ref.sse2;[
   <listitem>
    <para><literal>PSRLDQ</literal> shifts double quadword sized
     elements.</para>
   </listitem>
]]>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-psubx">
  <title><literal>PSUBx</literal>: Subtract Packed Integers</title>

  <indexterm>
   <primary><literal>PSUBx</literal></primary>
  </indexterm>

  <screen>PSUBB mm1,mm2/m64             ; 0F F8 /r             [PENT,MMX]
PSUBW mm1,mm2/m64             ; 0F F9 /r             [PENT,MMX]
PSUBD mm1,mm2/m64             ; 0F FA /r             [PENT,MMX]<![%inst-ref.sse2;[
PSUBQ mm1,mm2/m64             ; 0F FB /r        [WILLAMETTE,SSE2]

PSUBB xmm1,xmm2/m128          ; 66 0F F8 /r     [WILLAMETTE,SSE2]
PSUBW xmm1,xmm2/m128          ; 66 0F F9 /r     [WILLAMETTE,SSE2]
PSUBD xmm1,xmm2/m128          ; 66 0F FA /r     [WILLAMETTE,SSE2]
PSUBQ xmm1,xmm2/m128          ; 66 0F FB /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PSUBx</literal> subtracts packed integers in the
   source operand from those in the destination operand. It doesn't
   differentiate between signed and unsigned integers, and doesn't set
   any of the flags.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PSUBB</literal> operates on byte sized
     elements.</para>
   </listitem>

   <listitem>
    <para><literal>PSUBW</literal> operates on word sized
     elements.</para>
   </listitem>

   <listitem>
    <para><literal>PSUBD</literal> operates on doubleword sized
     elements.</para>
   </listitem>
<![%inst-ref.sse2;[
   <listitem>
    <para><literal>PSUBQ</literal> operates on quadword sized
     elements.</para>
   </listitem>
]]>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-psubsxx">
  <title><literal>PSUBSxx</literal>, <literal>PSUBUSx</literal>:
   Subtract Packed Integers with Saturation</title>

  <indexterm>
   <primary><literal>PSUBSxx</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>PSUBUSx</literal></primary>
  </indexterm>

  <screen>PSUBSB mm1,mm2/m64            ; 0F E8 /r             [PENT,MMX]
PSUBSW mm1,mm2/m64            ; 0F E9 /r             [PENT,MMX]<![%inst-ref.sse2;[
 
PSUBSB xmm1,xmm2/m128         ; 66 0F E8 /r     [WILLAMETTE,SSE2]
PSUBSW xmm1,xmm2/m128         ; 66 0F E9 /r     [WILLAMETTE,SSE2]]]>

PSUBUSB mm1,mm2/m64           ; 0F D8 /r             [PENT,MMX]
PSUBUSW mm1,mm2/m64           ; 0F D9 /r             [PENT,MMX]<![%inst-ref.sse2;[
 
PSUBUSB xmm1,xmm2/m128        ; 66 0F D8 /r     [WILLAMETTE,SSE2]
PSUBUSW xmm1,xmm2/m128        ; 66 0F D9 /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PSUBSx</literal> and <literal>PSUBUSx</literal>
   subtracts packed integers in the source operand from those in the
   destination operand, and use saturation for results that are
   outside the range supported by the destination operand.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PSUBSB</literal> operates on signed bytes, and uses
     signed saturation on the results.</para>
   </listitem>

   <listitem>
    <para><literal>PSUBSW</literal> operates on signed words, and uses
     signed saturation on the results.</para>
   </listitem>

   <listitem>
    <para><literal>PSUBUSB</literal> operates on unsigned bytes, and
     uses unsigned saturation on the results.</para>
   </listitem>

   <listitem>
    <para><literal>PSUBUSW</literal> operates on unsigned words, and
     uses unsigned saturation on the results.</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-punpckxxx">
  <title><literal>PUNPCKxxx</literal>: Unpack and Interleave
   Data</title>

  <indexterm>
   <primary><literal>PUNPCKxxx</literal></primary>
  </indexterm>

  <screen>PUNPCKHBW mm1,mm2/m64         ; 0F 68 /r             [PENT,MMX]
PUNPCKHWD mm1,mm2/m64         ; 0F 69 /r             [PENT,MMX]
PUNPCKHDQ mm1,mm2/m64         ; 0F 6A /r             [PENT,MMX]<![%inst-ref.sse2;[

PUNPCKHBW xmm1,xmm2/m128      ; 66 0F 68 /r     [WILLAMETTE,SSE2]
PUNPCKHWD xmm1,xmm2/m128      ; 66 0F 69 /r     [WILLAMETTE,SSE2]
PUNPCKHDQ xmm1,xmm2/m128      ; 66 0F 6A /r     [WILLAMETTE,SSE2]
PUNPCKHQDQ xmm1,xmm2/m128     ; 66 0F 6D /r     [WILLAMETTE,SSE2]]]>

PUNPCKLBW mm1,mm2/m32         ; 0F 60 /r             [PENT,MMX]
PUNPCKLWD mm1,mm2/m32         ; 0F 61 /r             [PENT,MMX]
PUNPCKLDQ mm1,mm2/m32         ; 0F 62 /r             [PENT,MMX]<![%inst-ref.sse2;[

PUNPCKLBW xmm1,xmm2/m128      ; 66 0F 60 /r     [WILLAMETTE,SSE2]
PUNPCKLWD xmm1,xmm2/m128      ; 66 0F 61 /r     [WILLAMETTE,SSE2]
PUNPCKLDQ xmm1,xmm2/m128      ; 66 0F 62 /r     [WILLAMETTE,SSE2]
PUNPCKLQDQ xmm1,xmm2/m128     ; 66 0F 6C /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PUNPCKxx</literal> all treat their operands as
   vectors, and produce a new vector generated by interleaving
   elements from the two inputs. The <literal>PUNPCKHxx</literal>
   instructions start by throwing away the bottom half of each input
   operand, and the <literal>PUNPCKLxx</literal> instructions throw
   away the top half.</para>

  <para>The remaining elements are then interleaved into the
   destination, alternating elements from the second (source) operand
   and the first (destination) operand: so the leftmost part of each
   element in the result always comes from the second operand, and the
   rightmost from the destination.</para>

  <itemizedlist>
   <listitem>
    <para><literal>PUNPCKxBW</literal> works a byte at a time,
     producing word sized output elements.</para>
   </listitem>

   <listitem>
    <para><literal>PUNPCKxWD</literal> works a word at a time,
     producing doubleword sized output elements.</para>
   </listitem>

   <listitem>
    <para><literal>PUNPCKxDQ</literal> works a doubleword at a time,
     producing quadword sized output elements.</para>
   </listitem>
<![%inst-ref.sse2;[
   <listitem>
    <para><literal>PUNPCKxDQ</literal> works a quadword at a time,
     producing double quadword sized output elements.</para>
   </listitem>
]]>
  </itemizedlist>

  <para>So, for example, for &reg.mmx; operands, if the first operand
   held <literal>0x7A6A5A4A3A2A1A0A</literal> and the second held
   <literal>0x7B6B5B4B3B2B1B0B</literal>, then:</para>

  <simplelist>
   <member><literal>PUNPCKHBW</literal> would return
    <literal>0x7B7A6B6A5B5A4B4A</literal>.</member>

   <member><literal>PUNPCKHWD</literal> would return
    <literal>0x7B6B7A6A5B4B5A4A</literal>.</member>

   <member><literal>PUNPCKHDQ</literal> would return
    <literal>0x7B6B5B4B7A6A5A4A</literal>.</member>

   <member><literal>PUNPCKLBW</literal> would return
    <literal>0x3B3A2B2A1B1A0B0A</literal>.</member>

   <member><literal>PUNPCKLWD</literal> would return
    <literal>0x3B2B3A2A1B0B1A0A</literal>.</member>

   <member><literal>PUNPCKLDQ</literal> would return
    <literal>0x3B2B1B0B3A2A1A0A</literal>.</member>
  </simplelist>
 </sect1>

 <sect1 id="inst-ref-push">
  <title><literal>PUSH</literal>: Push Data on Stack</title>

  <indexterm>
   <primary><literal>PUSH</literal></primary>
  </indexterm>

  <screen>PUSH reg16                    ; o16 50+r             [8086]
PUSH reg32                    ; o32 50+r             [386]

PUSH r/m16                    ; o16 FF /6            [8086]
PUSH r/m32                    ; o32 FF /6            [386]

PUSH CS                       ; 0E                   [8086]
PUSH DS                       ; 1E                   [8086]
PUSH ES                       ; 06                   [8086]
PUSH SS                       ; 16                   [8086]
PUSH FS                       ; 0F A0                [386]
PUSH GS                       ; 0F A8                [386]

PUSH imm8                     ; 6A ib                [286]
PUSH imm16                    ; o16 68 iw            [286]
PUSH imm32                    ; o32 68 id            [386]</screen>

  <para><literal>PUSH</literal> decrements the stack pointer (&reg.sp;
   or &reg.esp;) by 2 or 4, and then stores the given value at
   <literal>[&reg.ss;:&reg.sp;]</literal> or
   <literal>[&reg.ss;:&reg.esp;]</literal>.</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The address-size attribute of the instruction determines
   whether &reg.sp; or &reg.esp; is used as the stack pointer: to
   deliberately override the default given by the
   <literal>BITS</literal> setting, you can use an
   <literal>a16</literal> or <literal>a32</literal> prefix.</para>

  <indexterm>
   <primary><literal>o16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>o32</literal></primary>
  </indexterm>

  <para>The operand-size attribute of the instruction determines
   whether the stack pointer is decremented by 2 or 4: this means that
   segment register pushes in <literal>BITS 32</literal> mode will
   push 4 bytes on the stack, of which the upper two are undefined. If
   you need to override that, you can use an <literal>o16</literal> or
   <literal>o32</literal> prefix.</para>

  <indexterm>
   <primary>register push</primary>
  </indexterm>

  <para>The above opcode listings give two forms for general-purpose
   register push instructions: for example, <literal>PUSH BX</literal>
   has the two forms <literal>53</literal> and <literal>FF
    F3</literal>. NASM will always generate the shorter form when
   given <literal>PUSH BX</literal>.</para>
<![%inst-ref.undoc;[
  <para>Unlike the undocumented and barely supported <literal>POP
    CS</literal>, <literal>PUSH CS</literal> is a perfectly valid and
   sensible instruction, supported on all processors.</para>
]]>
  <para>The instruction <literal>PUSH SP</literal> may be used to
   distinguish an 8086 from later processors: on an 8086, the value of
   &reg.sp; stored is the value it has <emphasis>after</emphasis> the
   push instruction, whereas on later processors it is the value
   <emphasis>before</emphasis> the push instruction.</para>
 </sect1>

 <sect1 id="inst-ref-pusha">
  <title><literal>PUSHAx</literal>: Push All General-Purpose
   Registers</title>

  <indexterm>
   <primary><literal>PUSHAx</literal></primary>
  </indexterm>

  <screen>PUSHA                         ; 60                   [186]
PUSHAD                        ; o32 60               [386]
PUSHAW                        ; o16 60               [186]</screen>

  <para><literal>PUSHAW</literal> pushes, in succession, &reg.ax;,
   &reg.cx;, &reg.dx;, &reg.bx;, &reg.sp;, &reg.bp;, &reg.si; and
   &reg.di; on the stack, decrementing the stack pointer by a total of
   16.</para>

  <para><literal>PUSHAD</literal> pushes, in succession, &reg.eax;,
   &reg.ecx;, &reg.edx;, &reg.ebx;, &reg.esp;, &reg.ebp;, &reg.esi;
   and &reg.edi; on the stack, decrementing the stack pointer by a
   total of 32.</para>

  <para>In both cases, the value of &reg.sp; or &reg.esp; pushed is
   its <emphasis>original</emphasis> value, as it had before the
   instruction was executed.</para>

  <para><literal>PUSHA</literal> is an alias mnemonic for either
   <literal>PUSHAW</literal> or <literal>PUSHAD</literal>, depending
   on the current <literal>BITS</literal> setting.</para>

  <para>Note that the registers are pushed in order of their numeric
   values in opcodes (see <xref
    linkend="inst-ref-opcode-desc-reg-values">).</para>

  <para>See also <literal>POPA</literal> (<xref
    linkend="inst-ref-popa">).</para>
 </sect1>

 <sect1 id="inst-ref-pushf">
  <title><literal>PUSHFx</literal>: Push Flags Register</title>

  <indexterm>
   <primary><literal>PUSHFx</literal></primary>
  </indexterm>

  <screen>PUSHF                         ; 9C                   [8086]
PUSHFD                        ; o32 9C               [386]
PUSHFW                        ; o16 9C               [8086]</screen>

  <itemizedlist>
   <listitem>
    <para><literal>PUSHFW</literal> pops a word from the stack and
     stores it in the bottom 16 bits of the flags register (or the
     whole flags register, on processors below a 386).</para>
   </listitem>

   <listitem>
    <para><literal>PUSHFD</literal> pops a doubleword and stores it in
     the entire flags register.</para>
   </listitem>
  </itemizedlist>

  <para><literal>PUSHF</literal> is an alias mnemonic for either
   <literal>PUSHFW</literal> or <literal>PUSHFD</literal>, depending
   on the current <literal>BITS</literal> setting.</para>

  <para>See also <literal>POPF</literal> (<xref
    linkend="inst-ref-popf">).</para>
 </sect1>

 <sect1 id="inst-ref-pxor">
  <title><literal>PXOR</literal>: Packed Data Bitwise XOR</title>

  <indexterm>
   <primary><literal>PXOR</literal></primary>
  </indexterm>

  <screen>PXOR mm1,mm2/m64              ; 0F EF /r             [PENT,MMX]<![%inst-ref.sse2;[
PXOR xmm1,xmm2/m128           ; 66 0F EF /r     [WILLAMETTE,SSE2]]]></screen>

  <para><literal>PXOR</literal> performs a bitwise XOR operation
   between its two operands (i.e. each bit of the result is 1 if and
   only if exactly one of the corresponding bits of the two inputs was
   1), and stores the result in the destination (first)
   operand.</para>
 </sect1>

 <sect1 id="inst-ref-rcl">
  <title><literal>RCL</literal>, <literal>RCR</literal>: Bitwise
   Rotate through Carry Bit</title>

  <indexterm>
   <primary><literal>RCL</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>RCR</literal></primary>
  </indexterm>

  <screen>RCL r/m8,1                    ; D0 /2                [8086]
RCL r/m8,CL                   ; D2 /2                [8086]
RCL r/m8,imm8                 ; C0 /2 ib             [286]
RCL r/m16,1                   ; o16 D1 /2            [8086]
RCL r/m16,CL                  ; o16 D3 /2            [8086]
RCL r/m16,imm8                ; o16 C1 /2 ib         [286]
RCL r/m32,1                   ; o32 D1 /2            [386]
RCL r/m32,CL                  ; o32 D3 /2            [386]
RCL r/m32,imm8                ; o32 C1 /2 ib         [386]

RCR r/m8,1                    ; D0 /3                [8086]
RCR r/m8,CL                   ; D2 /3                [8086]
RCR r/m8,imm8                 ; C0 /3 ib             [286]
RCR r/m16,1                   ; o16 D1 /3            [8086]
RCR r/m16,CL                  ; o16 D3 /3            [8086]
RCR r/m16,imm8                ; o16 C1 /3 ib         [286]
RCR r/m32,1                   ; o32 D1 /3            [386]
RCR r/m32,CL                  ; o32 D3 /3            [386]
RCR r/m32,imm8                ; o32 C1 /3 ib         [386]</screen>

  <para><literal>RCL</literal> and <literal>RCR</literal> perform a
   9-bit, 17-bit or 33-bit bitwise rotation operation, involving the
   given source/destination (first) operand and the carry bit. Thus,
   for example, in the operation <literal>RCL &reg.al;,1</literal>, a
   9-bit rotation is performed in which &reg.al; is shifted left by 1,
   the top bit of &reg.al; moves into the carry flag, and the original
   value of the carry flag is placed in the low bit of
   &reg.al;.</para>

  <para>The number of bits to rotate by is given by the second
   operand. Only the bottom five bits of the rotation count are
   considered by processors above the 8086.</para>

  <para>You can force the longer (286 and upwards, beginning with a
   <literal>C1</literal> byte) form of <literal>RCL foo,1</literal> by
   using a <literal>BYTE</literal> prefix: <literal>RCL foo,BYTE
    1</literal>. Similarly with <literal>RCR</literal>.</para>
 </sect1>

 <sect1 id="inst-ref-rcpps">
  <title><literal>RCPPS</literal>: Packed Single-Precision FP
   Reciprocal</title>

  <indexterm>
   <primary><literal>RCPPS</literal></primary>
  </indexterm>

  <screen>RCPPS xmm1,xmm2/m128          ; 0F 53 /r        [KATMAI,SSE]</screen>

  <para><literal>RCPPS</literal> returns an approximation of the
   reciprocal of the packed single-precision FP values from xmm2/m128.
   The maximum error for this approximation is: |Error| <= 1.5 x
   2<superscript>-12</superscript></para>
 </sect1>

 <sect1 id="inst-ref-rcpss">
  <title><literal>RCPSS</literal>: Scalar Single-Precision FP
   Reciprocal</title>

  <indexterm>
   <primary><literal>RCPSS</literal></primary>
  </indexterm>

  <screen>RCPSS xmm1,xmm2/m128          ; F3 0F 53 /r     [KATMAI,SSE]</screen>

  <para><literal>RCPSS</literal> returns an approximation of the
   reciprocal of the lower single-precision FP value from xmm2/m32;
   the upper three fields are passed through from xmm1. The maximum
   error for this approximation is: |Error| <= 1.5 x
   2<superscript>-12</superscript></para>
 </sect1>

 <sect1 id="inst-ref-rdmsr">
  <title><literal>RDMSR</literal>: Read Model-Specific Registers</title>

  <indexterm>
   <primary><literal>RDMSR</literal></primary>
  </indexterm>

  <screen>RDMSR                         ; 0F 32                [PENT,PRIV]</screen>

  <para><literal>RDMSR</literal> reads the processor Model-Specific
   Register (MSR) whose index is stored in &reg.ecx;, and stores the
   result in <literal>&reg.edx;:&reg.eax;</literal>. See also
   <literal>WRMSR</literal> (<xref linkend="inst-ref-wrmsr">).</para>
 </sect1>

 <sect1 id="inst-ref-rdpmc">
  <title><literal>RDPMC</literal>: Read Performance-Monitoring
   Counters</title>

  <indexterm>
   <primary><literal>RDPMC</literal></primary>
  </indexterm>

  <screen>RDPMC                         ; 0F 33                [P6]</screen>

  <para><literal>RDPMC</literal> reads the processor
   performance-monitoring counter whose index is stored in &reg.ecx;,
   and stores the result in
   <literal>&reg.edx;:&reg.eax;</literal>.</para>

  <para>This instruction is available on P6 and later processors and
   on MMX class processors.</para>
 </sect1>

 <sect1 id="inst-ref-rdtsc">
  <title><literal>RDTSC</literal>: Read Time-Stamp Counter</title>

  <indexterm>
   <primary><literal>RDTSC</literal></primary>
  </indexterm>

  <screen>RDTSC                         ; 0F 31                [PENT]</screen>

  <para><literal>RDTSC</literal> reads the processor's time-stamp
   counter into <literal>&reg.edx;:&reg.eax;</literal>.</para>
 </sect1>

 <sect1 id="inst-ref-ret">
  <title><literal>RET</literal>, <literal>RETF</literal>,
   <literal>RETN</literal>: Return from Procedure Call</title>

  <indexterm>
   <primary><literal>RET</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>RETF</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>RETN</literal></primary>
  </indexterm>

  <screen>RET                           ; C3                   [8086]
RET imm16                     ; C2 iw                [8086]

RETF                          ; CB                   [8086]
RETF imm16                    ; CA iw                [8086]

RETN                          ; C3                   [8086]
RETN imm16                    ; C2 iw                [8086]</screen>

  <itemizedlist>
   <listitem>
    <para><literal>RET</literal>, and its exact synonym
     <literal>RETN</literal>, pop <literal>IP</literal> or
     <literal>EIP</literal> from the stack and transfer control to the
     new address. Optionally, if a numeric second operand is provided,
     they increment the stack pointer by a further
     <literal>imm16</literal> bytes after popping the return
     address.</para>
   </listitem>

   <listitem>
    <para><literal>RETF</literal> executes a far return: after popping
     <literal>IP</literal>/<literal>EIP</literal>, it then pops
     <literal>CS</literal>, and <emphasis>then</emphasis> increments
     the stack pointer by the optional argument if present.</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-rol">
  <title><literal>ROL</literal>, <literal>ROR</literal>: Bitwise
   Rotate</title>

  <indexterm>
   <primary><literal>ROL</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>ROR</literal></primary>
  </indexterm>

  <screen>ROL r/m8,1                    ; D0 /0                [8086]
ROL r/m8,CL                   ; D2 /0                [8086]
ROL r/m8,imm8                 ; C0 /0 ib             [286]
ROL r/m16,1                   ; o16 D1 /0            [8086]
ROL r/m16,CL                  ; o16 D3 /0            [8086]
ROL r/m16,imm8                ; o16 C1 /0 ib         [286]
ROL r/m32,1                   ; o32 D1 /0            [386]
ROL r/m32,CL                  ; o32 D3 /0            [386]
ROL r/m32,imm8                ; o32 C1 /0 ib         [386]

ROR r/m8,1                    ; D0 /1                [8086]
ROR r/m8,CL                   ; D2 /1                [8086]
ROR r/m8,imm8                 ; C0 /1 ib             [286]
ROR r/m16,1                   ; o16 D1 /1            [8086]
ROR r/m16,CL                  ; o16 D3 /1            [8086]
ROR r/m16,imm8                ; o16 C1 /1 ib         [286]
ROR r/m32,1                   ; o32 D1 /1            [386]
ROR r/m32,CL                  ; o32 D3 /1            [386]
ROR r/m32,imm8                ; o32 C1 /1 ib         [386]</screen>

  <para><literal>ROL</literal> and <literal>ROR</literal> perform a
   bitwise rotation operation on the given source/destination (first)
   operand. Thus, for example, in the operation <literal>ROL
    &reg.al;,1</literal>, an 8-bit rotation is performed in which
   &reg.al; is shifted left by 1 and the original top bit of &reg.al;
   moves round into the low bit.</para>

  <para>The number of bits to rotate by is given by the second
   operand.  Only the bottom five bits of the rotation count are
   considered by processors above the 8086.</para>

  <para>You can force the longer (286 and upwards, beginning with a
   <literal>C1</literal> byte) form of <literal>ROL foo,1</literal> by
   using a <literal>BYTE</literal> prefix: <literal>ROL foo,BYTE
    1</literal>. Similarly with <literal>ROR</literal>.</para>
 </sect1>

 <sect1 id="inst-ref-rsm">
  <title><literal>RSM</literal>: Resume from System-Management
   Mode</title>

  <indexterm>
   <primary><literal>RSM</literal></primary>
  </indexterm>

  <screen>RSM                           ; 0F AA                [PENT]</screen>

  <para><literal>RSM</literal> returns the processor to its normal
   operating mode when it was in System-Management Mode.</para>
 </sect1>

 <sect1 id="inst-ref-rsqrtps">
  <title><literal>RSQRTPS</literal>: Packed Single-Precision FP Square
   Root Reciprocal</title>

  <indexterm>
   <primary><literal>RSQRTPS</literal></primary>
  </indexterm>

  <screen>RSQRTPS xmm1,xmm2/m128        ; 0F 52 /r        [KATMAI,SSE]</screen>

  <para><literal>RSQRTPS</literal> computes the approximate
   reciprocals of the square roots of the packed single-precision
   floating-point values in the source and stores the results in xmm1.
   The maximum error for this approximation is: |Error| <= 1.5 x
   2<superscript>-12</superscript></para>
 </sect1>

 <sect1 id="inst-ref-rsqrtss">
  <title><literal>RSQRTSS</literal>: Scalar Single-Precision FP Square
   Root Reciprocal</title>

  <indexterm>
   <primary><literal>RSQRTSS</literal></primary>
  </indexterm>
  <screen>RSQRTSS xmm1,xmm2/m128        ; F3 0F 52 /r     [KATMAI,SSE]</screen>

  <para><literal>RSQRTSS</literal> returns an approximation of the
   reciprocal of the square root of the lowest order single-precision
   FP value from the source, and stores it in the low doubleword of
   the destination register. The upper three fields of xmm1 are
   preserved. The maximum error for this approximation is: |Error| <=
   1.5 x 2<superscript>-12</superscript></para>
 </sect1>

 <sect1 id="inst-ref-sahf">
  <title><literal>SAHF</literal>: Store AH to Flags</title>

  <indexterm>
   <primary><literal>SAHF</literal></primary>
  </indexterm>

  <screen>SAHF                          ; 9E                   [8086]</screen>

  <para><literal>SAHF</literal> sets the low byte of the flags word
   according to the contents of the &reg.ah; register.</para>

  <para>The operation of \c{SAHF} is:</para>

  <screen>AH --> SF:ZF:0:AF:0:PF:1:CF</screen>

  <para>See also <literal>LAHF</literal> (<xref
    linkend="inst-ref-lahf">).</para>
 </sect1>

 <sect1 id="inst-ref-sal">
  <title><literal>SAL</literal>, <literal>SAR</literal>: Bitwise
   Arithmetic Shifts</title>

  <indexterm>
   <primary><literal>SAL</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>SAR</literal></primary>
  </indexterm>

  <screen>SAL r/m8,1                    ; D0 /4                [8086]
SAL r/m8,CL                   ; D2 /4                [8086]
SAL r/m8,imm8                 ; C0 /4 ib             [286]
SAL r/m16,1                   ; o16 D1 /4            [8086]
SAL r/m16,CL                  ; o16 D3 /4            [8086]
SAL r/m16,imm8                ; o16 C1 /4 ib         [286]
SAL r/m32,1                   ; o32 D1 /4            [386]
SAL r/m32,CL                  ; o32 D3 /4            [386]
SAL r/m32,imm8                ; o32 C1 /4 ib         [386]

SAR r/m8,1                    ; D0 /7                [8086]
SAR r/m8,CL                   ; D2 /7                [8086]
SAR r/m8,imm8                 ; C0 /7 ib             [286]
SAR r/m16,1                   ; o16 D1 /7            [8086]
SAR r/m16,CL                  ; o16 D3 /7            [8086]
SAR r/m16,imm8                ; o16 C1 /7 ib         [286]
SAR r/m32,1                   ; o32 D1 /7            [386]
SAR r/m32,CL                  ; o32 D3 /7            [386]
SAR r/m32,imm8                ; o32 C1 /7 ib         [386]</screen>

  <para><literal>SAL</literal> and <literal>SAR</literal> perform an
   arithmetic shift operation on the given source/destination (first)
   operand. The vacated bits are filled with zero for
   <literal>SAL</literal>, and with copies of the original high bit of
   the source operand for <literal>SAR</literal>.</para>

  <para><literal>SAL</literal> is a synonym for <literal>SHL</literal>
   (see <xref linkend="inst-ref-shl">). NASM will assemble either one
   to the same code, but NDISASM will always disassemble that code as
   <literal>SHL</literal>.</para>

  <para>The number of bits to shift by is given by the second operand.
   Only the bottom five bits of the shift count are considered by
   processors above the 8086.</para>

  <para>You can force the longer (286 and upwards, beginning with a
   <literal>C1</literal> byte) form of <literal>SAL foo,1</literal> by
   using a <literal>BYTE</literal> prefix: <literal>SAL foo,BYTE
    1</literal>. Similarly with <literal>SAR</literal>.</para>
 </sect1>

 <sect1 id="inst-ref-salc">
  <title><literal>SALC</literal>: Set AL from Carry Flag</title>

  <indexterm>
   <primary><literal>SALC</literal></primary>
  </indexterm>

  <screen>SALC                          ; D6                  [8086,UNDOC]</screen>

  <para><literal>SALC</literal> is an early undocumented instruction
   similar in concept to <literal>SETcc</literal> (<xref
    linkend="inst-ref-setcc">). Its function is to set &reg.al; to
   zero if the carry flag is clear, or to <literal>0xFF</literal> if
   it is set.</para>
 </sect1>

 <sect1 id="inst-ref-sbb">
  <title><literal>SBB</literal>: Subtract with Borrow</title>

  <indexterm>
   <primary><literal>SBB</literal></primary>
  </indexterm>

  <screen>SBB r/m8,reg8                 ; 18 /r                [8086]
SBB r/m16,reg16               ; o16 19 /r            [8086]
SBB r/m32,reg32               ; o32 19 /r            [386]

SBB reg8,r/m8                 ; 1A /r                [8086]
SBB reg16,r/m16               ; o16 1B /r            [8086]
SBB reg32,r/m32               ; o32 1B /r            [386]

SBB r/m8,imm8                 ; 80 /3 ib             [8086]
SBB r/m16,imm16               ; o16 81 /3 iw         [8086]
SBB r/m32,imm32               ; o32 81 /3 id         [386]

SBB r/m16,imm8                ; o16 83 /3 ib         [8086]
SBB r/m32,imm8                ; o32 83 /3 ib         [386]

SBB AL,imm8                   ; 1C ib                [8086]
SBB AX,imm16                  ; o16 1D iw            [8086]
SBB EAX,imm32                 ; o32 1D id            [386]</screen>

  <para><literal>SBB</literal> performs integer subtraction: it
   subtracts its second operand, plus the value of the carry flag,
   from its first, and leaves the result in its destination (first)
   operand. The flags are set according to the result of the
   operation: in particular, the carry flag is affected and can be
   used by a subsequent <literal>SBB</literal> instruction.</para>

  <para>In the forms with an 8-bit immediate second operand and a
   longer first operand, the second operand is considered to be
   signed, and is sign-extended to the length of the first operand. In
   these cases, the <literal>BYTE</literal> qualifier is necessary to
   force NASM to generate this form of the instruction.</para>

  <para>To subtract one number from another without also subtracting
   the contents of the carry flag, use <literal>SUB</literal> (<xref
    linkend="inst-ref-sub">).</para>
 </sect1>

 <sect1 id="inst-ref-scasb">
  <title><literal>SCASB</literal>, <literal>SCASW</literal>,
   <literal>SCASD</literal>: Scan String</title>

  <indexterm>
   <primary><literal>SCASB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>SCASW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>SCASD</literal></primary>
  </indexterm>

  <screen>SCASB                         ; AE                   [8086]
SCASW                         ; o16 AF               [8086]
SCASD                         ; o32 AF               [386]</screen>

  <para><literal>SCASB</literal> compares the byte in &reg.al; with
   the byte at <literal>[&reg.es;:&reg.di;]</literal> or
   <literal>[&reg.es;:&reg.edi;]</literal>, and sets the flags
   accordingly. It then increments or decrements (depending on the
   direction flag: increments if the flag is clear, decrements if it
   is set) &reg.di; (or &reg.edi;).</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The register used is &reg.di; if the address size is 16 bits,
   and &reg.edi; if it is 32 bits. If you need to use an address size
   not equal to the current <literal>BITS</literal> setting, you can
   use an explicit <literal>a16</literal> or <literal>a32</literal>
   prefix.</para>

  <para>Segment override prefixes have no effect for this instruction:
   the use of &reg.es; for the load from <literal>[DI]</literal> or
   <literal>[&reg.edi;]</literal> cannot be overridden.</para>

  <para><literal>SCASW</literal> and <literal>SCASD</literal> work in
   the same way, but they compare a word to &reg.ax; or a doubleword
   to &reg.eax; instead of a byte to &reg.al;, and increment or
   decrement the addressing registers by 2 or 4 instead of 1.</para>

  <para>The <literal>REPE</literal> and <literal>REPNE</literal>
   prefixes (equivalently, <literal>REPZ</literal> and
   <literal>REPNZ</literal>) may be used to repeat the instruction up
   to &reg.cx; (or &reg.ecx; - again, the address size chooses which)
   times until the first unequal or equal byte is found.</para>
 </sect1>

 <sect1 id="inst-ref-setcc">
  <title><literal>SETcc</literal>: Set Register from Condition</title>

  <indexterm>
   <primary><literal>SETcc</literal></primary>
  </indexterm>

  <screen>SETcc r/m8                    ; 0F 90+cc /2          [386]</screen>

  <para><literal>SETcc</literal> sets the given 8-bit operand to zero
   if its condition is not satisfied, and to 1 if it is.</para>
 </sect1>

 <sect1 id="inst-ref-sfence">
  <title><literal>SFENCE</literal>: Store Fence</title>

  <indexterm>
   <primary><literal>SFENCE</literal></primary>
  </indexterm>

  <screen>SFENCE                 ; 0F AE /7               [KATMAI]</screen>

  <para><literal>SFENCE</literal> performs a serialising operation on
   all writes to memory that were issued before the
   <literal>SFENCE</literal> instruction. This guarantees that all
   memory writes before the <literal>SFENCE</literal> instruction are
   visible before any writes after the <literal>SFENCE</literal>
   instruction.</para>

  <para><literal>SFENCE</literal> is ordered respective to other
   <literal>SFENCE</literal> instruction, <literal>MFENCE</literal>,
   any memory write and any other serialising instruction (such as
   <literal>CPUID</literal>).</para>

  <para>Weakly ordered memory types can be used to achieve higher
   processor performance through such techniques as out-of-order
   issue, write-combining, and write-collapsing. The degree to which a
   consumer of data recognizes or knows that the data is weakly
   ordered varies among applications and may be unknown to the
   producer of this data. The <literal>SFENCE</literal> instruction
   provides a performance-efficient way of insuring store ordering
   between routines that produce weakly-ordered results and routines
   that consume this data.</para>

  <para><literal>SFENCE</literal> uses the following ModRM
   encoding:</para>

  <screen>          Mod (7:6)        = 11B
          Reg/Opcode (5:3) = 111B
          R/M (2:0)        = 000B</screen>

  <para>All other ModRM encodings are defined to be reserved, and use
   of these encodings risks incompatibility with future
   processors.</para>

  <para>See also <literal>LFENCE</literal> (<xref
    linkend="inst-ref-lfence">) and <literal>MFENCE</literal> (<xref
    linkend="inst-ref-mfence">).</para>
 </sect1>

 <sect1 id="inst-ref-sgdt">
  <title><literal>SGDT</literal>, <literal>SIDT</literal>,
   <literal>SLDT</literal>: Store Descriptor Table Pointers</title>

  <indexterm>
   <primary><literal>SGDT</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>SIDT</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>SLDT</literal></primary>
  </indexterm>

  <screen>SGDT mem                      ; 0F 01 /0             [286,PRIV]
SIDT mem                      ; 0F 01 /1             [286,PRIV]
SLDT r/m16                    ; 0F 00 /0             [286,PRIV]</screen>

  <para><literal>SGDT</literal> and <literal>SIDT</literal> both take
   a 6-byte memory area as an operand: they store the contents of the
   GDTR (global descriptor table register) or IDTR (interrupt
   descriptor table register) into that area as a 32-bit linear
   address and a 16-bit size limit from that area (in that order).
   These are the only instructions which directly use
   <emphasis>linear</emphasis> addresses, rather than segment/offset
   pairs.</para>

  <para><literal>SLDT</literal> stores the segment selector
   corresponding to the LDT (local descriptor table) into the given
   operand.</para>

  <para>See also <literal>LGDT</literal>, <literal>LIDT</literal> and
   <literal>LLDT</literal> (<xref linkend="inst-ref-lgdt">).</para>
 </sect1>

 <sect1 id="inst-ref-shl">
  <title><literal>SHL</literal>, <literal>SHR</literal>: Bitwise
   Logical Shifts</title>

  <indexterm>
   <primary><literal>SHL</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>SHR</literal></primary>
  </indexterm>

  <screen>SHL r/m8,1                    ; D0 /4                [8086]
SHL r/m8,CL                   ; D2 /4                [8086]
SHL r/m8,imm8                 ; C0 /4 ib             [286]
SHL r/m16,1                   ; o16 D1 /4            [8086]
SHL r/m16,CL                  ; o16 D3 /4            [8086]
SHL r/m16,imm8                ; o16 C1 /4 ib         [286]
SHL r/m32,1                   ; o32 D1 /4            [386]
SHL r/m32,CL                  ; o32 D3 /4            [386]
SHL r/m32,imm8                ; o32 C1 /4 ib         [386]

SHR r/m8,1                    ; D0 /5                [8086]
SHR r/m8,CL                   ; D2 /5                [8086]
SHR r/m8,imm8                 ; C0 /5 ib             [286]
SHR r/m16,1                   ; o16 D1 /5            [8086]
SHR r/m16,CL                  ; o16 D3 /5            [8086]
SHR r/m16,imm8                ; o16 C1 /5 ib         [286]
SHR r/m32,1                   ; o32 D1 /5            [386]
SHR r/m32,CL                  ; o32 D3 /5            [386]
SHR r/m32,imm8                ; o32 C1 /5 ib         [386]</screen>

  <para><literal>SHL</literal> and <literal>SHR</literal> perform a
   logical shift operation on the given source/destination (first)
   operand. The vacated bits are filled with zero.</para>

  <para>A synonym for <literal>SHL</literal> is <literal>SAL</literal>
   (see <xref linkend="inst-ref-sal">).  NASM will assemble either one
   to the same code.</para>

  <para>The number of bits to shift by is given by the second operand.
   Only the bottom five bits of the shift count are considered by
   processors above the 8086.</para>

  <para>You can force the longer (286 and upwards, beginning with a
   <literal>C1</literal> byte) form of <literal>SHL foo,1</literal> by
   using a <literal>BYTE</literal> prefix: <literal>SHL foo,BYTE
    1</literal>. Similarly with <literal>SHR</literal>.</para>
 </sect1>

 <sect1 id="inst-ref-shld">
  <title><literal>SHLD</literal>, <literal>SHRD</literal>: Bitwise
   Double-Precision Shifts</title>

  <indexterm>
   <primary><literal>SHLD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>SHRD</literal></primary>
  </indexterm>

  <screen>SHLD r/m16,reg16,imm8         ; o16 0F A4 /r ib      [386]
SHLD r/m16,reg32,imm8         ; o32 0F A4 /r ib      [386]
SHLD r/m16,reg16,CL           ; o16 0F A5 /r         [386]
SHLD r/m16,reg32,CL           ; o32 0F A5 /r         [386]

SHRD r/m16,reg16,imm8         ; o16 0F AC /r ib      [386]
SHRD r/m32,reg32,imm8         ; o32 0F AC /r ib      [386]
SHRD r/m16,reg16,CL           ; o16 0F AD /r         [386]
SHRD r/m32,reg32,CL           ; o32 0F AD /r         [386]</screen>

  <itemizedlist>
   <listitem>
    <para><literal>SHLD</literal> performs a double-precision left
     shift. It notionally places its second operand to the right of
     its first, then shifts the entire bit string thus generated to
     the left by a number of bits specified in the third operand. It
     then updates only the <emphasis>first</emphasis> operand
     according to the result of this. The second operand is not
     modified.</para>
   </listitem>

   <listitem>
    <para><literal>SHRD</literal> performs the corresponding right
     shift: it notionally places the second operand to the
     <emphasis>left</emphasis> of the first, shifts the whole bit
     string right, and updates only the first operand.</para>
   </listitem>
  </itemizedlist>

  <para>For example, if &reg.eax; holds <literal>0x01234567</literal>
   and &reg.ebx; holds <literal>0x89ABCDEF</literal>, then the
   instruction <literal>SHLD EAX,EBX,4</literal> would update
   &reg.eax; to hold <literal>0x12345678</literal>. Under the same
   conditions, <literal>SHRD EAX,EBX,4</literal> would update
   &reg.eax; to hold <literal>0xF0123456</literal>.</para>

  <para>The number of bits to shift by is given by the third operand.
   Only the bottom five bits of the shift count are considered.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-shufpd">
  <title><literal>SHUFPD</literal>: Shuffle Packed Double-Precision FP
   Values</title>

  <indexterm>
   <primary><literal>SHUFPD</literal></primary>
  </indexterm>

  <screen>SHUFPD xmm1,xmm2/m128,imm8    ; 66 0F C6 /r ib  [WILLAMETTE,SSE2]</screen>
 
  <para><literal>SHUFPD</literal> moves one of the packed
   double-precision FP values from the destination operand into the
   low quadword of the destination operand; the upper quadword is
   generated by moving one of the double-precision FP values from the
   source operand into the destination. The select (third) operand
   selects which of the values are moved to the destination
   register.</para>
 
  <para>The select operand is an 8-bit immediate: bit 0 selects which
   value is moved from the destination operand to the result (where 0
   selects the low quadword and 1 selects the high quadword) and bit 1
   selects which value is moved from the source operand to the result.
   Bits 2 through 7 of the shuffle operand are reserved.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-shufps">
  <title><literal>SHUFPS</literal>: Shuffle Packed Single-Precision FP
   Values</title>

  <indexterm>
   <primary><literal>SHUFPS</literal></primary>
  </indexterm>

  <screen>SHUFPS xmm1,xmm2/m128,imm8    ; 0F C6 /r ib     [KATMAI,SSE]</screen>

  <para><literal>SHUFPS</literal> moves two of the packed
   single-precision FP values from the destination operand into the
   low quadword of the destination operand; the upper quadword is
   generated by moving two of the single-precision FP values from the
   source operand into the destination. The select (third) operand
   selects which of the values are moved to the destination
   register.</para>

  <para>The select operand is an 8-bit immediate: bits 0 and 1 select
   the value to be moved from the destination operand the low
   doubleword of the result, bits 2 and 3 select the value to be moved
   from the destination operand the second doubleword of the result,
   bits 4 and 5 select the value to be moved from the source operand
   the third doubleword of the result, and bits 6 and 7 select the
   value to be moved from the source operand to the high doubleword of
   the result.</para>
 </sect1>

 <sect1 id="inst-ref-smsw">
  <title><literal>SMSW</literal>: Store Machine Status Word</title>

  <indexterm>
   <primary><literal>SMSW</literal></primary>
  </indexterm>

  <screen>SMSW r/m16                    ; 0F 01 /4             [286,PRIV]</screen>

  <para><literal>SMSW</literal> stores the bottom half of the
   <literal>CR0</literal> control register (or the Machine Status
   Word, on 286 processors) into the destination operand. See also
   <literal>LMSW</literal> (<xref linkend="inst-ref-lmsw">).</para>

  <para>For 32-bit code, this would use the low 16-bits of the
   specified register (or a 16 bit memory location), without needing
   an operand size override byte.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-sqrtpd">
  <title><literal>SQRTPD</literal>: Packed Double-Precision FP Square
   Root</title>

  <indexterm>
   <primary><literal>SQRTPD</literal></primary>
  </indexterm>

  <screen>SQRTPD xmm1,xmm2/m128         ; 66 0F 51 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>SQRTPD</literal> calculates the square root of the
   packed double-precision FP value from the source operand, and
   stores the double-precision results in the destination
   register.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-sqrtps">
  <title><literal>SQRTPS</literal>: Packed Single-Precision FP Square
   Root</title>

  <indexterm>
   <primary><literal>SQRTPS</literal></primary>
  </indexterm>

  <screen>SQRTPS xmm1,xmm2/m128         ; 0F 51 /r        [KATMAI,SSE]</screen>

  <para><literal>SQRTPS</literal> calculates the square root of the
   packed single-precision FP value from the source operand, and
   stores the single-precision results in the destination
   register.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-sqrtsd">
  <title><literal>SQRTSD</literal>: Scalar Double-Precision FP Square
   Root</title>

  <indexterm>
   <primary><literal>SQRTSD</literal></primary>
  </indexterm>

  <screen>SQRTSD xmm1,xmm2/m128         ; F2 0F 51 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>SQRTSD</literal> calculates the square root of the
   low-order double-precision FP value from the source operand, and
   stores the double-precision result in the destination register. The
   high-quadword remains unchanged.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-sqrtss">
  <title><literal>SQRTSS</literal>: Scalar Single-Precision FP Square
   Root</title>

  <indexterm>
   <primary><literal>SQRTSS</literal></primary>
  </indexterm>

  <screen>SQRTSS xmm1,xmm2/m128         ; F3 0F 51 /r     [KATMAI,SSE]</screen>

  <para><literal>SQRTSS</literal> calculates the square root of the
   low-order single-precision FP value from the source operand, and
   stores the single-precision result in the destination register. The
   three high doublewords remain unchanged.</para>
 </sect1>

 <sect1 id="inst-ref-stc">
  <title><literal>STC</literal>, <literal>STD</literal>,
   <literal>STI</literal>: Set Flags</title>

  <indexterm>
   <primary><literal>STC</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>STD</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>STI</literal></primary>
  </indexterm>

  <screen>STC                           ; F9                   [8086]
STD                           ; FD                   [8086]
STI                           ; FB                   [8086]</screen>

  <para>These instructions set various flags. <literal>STC</literal>
   sets the carry flag; <literal>STD</literal> sets the direction
   flag; and <literal>STI</literal> sets the interrupt flag (thus
   enabling interrupts).</para>

  <para>To clear the carry, direction, or interrupt flags, use the
   <literal>CLC</literal>, <literal>CLD</literal> and
   <literal>CLI</literal> instructions (<xref
    linkend="inst-ref-clc">).  To invert the carry flag, use
   <literal>CMC</literal> (<xref linkend="inst-ref-cmc">).</para>
 </sect1>

 <sect1 id="inst-ref-stmxcsr">
  <title><literal>STMXCSR</literal>: Store Streaming SIMD
   Extension Control/Status</title>

  <indexterm>
   <primary><literal>STMXCSR</literal></primary>
  </indexterm>
 
  <screen>STMXCSR m32                   ; 0F AE /3        [KATMAI,SSE]</screen>

  <para><literal>STMXCSR</literal> stores the contents of the
   <literal>MXCSR</literal> control/status register to the specified
   memory location.  <literal>MXCSR</literal> is used to enable
   masked/unmasked exception handling, to set rounding modes, to set
   flush-to-zero mode, and to view exception status flags.  The
   reserved bits in the <literal>MXCSR</literal> register are stored
   as 0s.</para>

  <para>For details of the <literal>MXCSR</literal> register, see the
   Intel processor docs.</para>

  <para>See also <literal>LDMXCSR</literal> (<xref
    linkend="inst-ref-ldmxcsr">).</para>
 </sect1>

 <sect1 id="inst-ref-stosb">
  <title><literal>STOSB</literal>, <literal>STOSW</literal>,
   <literal>STOSD</literal>: Store Byte to String</title>

  <indexterm>
   <primary><literal>STOSB</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>STOSW</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>STOSD</literal></primary>
  </indexterm>

  <screen>STOSB                         ; AA                   [8086]
STOSW                         ; o16 AB               [8086]
STOSD                         ; o32 AB               [386]</screen>

  <para><literal>STOSB</literal> stores the byte in &reg.al; at
   <literal>[&reg.es;:DI]</literal> or
   <literal>[&reg.es;:&reg.edi;]</literal>, and sets the flags
   accordingly. It then increments or decrements (depending on the
   direction flag: increments if the flag is clear, decrements if it
   is set) &reg.di; (or &reg.edi;).</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The register used is &reg.di; if the address size is 16 bits,
   and &reg.edi; if it is 32 bits. If you need to use an address size
   not equal to the current <literal>BITS</literal> setting, you can
   use an explicit <literal>a16</literal> or <literal>a32</literal>
   prefix.</para>

  <para>Segment override prefixes have no effect for this instruction:
   the use of &reg.es; for the store to <literal>[DI]</literal> or
   <literal>[&reg.edi;]</literal> cannot be overridden.</para>

  <para><literal>STOSW</literal> and <literal>STOSD</literal> work in
   the same way, but they store the word in &reg.ax; or the doubleword
   in &reg.eax; instead of the byte in &reg.al;, and increment or
   decrement the addressing registers by 2 or 4 instead of 1.</para>

  <para>The <literal>REP</literal> prefix may be used to repeat the
   instruction &reg.cx; (or &reg.ecx; - again, the address size
   chooses which) times.</para>
 </sect1>

 <sect1 id="inst-ref-str">
  <title><literal>STR</literal>: Store Task Register</title>

  <indexterm>
   <primary><literal>STR</literal></primary>
  </indexterm>

  <screen>STR r/m16                     ; 0F 00 /1             [286,PRIV]</screen>

  <para><literal>STR</literal> stores the segment selector
   corresponding to the contents of the Task Register into its
   operand.  When the operand size is a 16-bit register, the upper
   16-bits are cleared to 0s. When the destination operand is a memory
   location, 16 bits are written regardless of the operand
   size.</para>
 </sect1>

 <sect1 id="inst-ref-sub">
  <title><literal>SUB</literal>: Subtract Integers</title>

  <indexterm>
   <primary><literal>SUB</literal></primary>
  </indexterm>

  <screen>SUB r/m8,reg8                 ; 28 /r                [8086]
SUB r/m16,reg16               ; o16 29 /r            [8086]
SUB r/m32,reg32               ; o32 29 /r            [386]

SUB reg8,r/m8                 ; 2A /r                [8086]
SUB reg16,r/m16               ; o16 2B /r            [8086]
SUB reg32,r/m32               ; o32 2B /r            [386]

SUB r/m8,imm8                 ; 80 /5 ib             [8086]
SUB r/m16,imm16               ; o16 81 /5 iw         [8086]
SUB r/m32,imm32               ; o32 81 /5 id         [386]

SUB r/m16,imm8                ; o16 83 /5 ib         [8086]
SUB r/m32,imm8                ; o32 83 /5 ib         [386]

SUB AL,imm8                   ; 2C ib                [8086]
SUB AX,imm16                  ; o16 2D iw            [8086]
SUB EAX,imm32                 ; o32 2D id            [386]</screen>

  <para><literal>SUB</literal> performs integer subtraction: it
   subtracts its second operand from its first, and leaves the result
   in its destination (first) operand. The flags are set according to
   the result of the operation: in particular, the carry flag is
   affected and can be used by a subsequent <literal>SBB</literal>
   instruction (<xref linkend="inst-ref-sbb">).</para>

  <para>In the forms with an 8-bit immediate second operand and a
   longer first operand, the second operand is considered to be
   signed, and is sign-extended to the length of the first operand. In
   these cases, the <literal>BYTE</literal> qualifier is necessary to
   force NASM to generate this form of the instruction.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-subpd">
  <title><literal>SUBPD</literal>: Packed Double-Precision FP
   Subtract</title>

  <indexterm>
   <primary><literal>SUBPD</literal></primary>
  </indexterm>

  <screen>SUBPD xmm1,xmm2/m128          ; 66 0F 5C /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>SUBPD</literal> subtracts the packed double-precision
   FP values of the source operand from those of the destination
   operand, and stores the result in the destination operation.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-subps">
  <title><literal>SUBPS</literal>: Packed Single-Precision FP
   Subtract</title>

  <indexterm>
   <primary><literal>SUBPS</literal></primary>
  </indexterm>

  <screen>SUBPS xmm1,xmm2/m128          ; 0F 5C /r        [KATMAI,SSE]</screen>

  <para><literal>SUBPS</literal> subtracts the packed single-precision
   FP values of the source operand from those of the destination
   operand, and stores the result in the destination operation.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-subsd">
  <title><literal>SUBSD</literal>: Scalar Single-FP Subtract</title>

  <indexterm>
   <primary><literal>SUBSD</literal></primary>
  </indexterm>

  <screen>SUBSD xmm1,xmm2/m128          ; F2 0F 5C /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>SUBSD</literal> subtracts the low-order
   double-precision FP value of the source operand from that of the
   destination operand, and stores the result in the destination
   operation. The high quadword is unchanged.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-subss">
  <title><literal>SUBSS</literal>: Scalar Single-FP Subtract</title>

  <indexterm>
   <primary><literal>SUBSS</literal></primary>
  </indexterm>

  <screen>SUBSS xmm1,xmm2/m128          ; F3 0F 5C /r     [KATMAI,SSE]</screen>

  <para><literal>SUBSS</literal> subtracts the low-order
   single-precision FP value of the source operand from that of the
   destination operand, and stores the result in the destination
   operation. The three high doublewords are unchanged.</para>
 </sect1>

 <sect1 id="inst-ref-syscall">
  <title><literal>SYSCALL</literal>: Call Operating System</title>

  <indexterm>
   <primary><literal>SYSCALL</literal></primary>
  </indexterm>

  <screen>SYSCALL                       ; 0F 05                [P6,AMD]</screen>

  <para><literal>SYSCALL</literal> provides a fast method of
   transferring control to a fixed entry point in an operating
   system.</para>

  <itemizedlist>
   <listitem>
    <para>The &reg.eip; register is copied into the &reg.ecx;
     register.</para>
   </listitem>

   <listitem>
    <para>Bits [31-0] of the 64-bit SYSCALL/SYSRET Target Address
     Register (<literal>STAR</literal>) are copied into the &reg.eip;
     register.</para>
   </listitem>

   <listitem>
    <para>Bits [47-32] of the <literal>STAR</literal> register specify
     the selector that is copied into the &reg.cs; register.</para>
   </listitem>

   <listitem>
    <para>Bits [47-32]+1000b of the <literal>STAR</literal> register
     specify the selector that is copied into the &reg.ss;
     register.</para>
   </listitem>
  </itemizedlist>

  <para>The &reg.cs; and &reg.ss; registers should not be modified by
   the operating system between the execution of the
   <literal>SYSCALL</literal> instruction and its corresponding
   <literal>SYSRET</literal> instruction.</para>

  <para>For more information, see the <quote>SYSCALL and SYSRET
    Instruction Specification</quote> (AMD document number
   21086.pdf).</para>
 </sect1>

 <sect1 id="inst-ref-sysenter">
  <title><literal>SYSENTER</literal>: Fast System Call</title>

  <indexterm>
   <primary><literal>SYSENTER</literal></primary>
  </indexterm>

  <screen>SYSENTER                      ; 0F 34                [P6]</screen>

  <para><literal>SYSENTER</literal> executes a fast call to a level 0
   system procedure or routine.  Before using this instruction,
   various MSRs need to be set up:</para>

  <itemizedlist>
   <listitem>
    <para><literal>SYSENTER_CS_MSR</literal> contains the 32-bit
     segment selector for the privilege level 0 code segment. (This
     value is also used to compute the segment selector of the
     privilege level 0 stack segment.)</para>
   </listitem>

   <listitem>
    <para><literal>SYSENTER_EIP_MSR</literal> contains the 32-bit
     offset into the privilege level 0 code segment to the first
     instruction of the selected operating procedure or
     routine.</para>
   </listitem>

   <listitem>
    <para><literal>SYSENTER_ESP_MSR</literal> contains the 32-bit
     stack pointer for the privilege level 0 stack.</para>
   </listitem>
  </itemizedlist>

  <para><literal>SYSENTER</literal> performs the following sequence of
   operations:</para>

  <itemizedlist>
   <listitem>
    <para>Loads the segment selector from the
     <literal>SYSENTER_CS_MSR</literal> into the &reg.cs;
     register.</para>
   </listitem>

   <listitem>
    <para>Loads the instruction pointer from the
     <literal>SYSENTER_EIP_MSR</literal> into the &reg.eip;
     register.</para>
   </listitem>

   <listitem>
    <para>Adds 8 to the value in <literal>SYSENTER_CS_MSR</literal>
     and loads it into the &reg.ss; register.</para>
   </listitem>

   <listitem>
    <para>Loads the stack pointer from the
     <literal>SYSENTER_ESP_MSR</literal> into the &reg.esp;
     register.</para>
   </listitem>

   <listitem>
    <para>Switches to privilege level 0.</para>
   </listitem>

   <listitem>
    <para>Clears the &flag.vm; flag in the <literal>EFLAGS</literal>
     register, if the flag is set.</para>
   </listitem>

   <listitem>
    <para>Begins executing the selected system procedure.</para>
   </listitem>
  </itemizedlist>

  <para>In particular, note that this instruction des not save the
   values of &reg.cs; or &reg.eip;. If you need to return to the
   calling code, you need to write your code to cater for this.</para>

  <para>For more information, see the <quote>Intel Architecture
    Software Developer's Manual, Volume 2</quote>.</para>
 </sect1>

 <sect1 id="inst-ref-sysexit">
  <title><literal>SYSEXIT</literal>: Fast Return From System
   Call</title>

  <indexterm>
   <primary><literal>SYSEXIT</literal></primary>
  </indexterm>

  <screen>SYSEXIT                       ; 0F 35                [P6,PRIV]</screen>

  <para><literal>SYSEXIT</literal> executes a fast return to privilege
   level 3 user code. This instruction is a companion instruction to
   the <literal>SYSENTER</literal> instruction, and can only be
   executed by privilege level 0 code. Various registers need to be
   set up before calling this instruction:</para>

  <itemizedlist>
   <listitem>
    <para><literal>SYSENTER_CS_MSR</literal> contains the 32-bit
     segment selector for the privilege level 0 code segment in which
     the processor is currently executing. (This value is used to
     compute the segment selectors for the privilege level 3 code and
     stack segments.)</para>
   </listitem>

   <listitem>
    <para>&reg.edx; contains the 32-bit offset into the privilege
     level 3 code segment to the first instruction to be executed in
     the user code.</para>
   </listitem>

   <listitem>
    <para>&reg.ecx; contains the 32-bit stack pointer for the
     privilege level 3 stack.</para>
   </listitem>
  </itemizedlist>

  <para><literal>SYSEXIT</literal> performs the following sequence of
   operations:</para>

  <itemizedlist>
   <listitem>
    <para>Adds 16 to the value in <literal>SYSENTER_CS_MSR</literal>
     and loads the sum into the &reg.cs; selector register.</para>
   </listitem>

   <listitem>
    <para>Loads the instruction pointer from the &reg.edx; register
     into the &reg.eip; register.</para>
   </listitem>

   <listitem>
    <para>Adds 24 to the value in <literal>SYSENTER_CS_MSR</literal>
     and loads the sum into the &reg.ss; selector register.</para>
   </listitem>

   <listitem>
    <para>Loads the stack pointer from the &reg.ecx; register into the
     &reg.esp; register.</para>
   </listitem>

   <listitem>
    <para>Switches to privilege level 3.</para>
   </listitem>

   <listitem>
    <para>Begins executing the user code at the &reg.eip;
     address.</para>
   </listitem>
  </itemizedlist>

  <para>For more information on the use of the
   <literal>SYSENTER</literal> and <literal>SYSEXIT</literal>
   instructions, see the <quote>Intel Architecture Software
    Developer's Manual, Volume 2</quote>.</para>
 </sect1>

 <sect1 id="inst-ref-sysret">
  <title><literal>SYSRET</literal>: Return From Operating
   System</title>

  <indexterm>
   <primary><literal>SYSRET</literal></primary>
  </indexterm>

  <screen>SYSRET                        ; 0F 07                [P6,AMD,PRIV]</screen>

  <para><literal>SYSRET</literal> is the return instruction used in
   conjunction with the <literal>SYSCALL</literal> instruction to
   provide fast entry/exit to an operating system.</para>

  <itemizedlist>
   <listitem>
    <para>The &reg.ecx; register, which points to the next sequential
     instruction after the corresponding <literal>SYSCALL</literal>
     instruction, is copied into the &reg.eip; register.</para>
   </listitem>

   <listitem>
    <para>Bits [63-48] of the <literal>STAR</literal> register specify
     the selector that is copied into the &reg.cs; register.</para>
   </listitem>

   <listitem>
    <para>Bits [63-48]+1000b of the <literal>STAR</literal> register
     specify the selector that is copied into the &reg.ss;
     register.</para>
   </listitem>

   <listitem>
    <para>Bits [1-0] of the &reg.ss; register are set to 11b (RPL of
     3) regardless of the value of bits [49-48] of the
     <literal>STAR</literal> register.</para>
   </listitem>
  </itemizedlist>

  <para>The &reg.cs; and &reg.ss; registers should not be modified by
   the operating system between the execution of the
   <literal>SYSCALL</literal> instruction and its corresponding
   <literal>SYSRET</literal> instruction.</para>

  <para>For more information, see the <quote>SYSCALL and SYSRET
    Instruction Specification</quote> (AMD document number
   21086.pdf).</para>
 </sect1>

 <sect1 id="inst-ref-test">
  <title><literal>TEST</literal>: Test Bits (notional bitwise
   AND)</title>

  <indexterm>
   <primary><literal>TEST</literal></primary>
  </indexterm>

  <screen>TEST r/m8,reg8                ; 84 /r                [8086]
TEST r/m16,reg16              ; o16 85 /r            [8086]
TEST r/m32,reg32              ; o32 85 /r            [386]

TEST r/m8,imm8                ; F6 /0 ib             [8086]
TEST r/m16,imm16              ; o16 F7 /0 iw         [8086]
TEST r/m32,imm32              ; o32 F7 /0 id         [386]

TEST AL,imm8                  ; A8 ib                [8086]
TEST AX,imm16                 ; o16 A9 iw            [8086]
TEST EAX,imm32                ; o32 A9 id            [386]</screen>

  <para><literal>TEST</literal> performs a <quote>mental</quote>
   bitwise AND of its two operands, and affects the flags as if the
   operation had taken place, but does not store the result of the
   operation anywhere.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-ucomisd">
  <title><literal>UCOMISD</literal>: Unordered Scalar Double-Precision
   FP compare and set EFLAGS</title>

  <indexterm>
   <primary><literal>UCOMISD</literal></primary>
  </indexterm>

  <screen>UCOMISD xmm1,xmm2/m128        ; 66 0F 2E /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>UCOMISS</literal> compares the low-order
   double-precision FP numbers in the two operands, and sets the
   &flag.zf;, &flag.pf;, and &flag.cf; bits in the
   <literal>EFLAGS</literal> register. In addition, the &flag.of;,
   &flag.sf; and &flag.af; bits in the <literal>EFLAGS</literal>
   register are zeroed out. The unordered predicate (&flag.zf;,
   &flag.pf;, and &flag.cf; all set) is returned if either source
   operand is a <literal>NaN</literal> (<literal>qNaN</literal> or
   <literal>sNaN</literal>).</para>
 </sect1>
]]>
 <sect1 id="inst-ref-ucomiss">
  <title><literal>UCOMISS</literal>: Unordered Scalar Single-Precision
   FP compare and set EFLAGS</title>

  <indexterm>
   <primary><literal>UCOMISS</literal></primary>
  </indexterm>

  <screen>UCOMISS xmm1,xmm2/m128        ; 0F 2E /r        [KATMAI,SSE]</screen>

  <para><literal>UCOMISS</literal> compares the low-order
   single-precision FP numbers in the two operands, and sets the
   &flag.zf;, &flag.pf;, and &flag.cf; bits in the
   <literal>EFLAGS</literal> register. In addition, the &flag.of;,
   &flag.sf; and &flag.af; bits in the <literal>EFLAGS</literal>
   register are zeroed out. The unordered predicate (&flag.zf;,
   &flag.pf;, and &flag.cf; all set) is returned if either source
   operand is a <literal>NaN</literal> (<literal>qNaN</literal> or
   <literal>sNaN</literal>).</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-unpckhpd">
  <title><literal>UNPCKHPD</literal>: Unpack and Interleave High
   Packed Double-Precision FP Values</title>

  <indexterm>
   <primary><literal>UNPCKHPD</literal></primary>
  </indexterm>

  <screen>UNPCKHPD xmm1,xmm2/m128       ; 66 0F 15 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>UNPCKHPD</literal> performs an interleaved unpack of
   the high-order data elements of the source and destination
   operands, saving the result in xmm1. It ignores the lower half of
   the sources.</para>

  <para>The operation of this instruction is:</para>

  <screen>   dst[63-0]   := dst[127-64];
   dst[127-64] := src[127-64].</screen>
 </sect1>
]]>
 <sect1 id="inst-ref-unpckhps">
  <title><literal>UNPCKHPS</literal>: Unpack and Interleave High
   Packed Single-Precision FP Values</title>

  <indexterm>
   <primary><literal>UNPCKHPS</literal></primary>
  </indexterm>

  <screen>UNPCKHPS xmm1,xmm2/m128       ; 0F 15 /r        [KATMAI,SSE]</screen>

  <para><literal>UNPCKHPS</literal> performs an interleaved unpack of
   the high-order data elements of the source and destination
   operands, saving the result in xmm1. It ignores the lower half of
   the sources.</para>

  <para>The operation of this instruction is:</para>

  <screen>   dst[31-0]   := dst[95-64];
   dst[63-32]  := src[95-64];
   dst[95-64]  := dst[127-96];
   dst[127-96] := src[127-96].</screen>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-unpcklpd">
  <title><literal>UNPCKLPD</literal>: Unpack and Interleave Low Packed
   Double-Precision FP Data</title>

  <indexterm>
   <primary><literal>UNPCKLPD</literal></primary>
  </indexterm>

  <screen>UNPCKLPD xmm1,xmm2/m128       ; 66 0F 14 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>UNPCKLPD</literal> performs an interleaved unpack of
   the low-order data elements of the source and destination operands,
   saving the result in xmm1. It ignores the lower half of the
   sources.</para>

  <para>The operation of this instruction is:</para>

  <screen>   dst[63-0]   := dst[63-0];
   dst[127-64] := src[63-0].</screen>
 </sect1>
]]>
 <sect1 id="inst-ref-unpcklps">
  <title><literal>UNPCKLPS</literal>: Unpack and Interleave Low Packed
   Single-Precision FP Data</title>

  <indexterm>
   <primary><literal>UNPCKLPS</literal></primary>
  </indexterm>

  <screen>UNPCKLPS xmm1,xmm2/m128       ; 0F 14 /r        [KATMAI,SSE]</screen>

  <para><literal>UNPCKLPS</literal> performs an interleaved unpack of
   the low-order data elements of the source and destination operands,
   saving the result in xmm1. It ignores the lower half of the
   sources.</para>

  <para>The operation of this instruction is:</para>

  <screen>   dst[31-0]   := dst[31-0];
   dst[63-32]  := src[31-0];
   dst[95-64]  := dst[63-32];
   dst[127-96] := src[63-32].</screen>
 </sect1>

 <sect1 id="inst-ref-verr">
  <title><literal>VERR</literal>, <literal>VERW</literal>: Verify
   Segment Readability/Writability</title>

  <indexterm>
   <primary><literal>VERR</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>VERW</literal></primary>
  </indexterm>

  <screen>VERR r/m16                    ; 0F 00 /4             [286,PRIV]

VERW r/m16                    ; 0F 00 /5             [286,PRIV]</screen>

  <itemizedlist>
   <listitem>
    <para><literal>VERR</literal> sets the zero flag if the segment
     specified by the selector in its operand can be read from at the
     current privilege level.</para>
   </listitem>

   <listitem>
    <para><literal>VERW</literal> sets the zero flag if the segment
     can be written.</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="inst-ref-wait">
  <title><literal>WAIT</literal>: Wait for Floating-Point
   Processor</title>

  <indexterm>
   <primary><literal>WAIT</literal></primary>
  </indexterm>

  <screen>WAIT                          ; 9B                   [8086]
FWAIT                         ; 9B                   [8086]</screen>

  <para><literal>WAIT</literal>, on 8086 systems with a separate 8087
   FPU, waits for the FPU to have finished any operation it is engaged
   in before continuing main processor operations, so that (for
   example) an FPU store to main memory can be guaranteed to have
   completed before the CPU tries to read the result back out.</para>

  <para>On higher processors, <literal>WAIT</literal> is unnecessary
   for this purpose, and it has the alternative purpose of ensuring
   that any pending unmasked FPU exceptions have happened before
   execution continues.</para>
 </sect1>

 <sect1 id="inst-ref-wbinvd">
  <title><literal>WBINVD</literal>: Write Back and Invalidate Cache</title>

  <indexterm>
   <primary><literal>WBINVD</literal></primary>
  </indexterm>

  <screen>WBINVD                        ; 0F 09                [486]</screen>

  <para><literal>WBINVD</literal> invalidates and empties the
   processor's internal caches, and causes the processor to instruct
   external caches to do the same. It writes the contents of the
   caches back to memory first, so no data is lost. To flush the
   caches quickly without bothering to write the data back first, use
   <literal>INVD</literal> (<xref linkend="inst-ref-invd">).</para>
 </sect1>

 <sect1 id="inst-ref-wrmsr">
  <title><literal>WRMSR</literal>: Write Model-Specific Registers</title>

  <indexterm>
   <primary><literal>WRMSR</literal></primary>
  </indexterm>

  <screen>WRMSR                         ; 0F 30                [PENT]</screen>

  <para><literal>WRMSR</literal> writes the value in
   <literal>&reg.edx;:&reg.eax;</literal> to the processor
   Model-Specific Register (MSR) whose index is stored in &reg.ecx;.
   See also <literal>RDMSR</literal> (<xref
    linkend="inst-ref-rdmsr">).</para>
 </sect1>

 <sect1 id="inst-ref-xadd">
  <title><literal>XADD</literal>: Exchange and Add</title>

  <indexterm>
   <primary><literal>XADD</literal></primary>
  </indexterm>

  <screen>XADD r/m8,reg8                ; 0F C0 /r             [486]
XADD r/m16,reg16              ; o16 0F C1 /r         [486]
XADD r/m32,reg32              ; o32 0F C1 /r         [486]</screen>

  <para><literal>XADD</literal> exchanges the values in its two
   operands, and then adds them together and writes the result into
   the destination (first) operand. This instruction can be used with
   a <literal>LOCK</literal> prefix for multi-processor
   synchronisation purposes.</para>
 </sect1>

 <sect1 id="inst-ref-xchg">
  <title><literal>XCHG</literal>: Exchange</title>

  <indexterm>
   <primary><literal>XCHG</literal></primary>
  </indexterm>

  <screen>XCHG reg8,r/m8                ; 86 /r                [8086]
XCHG reg16,r/m8               ; o16 87 /r            [8086]
XCHG reg32,r/m32              ; o32 87 /r            [386]

XCHG r/m8,reg8                ; 86 /r                [8086]
XCHG r/m16,reg16              ; o16 87 /r            [8086]
XCHG r/m32,reg32              ; o32 87 /r            [386]

XCHG AX,reg16                 ; o16 90+r             [8086]
XCHG EAX,reg32                ; o32 90+r             [386]
XCHG reg16,AX                 ; o16 90+r             [8086]
XCHG reg32,EAX                ; o32 90+r             [386]</screen>

  <para><literal>XCHG</literal> exchanges the values in its two
   operands. It can be used with a <literal>LOCK</literal> prefix for
   purposes of multi-processor synchronisation.</para>

  <para><literal>XCHG AX,AX</literal> or <literal>XCHG
    EAX,EAX</literal> (depending on the <literal>BITS</literal>
   setting) generates the opcode <literal>90h</literal>, and so is a
   synonym for <literal>NOP</literal> (<xref
    linkend="inst-ref-nop">).</para>
 </sect1>

 <sect1 id="inst-ref-xlatb">
  <title><literal>XLATB</literal>: Translate Byte in Lookup
   Table</title>

  <indexterm>
   <primary><literal>XLATB</literal></primary>
  </indexterm>

  <screen>XLAT                          ; D7                   [8086]
XLATB                         ; D7                   [8086]</screen>

  <para><literal>XLATB</literal> adds the value in &reg.al;, treated
   as an unsigned byte, to &reg.bx; or &reg.ebx;, and loads the byte
   from the resulting address (in the segment specified by &reg.ds;)
   back into &reg.al;.</para>

  <indexterm>
   <primary><literal>a16</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>a32</literal></primary>
  </indexterm>

  <para>The base register used is &reg.bx; if the address size is 16
   bits, and &reg.ebx; if it is 32 bits. If you need to use an address
   size not equal to the current <literal>BITS</literal> setting, you
   can use an explicit <literal>a16</literal> or
   <literal>a32</literal> prefix.</para>

  <para>The segment register used to load from
   <literal>[&reg.bx;+&reg.al;]</literal> or
   <literal>[&reg.ebx;+&reg.al;]</literal> can be overridden by using
   a segment register name as a prefix (for example, <literal>es
    xlatb</literal>).</para>
 </sect1>

 <sect1 id="inst-ref-xor">
  <title><literal>XOR</literal>: Bitwise Exclusive OR</title>

  <indexterm>
   <primary><literal>XOR</literal></primary>
  </indexterm>

  <screen>XOR r/m8,reg8                 ; 30 /r                [8086]
XOR r/m16,reg16               ; o16 31 /r            [8086]
XOR r/m32,reg32               ; o32 31 /r            [386]

XOR reg8,r/m8                 ; 32 /r                [8086]
XOR reg16,r/m16               ; o16 33 /r            [8086]
XOR reg32,r/m32               ; o32 33 /r            [386]

XOR r/m8,imm8                 ; 80 /6 ib             [8086]
XOR r/m16,imm16               ; o16 81 /6 iw         [8086]
XOR r/m32,imm32               ; o32 81 /6 id         [386]

XOR r/m16,imm8                ; o16 83 /6 ib         [8086]
XOR r/m32,imm8                ; o32 83 /6 ib         [386]

XOR AL,imm8                   ; 34 ib                [8086]
XOR AX,imm16                  ; o16 35 iw            [8086]
XOR EAX,imm32                 ; o32 35 id            [386]</screen>

  <para><literal>XOR</literal> performs a bitwise XOR operation
   between its two operands (i.e. each bit of the result is 1 if and
   only if exactly one of the corresponding bits of the two inputs was
   1), and stores the result in the destination (first)
   operand.</para>

  <para>In the forms with an 8-bit immediate second operand and a
   longer first operand, the second operand is considered to be
   signed, and is sign-extended to the length of the first operand. In
   these cases, the <literal>BYTE</literal> qualifier is necessary to
   force NASM to generate this form of the instruction.</para>

  <para>The &reg.mmx; instruction <literal>PXOR</literal> (see <xref
    linkend="inst-ref-pxor">) performs the same operation on the
   64-bit &reg.mmx; registers.</para>
 </sect1>
<![%inst-ref.sse2;[
 <sect1 id="inst-ref-xorpd">
  <title><literal>XORPD</literal>: Bitwise Logical XOR of
   Double-Precision FP Values</title>

  <indexterm>
   <primary><literal>XORPD</literal></primary>
  </indexterm>

  <screen>XORPD xmm1,xmm2/m128          ; 66 0F 57 /r     [WILLAMETTE,SSE2]</screen>

  <para><literal>XORPD</literal> returns a bit-wise logical XOR
   between the source and destination operands, storing the result in
   the destination operand.</para>
 </sect1>
]]>
 <sect1 id="inst-ref-xorps">
  <title><literal>XORPS</literal>: Bitwise Logical XOR of
   Single-Precision FP Values</title>

  <indexterm>
   <primary><literal>XORPS</literal></primary>
  </indexterm>

  <screen>XORPS xmm1,xmm2/m128          ; 0F 57 /r        [KATMAI,SSE]</screen>

  <para><literal>XORPS</literal> returns a bit-wise logical XOR
   between the source and destination operands, storing the result in
   the destination operand.</para>
 </sect1>
</appendix>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../appendix.decl"
     sgml-indent-data: t
     sgml-indent-step: 1
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "appendix")
     End:
-->
